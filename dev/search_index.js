var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"using Markdown\nusing Pkg\nusing MultiGridBarrier\nv = string(pkgversion(MultiGridBarrier))\nmd\"# MultiGridBarrier $v\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"MultiGridBarrier is a Julia module for solving nonlinear convex optimization problems in function spaces, such as p-Laplace problems. When regularity conditions are satisfied, the solvers are quasi-optimal.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The MultiGridBarrier module features finite element and spectral discretizations in 1d and 2d.","category":"page"},{"location":"#Finite-elements","page":"Home","title":"Finite elements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"After installing MultiGridBarrier with the Julia package manager, in a Jupyter notebook, one solves a 1d p-Laplace problem as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using PyPlot # hide\nusing MultiGridBarrier\nfem1d_solve(L=5,p=1.0,verbose=false);\nsavefig(\"fem1d.svg\"); nothing # hide\nclose() #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"A 2d p-Laplace problem:","category":"page"},{"location":"","page":"Home","title":"Home","text":"fem2d_solve(L=3,p=1.0,verbose=false);\nsavefig(\"fem2d.svg\"); nothing # hide\nclose() #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#Spectral-elements","page":"Home","title":"Spectral elements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Solve a 1d p-Laplace problem using spectral methods as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"spectral1d_solve(n=40,p=1.0,verbose=false);\nsavefig(\"spectral1d.svg\"); nothing # hide\nclose() #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"A 2d p-Laplace problem:","category":"page"},{"location":"","page":"Home","title":"Home","text":"spectral2d_solve(n=5,p=1.5,verbose=false);\nsavefig(\"spectral2d.svg\"); nothing # hide\nclose() #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#Solving-\\infty-Laplacians","page":"Home","title":"Solving infty-Laplacians","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For p geq 1 and domain Omega, the solution u of the p-Laplace problem is the minimizer of J(u) = nabla u_L^p(Omega)^p + int_Omega fu where u is in a suitable space of function satisfying, e.g. Dirichlet conditions, and f is a forcing. This definition must be modified for the infty-Laplace problem. Here we show how to minimize: J(u) = nabla u_L^infty(Omega)^p + int_Omega fu We put p=1 for simplicity.","category":"page"},{"location":"","page":"Home","title":"Home","text":"fem1d_solve(L=5,p=1.0,state_variables=[:u :dirichlet; :s :uniform],verbose=false);\nsavefig(\"fem1dinfty.svg\"); nothing # hide\nclose() #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#Parabolic-problems","page":"Home","title":"Parabolic problems","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A time-dependent problem:","category":"page"},{"location":"","page":"Home","title":"Home","text":"parabolic_solve(h=0.1,L=3,printer=anim->anim.save(\"parabolic.mp4\"),verbose=false);\nclose() #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"<video src=\"parabolic.mp4\" width=\"600\" controls autoplay loop></video>","category":"page"},{"location":"#Module-reference","page":"Home","title":"Module reference","text":"","category":"section"},{"location":"#MultiGridBarrier.MultiGridBarrier","page":"Home","title":"MultiGridBarrier.MultiGridBarrier","text":"module MultiGridBarrier\n\nModule MultiGridBarrier solves convex optimization problems in function spaces, for example, solving p-Laplace problems. We recommend to start with the functions fem1d_solve(), fem2d_solve(), spectral1d_solve(), spectral2d_solve(). These functions are sufficient to solve p-Laplace problems in 1d or 2d, using finite or spectral elements.\n\nFor more general use, the user will need to familiarize themselves with the basic ideas of convex optimization.\n\nOverview of convex optimization in function spaces by MultiGrid Barrier method.\n\nThe general idea is to build a multigrid hierarchy, represented by an AMG object, and barrier for a convex set, represented by a Barrier object, and then solve a convex optimization problem using the amgb() solver.\n\nTo generate the multigrid hierarchy represented by the AMG object, use either fem1d(), fem2d(), spectral1d() or spectral2d() functions. These constructors will assemble suitable AMG objects for either FEM or spectral discretizations, in 1d or 2d. One should think of these four constructors as being specialized in constructing some specific function spaces. A user can use the amg() constructor directly if custom function spaces are required, but this is more difficult.\n\nWe now describe the barrier function.\n\nAssume that Omega subset mathbbR^d is some open set. Consider the example of the p-Laplace problem on Omega. Let f(x) be a \"forcing\" (a function) on Omega, and 1 leq p  infty. One wishes to solve the minimization problem\n\nbeginequation\ninf_u int_Omega fu + nabla u_2^p  dx tag1\nendequation\n\nGenerally speaking, u will range in some function space, e.g. a space of differentiable functions satisfying homogeneous Dirichlet conditions. Under some conditions, minimizing (1) is equivalent to solving the p-Laplace PDE:\n\nnabla cdot (nabla u_2^p-2nabla u) = 1 over p f\n\nWe introduce the \"slack function\" s(x) and replace (1) with the following equivalent problem:\n\nbeginequation\ninf_s(x) geq nabla u(x)_2^p int_Omega fu + s  dx tag2\nendequation\n\nDefine the convex set mathcalQ =  (u(x)q(x)s(x))    s(x) geq q(x)_2^p , and\n\nz = beginbmatrix u  s endbmatrix qquad\nc^T = f01 qquad\nDz = beginbmatrix u  nabla u  s endbmatrix\n\nThen, (2) can be rewritten as\n\nbeginequation\ninf_Dz in mathcalQ int_Omega c^T(x)Dz(x)  dx tag3\nendequation\n\nRecall that a barrier for mathcalQ is a convex function mathcalF on mathcalQ such that mathcalF  infty in the interior of mathcalQ and mathcalF = infty on the boundary of mathcalQ. A barrier for the p-Laplace problem is:\n\nmathcalF(uqs) = int_Omega -log(s^2 over p - q_2^2) - 2log s  dx = int_Omega F(Dz(x))  dx\n\nThe central path z^*(t) minimizes, for each fixed t0, the quantity\n\nint_Omega tc^TDz + F(Dz)  dx\n\nAs t to infty, z^*(t) forms a minimizing sequence (or filter) for (3). We think of the function c(x) as the \"functional\" that we seek to minimize.\n\nThe Convex{T} type describes various convex sets (denoted Q above) by way of functions barrier(), cobarrier() and slack(). barrier is indeed a barrier for Q, cobarrier() is a barrier for a related feasibility problems, and slack() is used in solving the feasibility problem. Convex{T} objects can be created using the various convex_...() constructors, e.g. convex_Euclidian_power() for the p-Laplace problem.\n\nOnce one has AMG and Convex objects, and a suitable \"functional\" c, one uses the amgb() function to solve the optimization problem by the MultiGrid Barrier method, a variant of the barrier method (or interior point method) that is quasi-optimal for sufficiently regular problems.\n\n\n\n\n\n","category":"module"},{"location":"#Types-reference","page":"Home","title":"Types reference","text":"","category":"section"},{"location":"#MultiGridBarrier.AMGBConvergenceFailure","page":"Home","title":"MultiGridBarrier.AMGBConvergenceFailure","text":"AMGBConvergenceFailure <: Exception\n\nThrown when the AMGB solver fails to converge (feasibility or main phase). Includes a descriptive message about the failure.\n\n\n\n\n\n","category":"type"},{"location":"#MultiGridBarrier.Convex","page":"Home","title":"MultiGridBarrier.Convex","text":"Convex{T}\n\nContainer for a convex constraint set used by AMGB.\n\nFields:\n\nbarrier(x, y): barrier of the set\ncobarrier(x, yhat): barrier with slack for feasibility\nslack(x, y): initial slack value\n\nConstruct via helpers like convex_linear, convex_Euclidian_power, convex_piecewise, or intersect.\n\n\n\n\n\n","category":"type"},{"location":"#MultiGridBarrier.FEM1D","page":"Home","title":"MultiGridBarrier.FEM1D","text":"FEM1D\n\n1D FEM geometry descriptor. Field: L::Int (levels). Use with amgb.\n\n\n\n\n\n","category":"type"},{"location":"#MultiGridBarrier.FEM2D","page":"Home","title":"MultiGridBarrier.FEM2D","text":"FEM2D{T}\n\n2D FEM geometry descriptor for quadratic+bubble triangles. Fields: K::Matrix{T} (3n×2 mesh), L::Int (levels). Use with amgb.\n\n\n\n\n\n","category":"type"},{"location":"#MultiGridBarrier.SPECTRAL1D","page":"Home","title":"MultiGridBarrier.SPECTRAL1D","text":"SPECTRAL1D\n\n1D spectral geometry descriptor (Chebyshev). Field: n::Int (nodes). Use with amgb.\n\n\n\n\n\n","category":"type"},{"location":"#MultiGridBarrier.SPECTRAL2D","page":"Home","title":"MultiGridBarrier.SPECTRAL2D","text":"SPECTRAL2D\n\n2D spectral geometry descriptor (tensor Chebyshev). Field: n::Int (nodes per dim). Use with amgb.\n\n\n\n\n\n","category":"type"},{"location":"#Functions-reference","page":"Home","title":"Functions reference","text":"","category":"section"},{"location":"#Base.intersect-Union{Tuple{T}, Tuple{Convex{T}, Vararg{Any}}} where T","page":"Home","title":"Base.intersect","text":"intersect(U::Convex{T}, rest...) where {T}\n\nReturn the intersection of convex domains as a single Convex{T}. Equivalent to convex_piecewise with all pieces active.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.amgb-Union{Tuple{}, Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T","page":"Home","title":"MultiGridBarrier.amgb","text":"amgb(geometry=fem1d(), ::Type{T}=get_T(geometry); kwargs...)\n\nAlgebraic MultiGrid Barrier (AMGB) solver for nonlinear convex optimization problems  in function spaces using multigrid barrier methods.\n\nThis is the main high-level entry point for solving p-Laplace and related problems using the barrier method with multigrid acceleration. The solver operates in two phases:\n\nFeasibility phase: Finds an interior point for the constraint set (if needed)\nMain optimization phase: Solves the barrier-augmented optimization problem\n\nArguments\n\ngeometry: Discretization geometry (default: fem1d()). Options: \nfem1d(L=n): 1D finite elements with 2^L elements\nfem2d(L=n, K=mesh): 2D finite elements \nspectral1d(n=m): 1D spectral with m nodes\nspectral2d(n=m): 2D spectral with m×m nodes\nT::Type: Numeric type (default: inferred from geometry via get_T(geometry))\n\nKeyword Arguments\n\nProblem Specification\n\ndim::Integer = amg_dim(geometry): Problem dimension (1 or 2), auto-detected from geometry\nstate_variables::Matrix{Symbol} = [:u :dirichlet; :s :full]: Solution components and their function spaces\nD::Matrix{Symbol} = default_D[dim]: Differential operators to apply to state variables\nx::Matrix{T} = M[1].x: Mesh/sample points where f and g are evaluated when they are functions\n\nDiscretization Control\n\nM = amg(geometry;state_variables,D): AMG hierarchy\n\nProblem Data\n\np::T = 1.0: Exponent for p-Laplace operator (p ≥ 1)\ng::Function = default_g(T)[dim]: Boundary conditions/initial guess (function of spatial coordinates)\ng_grid::Matrix{T}: Alternative to g, directly provide values on grid (default: g evaluated at x)\nf::Function = default_f(T)[dim]: Forcing term/cost functional (function of spatial coordinates)\nf_grid::Matrix{T}: Alternative to f, directly provide values on grid (default: f evaluated at x)\nQ::Convex{T} = convex_Euclidian_power(T, idx=2:dim+2, p=x->p): Convex constraint set\n\nOutput Control\n\nverbose::Bool = true: Display progress bar during solving\nshow::Bool = true: Plot the computed solution using PyPlot (requires PyPlot.jl)\nreturn_details::Bool = false: \nfalse: Return only the solution matrix z\ntrue: Return full solution object with detailed solver information\nlogfile = devnull: IO stream for logging (default: no file logging)\n\nSolver Control\n\nPassthrough Arguments\n\nAdditional keyword arguments are passed through to internal solver components:\n\ntol = sqrt(eps(T)): Stopping tolerance; the method stops once 1/t < tol where t is the barrier parameter\nt = T(0.1): Initial barrier parameter for the main solve\nt_feasibility = t: Initial barrier parameter for the feasibility solve\nmaxit = 10000: Maximum number of barrier iterations\nkappa = T(10.0): Initial step size multiplier for barrier parameter t. Adapted dynamically but never exceeds this initial value\nc0 = T(0): Base offset added to the objective (c0 + t*c)\nearly_stop = z->false: Function z -> Bool; if true, the iteration halts early (e.g., to stop feasibility phase when interior point found)\nmax_newton = ceil((log2(-log2(eps(T))))+2): Maximum Newton iterations per inner solve\nstopping_criterion = stopping_inexact(sqrt(minimum(M[1].w))/2, T(0.5)): Stopping criterion for Newton solver. Options:\nstopping_exact(theta): Check if objective decreased and gradient norm fell below tolerance\nstopping_inexact(lambda_tol, theta): Inexact Newton with mesh-dependent tolerance\nline_search = linesearch_backtracking(T): Line search strategy. Options:\nlinesearch_backtracking(T): Backtracking line search (default)\nlinesearch_illinois(T): Illinois algorithm-based line search\nfinalize = stopping_exact(T(0.5)): Finalization stopping criterion for the last Newton solve (stricter convergence)\n\nDefault Values\n\nThe defaults for f, g, and D depend on the problem dimension:\n\n1D Problems\n\nf(x) = [0.5, 0.0, 1.0] - Forcing term\ng(x) = [x[1], 2] - Boundary conditions  \nD = [:u :id; :u :dx; :s :id] - Identity, derivative, identity\n\n2D Problems\n\nf(x) = [0.5, 0.0, 0.0, 1.0] - Forcing term\ng(x) = [x[1]²+x[2]², 100.0] - Boundary conditions\nD = [:u :id; :u :dx; :u :dy; :s :id] - Identity, x-derivative, y-derivative, identity\n\nReturns\n\nIf return_details=false (default): Matrix of size (n_nodes, n_components) containing the solution\nIf return_details=true: NamedTuple with fields:\nz: Solution matrix of size (n_nodes, n_components) containing the computed solution\nSOL_feasibility: Feasibility phase results (nothing if initial point was already feasible), otherwise a solution object (see below)\nSOL_main: Main optimization phase results as a solution object (see below)\nlog: String containing detailed iteration log for debugging\nEach solution object (SOL_feasibility and SOL_main) is a NamedTuple containing:\nz: Solution vector (flattened; for feasibility phase includes auxiliary slack variable)\nz_unfinalized: Solution before final refinement step\nc: Cost functional used in this phase\nits: Iteration counts across levels and barrier steps (L×k matrix where L is number of levels, k is number of barrier iterations)\nts: Sequence of barrier parameters t used (length k)\nkappas: Step size multipliers used at each iteration (length k)\ntimes: Wall-clock timestamps for each iteration (length k)\nM: The AMG hierarchy used (M[2] for feasibility, M[1] for main)\nt_begin, t_end, t_elapsed: Timing information for this phase\npassed: Boolean array indicating phase 1 success at each level\nc_dot_Dz: Values of ⟨c, D*z⟩ at each barrier iteration (length k)\n\nAlgorithm Overview\n\nThe AMGB method combines:\n\nInterior point method: Uses logarithmic barriers to handle constraints\nMultigrid acceleration: Solves on hierarchy of grids from coarse to fine\nDamped Newton iteration: Inner solver with line search for robustness\n\nThe solver automatically handles:\n\nConstruction of appropriate discretization and multigrid hierarchy\nFeasibility restoration when initial point is infeasible  \nAdaptive barrier parameter updates with step size control\nConvergence monitoring across multiple grid levels\nProgress reporting (when verbose=true) and logging (to logfile if specified)\n\nErrors\n\nThrows AMGBConvergenceFailure if:\n\nThe feasibility problem cannot be solved (problem may be infeasible)\nThe main optimization fails to converge within maxit iterations\nNewton iteration fails at any grid level\n\nExamples\n\n# Solve 1D p-Laplace problem with p=1.5 using FEM\nz = amgb(fem1d(L=4); p=1.5)\n\n# Solve 2D problem with spectral elements\nz = amgb(spectral2d(n=8); p=2.0)\n\n# Custom boundary conditions\ng_custom(x) = [sin(π*x[1])*sin(π*x[2]), 10.0]\nz = amgb(fem2d(L=3); g=g_custom)\n\n# Get detailed solution information\nsol = amgb(fem1d(L=3); return_details=true, verbose=true)\nprintln(\"Iterations: \", sum(sol.SOL_main.its))\nprintln(\"Final barrier parameter: \", sol.SOL_main.ts[end])\n\n# Log iterations to a file\nopen(\"solver.log\", \"w\") do io\n    amgb(fem2d(L=2); logfile=io, verbose=false)\nend\n\n# Use pre-built hierarchy\ngeom = spectral1d(n=32)\nM = subdivide(geom; state_variables=[:u :dirichlet; :v :full; :s :full])\nz = amgb(geom; M=M, p=1.5)\n\nSee Also\n\nfem1d_solve, fem2d_solve, spectral1d_solve, spectral2d_solve:  Convenience wrappers for specific discretizations\nsubdivide: Generate AMG hierarchy for various discretizations\nConvex: Constraint set specification type\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.apply_D-Union{Tuple{T}, Tuple{Any, Vector{T}}} where T","page":"Home","title":"MultiGridBarrier.apply_D","text":"apply_D(D,z::Vector{T}) where {T} = hcat([D[k]*z for k in 1:length(D)]...)\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.convex_Euclidian_power-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.convex_Euclidian_power","text":"convex_Euclidian_power(::Type{T}=Float64; idx=Colon(), A=(x)->I, b=(x)->T(0), p=x->T(2))\n\nCreate a convex set defined by Euclidean norm power constraints.\n\nConstructs a Convex{T} object representing the power cone: {y : s ≥ ‖q‖₂^p} where [q; s] = A(x)*y[idx] + b(x)\n\nThis is the fundamental constraint for p-Laplace problems where we need s ≥ ‖∇u‖^p for some scalar field u.\n\nArguments\n\nT::Type=Float64: Numeric type for computations\n\nKeyword Arguments\n\nidx=Colon(): Indices of y to which transformation applies\nA::Function: Matrix function x -> A(x) for linear transformation\nb::Function: Vector function x -> b(x) for affine shift\np::Function: Exponent function x -> p(x) where p(x) ≥ 1\n\nReturns\n\nConvex{T} object with logarithmic barrier for the power cone\n\nMathematical Details\n\nThe barrier function is:\n\nFor p = 2: -log(s² - ‖q‖²)\nFor p ≠ 2: -log(s^(2/p) - ‖q‖²) - μ(p)*log(s) where μ(p) = 0 if p∈{1,2}, 1 if p<2, 2 if p>2\n\nExamples\n\n# Standard p-Laplace constraint: s ≥ ‖∇u‖^p\nQ = convex_Euclidian_power(; idx=2:4, p=x->1.5)\n\n# Spatially varying exponent\np_var(x) = 1.0 + 0.5 * x[1]  # variable p\nQ = convex_Euclidian_power(; p=p_var)\n\n# Second-order cone constraint: s ≥ ‖q‖₂\nQ = convex_Euclidian_power(; p=x->1.0)\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.convex_linear-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.convex_linear","text":"convex_linear(::Type{T}=Float64; idx=Colon(), A=(x)->I, b=(x)->T(0))\n\nCreate a convex set defined by linear inequality constraints.\n\nConstructs a Convex{T} object representing the feasible region: {y : A(x)*y[idx] + b(x) ≤ 0} for each spatial point x.\n\nArguments\n\nT::Type=Float64: Numeric type for computations\n\nKeyword Arguments\n\nidx=Colon(): Indices of y to which constraints apply (default: all)\nA::Function: Matrix function x -> A(x) for constraint coefficients\nb::Function: Vector function x -> b(x) for constraint bounds\n\nReturns\n\nConvex{T} object with appropriate barrier functions\n\nExamples\n\n# Box constraints: -1 ≤ y ≤ 1\nA_box(x) = [I; -I]\nb_box(x) = [ones(n); ones(n)]\nQ = convex_linear(; A=A_box, b=b_box)\n\n# Single linear constraint: y[1] + 2*y[2] ≤ 3\nA_single(x) = [1.0 2.0]\nb_single(x) = [-3.0]\nQ = convex_linear(; A=A_single, b=b_single, idx=1:2)\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.convex_piecewise-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.convex_piecewise","text":"convex_piecewise(::Type{T}=Float64; Q::Vector{Convex{T}}, select::Function=(tr=fill(true,length(Q));x->tr)) where {T}\n\nBuild a Convex{T} that combines multiple convex domains with spatial selectivity.\n\nArguments\n\nQ::Vector{Convex{T}}: a vector of convex pieces to be combined.\nselect::Function: a function x -> Vector{Bool} indicating which pieces are active at x. Default: all pieces active everywhere (equivalent to intersection).\n\nSemantics\n\nFor sel = select(x), the resulting convex domain has:\n\nbarrier(x, y) = ∑(Q[k].barrier(x, y) for k where sel[k])\ncobarrier(x, yhat) = ∑(Q[k].cobarrier(x, yhat) for k where sel[k])  \nslack(x, y) = max(Q[k].slack(x, y) for k where sel[k])\n\nThe slack is the maximum over active pieces, ensuring a single slack value suffices for feasibility at each x.\n\nUse cases\n\nIntersections (default): All pieces active everywhere creates Q₁ ∩ Q₂ ∩ ...\nSpatial switching: Different constraints in different regions\nConditional constraints: Activate constraints based on solution state\n\nExamples\n\n# Intersection (using default select)\nU = convex_Euclidian_power(Float64; idx=[1, 3], p = x->2)\nV = convex_linear(Float64; A = x->A_matrix, b = x->b_vector)\nQint = convex_piecewise(Float64; Q = [U, V])  # U ∩ V everywhere\n\n# Region-dependent constraints\nQ_left = convex_Euclidian_power(Float64; p = x->1.5)  \nQ_right = convex_Euclidian_power(Float64; p = x->2.0)\nselect(x) = [x[1] < 0, x[1] >= 0]  # left half vs right half\nQreg = convex_piecewise(Float64; Q = [Q_left, Q_right], select = select)\n\n# Conditional activation\nQ_base = convex_linear(Float64; A = x->I, b = x->-ones(2))\nQ_extra = convex_Euclidian_power(Float64; p = x->3)\nselect(x) = [true, norm(x) > 0.5]  # extra constraint outside radius 0.5\nQcond = convex_piecewise(Float64; Q = [Q_base, Q_extra], select = select)\n\nSee also: intersect, convex_linear, convex_Euclidian_power.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.fem1d-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.fem1d","text":"fem1d(::Type{T}=Float64; L=4, kwargs...)\n\nConstruct 1D FEM geometry (piecewise linear) on [-1, 1]. Returns FEM1D{T}; use with subdivide and amgb. Keyword L sets 2^L elements.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.fem1d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.fem1d_solve","text":"fem1d_solve(::Type{T}=Float64;rest...) where {T} = amgb(fem1d(T;rest...);rest...)\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.fem2d-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.fem2d","text":"fem2d(::Type{T}=Float64; L=2, K=default_mesh, kwargs...)\n\nConstruct 2D FEM geometry (quadratic + bubble) on a triangular mesh. Returns FEM2D{T}; use with subdivide and amgb. Keywords: L levels, K 3n×2 vertices.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.fem2d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.fem2d_solve","text":"fem2d_solve(::Type{T}=Float64;rest...) where {T} = amgb(fem2d(T;rest...);rest...)\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.interpolate","page":"Home","title":"MultiGridBarrier.interpolate","text":"interpolate(M::Geometry, z::Vector, t)\n\nInterpolate a solution vector at specified points.\n\nGiven a solution z on the AMG mesh M, evaluates the solution at new points t using the appropriate interpolation method for the discretization (piecewise linear for FEM, polynomial for spectral).\n\nArguments\n\nM::Geometry: The mesh containing grid and basis information\nz::Vector: Solution vector on the mesh (length must match number of DOFs)\nt: Evaluation points. Format depends on dimension:\n1D: Scalar or vector of x-coordinates\n2D: Matrix where each row is [x, y]\n\nReturns\n\nInterpolated values at the specified points. Shape matches input t.\n\nExamples\n\n# 1D interpolation\nM = subdivide(fem1d(L=3); generate_feasibility=false)\nz = sin.(π * M.x)  # sample solution\ny = interpolate(M, z, 0.5)  # evaluate at x=0.5\ny_vec = interpolate(M, z, [-0.5, 0.0, 0.5])  # evaluate at multiple points\n\n# 2D interpolation\nM = subdivide(spectral2d(n=4); generate_feasibility=false)\nz = sin.(π * M.x[:,1]) .* cos.(π * M.x[:,2])\npoints = [0.0 0.0; 0.5 0.5; -0.5 0.5]  # 3 points\ny = interpolate(M, z, points)\n\n\n\n\n\n","category":"function"},{"location":"#MultiGridBarrier.parabolic_solve-Union{Tuple{}, Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T","page":"Home","title":"MultiGridBarrier.parabolic_solve","text":"parabolic_solve(geometry=fem2d(), ::Type{T}=get_T(geometry); kwargs...)\n\nSolve time-dependent p-Laplace problems using implicit Euler timestepping.\n\nSolves the parabolic PDE:\n\nu_t - nabla cdot (nabla u_2^p-2nabla u) = -f_1\n\nusing implicit Euler discretization and barrier methods.\n\nArguments\n\ngeometry: Discretization geometry (default: fem2d())\nT::Type: Numeric type (inferred from geometry)\n\nKeyword Arguments\n\nDiscretization\n\nstate_variables: State variables (default: [:u :dirichlet; :s1 :full; :s2 :full])\nD: Differential operators (default depends on dimension)\ndim::Int: Spatial dimension (auto-detected from geometry)\nM: Pre-built AMG hierarchy (constructed if not provided)\n\nTime Integration\n\nt0::T=0: Initial time\nt1::T=1: Final time\nh::T=0.2: Time step size\n\nProblem Parameters\n\np::T=1: Exponent for p-Laplacian\nf1: Source term function (default: x->T(0.5))\nf: Full forcing function (derived from f1 by default)\ng: Initial/boundary conditions (default depends on dimension)\nQ: Convex constraints (default: appropriate for p-Laplace)\n\nOutput Control\n\nverbose::Bool=true: Show progress bar\nshow::Bool=true: Animate solution after solving\ninterval::Int=200: Animation frame interval (ms)\nprinter: Function to display animation. Takes a single argument animation::matplotlib.animation.FuncAnimation  and displays it. Default: (animation)->display(\"text/html\", animation.to_html5_video(embed_limit=200.0)).  Custom printers can save to file (e.g., (anim)->anim.save(\"output.mp4\")) or use alternative display methods.\n\nAdditional Parameters\n\nrest...: Passed to amgb for each time step\n\nReturns\n\n3D array U of size (n_nodes, n_components, n_timesteps) containing the solution at each time step.\n\nMathematical Formulation\n\nThe implicit Euler scheme u_t  (u_k+1-u_k)h gives:\n\nu_k+1 - hnabla cdot (nabla u_k+1^p-2nabla u_k+1) = u_k - hf_1\n\nWe minimize the functional:\n\nJ(u) = int_Ω frac12u² + frachpnabla u^p + (hf_1 - u_k)u  dx\n\nWith slack variables s_1  u² and s_2  nabla u^p, this becomes:\n\nmin int_Ω frac12s_1 + frachps_2 + (hf_1 - u_k)u  dx\n\nExamples\n\n# Basic 2D heat equation (p=2)\nU = parabolic_solve(; p=2.0, h=0.1)\n\n# 1D p-Laplace with custom parameters\nU = parabolic_solve(fem1d(L=5); p=1.5, h=0.05, t1=2.0)\n\n# Spectral discretization without animation\nU = parabolic_solve(spectral2d(n=8); show=false, verbose=true)\n\n# Custom initial condition\ng_init(t, x) = [exp(-10*(x[1]^2 + x[2]^2)), 0, 0]\nU = parabolic_solve(; g=g_init)\n\nSee Also\n\namgb: Single time step solver\nplot: Animation function for time-dependent solutions\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.spectral1d-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.spectral1d","text":"spectral1d(::Type{T}=Float64; n=16, kwargs...)\n\nConstruct 1D spectral geometry with n Chebyshev nodes (degree n-1). Returns SPECTRAL1D{T}; use with subdivide and amgb.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.spectral1d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.spectral1d_solve","text":"spectral1d_solve(::Type{T}=Float64;rest...) where {T} = amgb(spectral1d(T;rest...);rest...)\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.spectral2d-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.spectral2d","text":"spectral2d(::Type{T}=Float64; n=4, kwargs...)\n\nConstruct 2D spectral geometry with n×n Chebyshev nodes on [-1,1]^2. Returns SPECTRAL2D{T}; use with subdivide and amgb.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.spectral2d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.spectral2d_solve","text":"spectral2d_solve(::Type{T}=Float64;rest...) where {T} = amgb(spectral2d(T;rest...);rest...)\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.stopping_exact-Tuple{T} where T","page":"Home","title":"MultiGridBarrier.stopping_exact","text":"stopping_exact(theta::T) where {T}\n\nCreate an exact stopping criterion for Newton methods.\n\nArguments\n\ntheta : tolerance parameter for gradient norm relative decrease (type T).\n\nReturns\n\nA stopping criterion function with signature: stop(ymin, ynext, gmin, gnext, n, ndecmin, ndec) -> Bool\n\nwhere:\n\nymin : minimum objective value seen so far.\nynext : current objective value.\ngmin : minimum gradient norm seen so far.\ngnext : current gradient vector.\nn : current Newton direction.\nndecmin : square root of minimum Newton decrement seen so far.\nndec : square root of current Newton decrement.\n\nAlgorithm\n\nReturns true (stop) if both conditions hold:\n\nNo objective improvement: ynext ≥ ymin\nGradient norm stagnation: ‖gnext‖ ≥ theta * gmin\n\nNotes\n\nThis criterion is \"exact\" in the sense that it requires both objective and gradient stagnation before stopping, making it suitable for high-precision optimization. Typical values of theta are in the range [0.1, 0.9].\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.stopping_inexact-Union{Tuple{T}, Tuple{T, T}} where T","page":"Home","title":"MultiGridBarrier.stopping_inexact","text":"stopping_inexact(lambda_tol::T, theta::T) where {T}\n\nCreate an inexact stopping criterion for Newton methods that combines Newton decrement and exact stopping conditions.\n\nArguments\n\nlambda_tol : tolerance for the Newton decrement (type T).\ntheta : tolerance parameter for the exact stopping criterion (type T).\n\nReturns\n\nA stopping criterion function with signature: stop(ymin, ynext, gmin, gnext, n, ndecmin, ndec) -> Bool\n\nwhere:\n\nymin : minimum objective value seen so far.\nynext : current objective value.\ngmin : minimum gradient norm seen so far.\ngnext : current gradient vector.\nn : current Newton direction.\nndecmin : square root of minimum Newton decrement seen so far.\nndec : square root of current Newton decrement (√(gᵀH⁻¹g)).\n\nAlgorithm\n\nReturns true (stop) if either condition holds:\n\nNewton decrement condition: ndec < lambda_tol\nExact stopping condition: stopping_exact(theta) is satisfied\n\nNotes\n\nThis criterion is \"inexact\" because it allows early termination based on the Newton decrement, which provides a quadratic convergence estimate. The Newton decrement λ = √(gᵀH⁻¹g) approximates the distance to the optimum in the Newton metric. Typical values: lambda_tol ∈ [1e-6, 1e-3], theta ∈ [0.1, 0.9].\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.subdivide","page":"Home","title":"MultiGridBarrier.subdivide","text":"subdivide(geometry; state_variables, D, generate_feasibility=true)\n\nGenerate a multigrid hierarchy (AMG object) for a given discretization geometry.\n\nThis function constructs the complete multigrid data structures needed for the AMGB solver, including basis functions, differential operators, and interpolation operators across all grid levels.\n\nArguments\n\ngeometry: A geometry object (FEM1D, FEM2D, SPECTRAL1D, or SPECTRAL2D) specifying the discretization method and parameters\n\nKeyword Arguments\n\nstate_variables::Matrix{Symbol}: State variables and their function spaces. Default depends on geometry but typically [:u :dirichlet; :s :full]\nD::Matrix{Symbol}: Differential operators to apply. Default depends on dimension.\n1D: [:u :id; :u :dx; :s :id] (identity, derivative, identity)\n2D: [:u :id; :u :dx; :u :dy; :s :id] (identity, x-deriv, y-deriv, identity)\ngenerate_feasibility::Bool=true: If true, returns a tuple (M_main, M_feasibility) where M_feasibility includes an additional slack variable for feasibility phase\n\nReturns\n\nIf generate_feasibility=false: Single AMG object for the main problem\nIf generate_feasibility=true: Tuple of (mainAMG, feasibilityAMG)\n\nExamples\n\n# Generate FEM hierarchy with 4 levels\nM = subdivide(fem1d(L=4))\n\n# Generate spectral hierarchy without feasibility\nM = subdivide(spectral2d(n=8); generate_feasibility=false)\n\n# Custom state variables\nM = subdivide(fem2d(L=3); state_variables=[:u :dirichlet; :v :dirichlet; :s :full])\n\n\n\n\n\n","category":"function"},{"location":"#PyPlot.plot","page":"Home","title":"PyPlot.plot","text":"plot(M::Geometry, z::Vector; kwargs...)\nplot(M::Geometry, U::Matrix{T}; interval=200, embed_limit=200.0, printer=...) where T\n\nVisualize solutions on AMG meshes, either as static plots or animations.\n\nStatic plots (vector input)\n\nWhen z is a vector, produces a single plot:\n\n1D problems: Line plot. For spectral methods, you can specify evaluation points with x=-1:0.01:1\n2D FEM: Triangulated surface plot using the mesh structure\n2D spectral: 3D surface plot. You can specify evaluation grids with x=-1:0.01:1, y=-1:0.01:1\n\nAll other keyword arguments are passed to the underlying PyPlot functions.\n\nAnimations (matrix input)\n\nWhen U is a matrix, each column U[:, i] becomes a frame in an animation:\n\nThe axis limits are fixed across all frames for consistent scaling\nEach frame is rendered using the appropriate static plot method\nAnimation options:\ninterval: Time between frames in milliseconds (default: 200)\nembed_limit: Maximum size in MB for HTML5 video output (default: 200.0)\nprinter: Function to display the animation. Takes a single argument animation::matplotlib.animation.FuncAnimation. Default: (animation)->display(\"text/html\", animation.to_html5_video(embed_limit=embed_limit)) which renders  the animation as HTML5 video in Jupyter/Pluto notebooks. Custom printers can save to file  (e.g., (anim)->anim.save(\"output.mp4\")) or use alternative display methods.\n\nExamples\n\n# Static line plot\nM = subdivide(fem1d(L=3); generate_feasibility=false)\nz = sin.(π .* M.x)\nplot(M, z)\n\n# Static surface plot with custom grid\nM = subdivide(spectral2d(n=4); generate_feasibility=false)\nz = exp.(-M.x[:,1].^2 - M.x[:,2].^2)\nplot(M, z; x=-1:0.05:1, y=-1:0.05:1)\n\n# Animate a time series\nU = parabolic_solve(fem2d(L=2); show=false)  # returns (nodes, components, timesteps)\nplot(M[1], U[:, 1, :]; interval=100)         # animate the first component\n\n\n\n\n\n","category":"function"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
