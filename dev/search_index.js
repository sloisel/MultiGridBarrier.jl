var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"using Markdown\nusing Pkg\nusing MultiGridBarrier\nv = string(pkgversion(MultiGridBarrier))\nmd\"# MultiGridBarrier $v\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"MultiGridBarrier is a Julia module for solving nonlinear convex optimization problems in function spaces, such as p-Laplace problems. When regularity conditions are satisfied, the solvers are quasi-optimal.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The MultiGridBarrier module features finite element and spectral discretizations in 1d and 2d.","category":"page"},{"location":"#Finite-elements","page":"Home","title":"Finite elements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"After installing MultiGridBarrier with the Julia package manager, in a Jupyter notebook, one solves a 1d p-Laplace problem as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using PyPlot # hide\nusing MultiGridBarrier\nplot(fem1d_solve(L=5,p=1.0,verbose=false));\nsavefig(\"fem1d.svg\"); nothing # hide\nclose() #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"A 2d p-Laplace problem:","category":"page"},{"location":"","page":"Home","title":"Home","text":"plot(fem2d_solve(L=3,p=1.0,verbose=false));\nsavefig(\"fem2d.svg\"); nothing # hide\nclose() #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#Spectral-elements","page":"Home","title":"Spectral elements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Solve a 1d p-Laplace problem using spectral methods as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"plot(spectral1d_solve(n=40,p=1.0,verbose=false));\nsavefig(\"spectral1d.svg\"); nothing # hide\nclose() #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"A 2d p-Laplace problem:","category":"page"},{"location":"","page":"Home","title":"Home","text":"plot(spectral2d_solve(n=5,p=1.5,verbose=false));\nsavefig(\"spectral2d.svg\"); nothing # hide\nclose() #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#Solving-\\infty-Laplacians","page":"Home","title":"Solving infty-Laplacians","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For p geq 1 and domain Omega, the solution u of the p-Laplace problem is the minimizer of J(u) = nabla u_L^p(Omega)^p + int_Omega fu where u is in a suitable space of function satisfying, e.g. Dirichlet conditions, and f is a forcing. This definition must be modified for the infty-Laplace problem. Here we show how to minimize: J(u) = nabla u_L^infty(Omega)^p + int_Omega fu We put p=1 for simplicity.","category":"page"},{"location":"","page":"Home","title":"Home","text":"plot(fem1d_solve(L=5,p=1.0,state_variables=[:u :dirichlet; :s :uniform],verbose=false));\nsavefig(\"fem1dinfty.svg\"); nothing # hide\nclose() #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#Parabolic-problems","page":"Home","title":"Parabolic problems","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A time-dependent problem:","category":"page"},{"location":"","page":"Home","title":"Home","text":"plot(parabolic_solve(fem2d(L=3);h=0.1,verbose=false))","category":"page"},{"location":"#Module-reference","page":"Home","title":"Module reference","text":"","category":"section"},{"location":"#MultiGridBarrier.MultiGridBarrier","page":"Home","title":"MultiGridBarrier.MultiGridBarrier","text":"module MultiGridBarrier\n\nMultiGridBarrier solves nonlinear convex optimization problems in function spaces using a barrier (interior-point) method accelerated by a multigrid hierarchy constructed from your chosen discretization (FEM or spectral). The package provides simple, high-level entry points as well as a general solver that accept a \"geometry\" and optional keywords.\n\nA gentle introduction via the p-Laplacian\n\nFor a domain Ω ⊂ ℝᵈ and p ≥ 1, consider the variational problem\n\nmin_u  J(u) = int_Omega nabla u_2^p + fu  dx\n\nsubject to appropriate boundary conditions (e.g., homogeneous Dirichlet). The Euler–Lagrange equation gives the p-Laplace PDE:\n\nnabla cdot big(nabla u_2^p-2nabla ubig) = tfrac1pf quad textin  Omega\n\nwith the specified boundary conditions. This connection is obtained by integration by parts applied to the first variation of J(u).\n\nConstrained linear reformulation with a slack variable\n\nIntroduce a slack s(x) geq nabla u(x)_2^p and rewrite the objective using s:\n\nmin_us  int_Omega s + fu  dx\nquad textsubject toquad s ge nabla u_2^p\n\nThis is a convex optimization problem with a linear objective and convex constraints. In discrete form, we bundle the state into z, and apply a block \"differential\" operator D so that\n\nD z = beginbmatrix u  nabla u  s endbmatrix\nqquad\nc^top = beginbmatrix f  0  1 endbmatrix\n\nThe problem becomes\n\nmin_z int_Omega c(x)^top  (D z)(x)  dx\nquad textsubject toquad (uqs) in mathcalQ =  s ge q_2^p  textpointwise\n\nwhich MultiGridBarrier solves by a barrier method. An illustrative (simple) barrier for mathcalQ is\n\nmathcalF(qs) = -logbig(s^2p - q_2^2big) - 2log s\n\nand the method minimizes the barrier-augmented functional\n\nint_Omega t c(x)^top (D z)(x) + mathcalFbig((D z)(x)big)  dx\n\nfor increasing barrier parameter t. Internally, the solve proceeds on a hierarchy of grids with damped Newton steps and line search, but these details are abstracted away.\n\nHow to use it (discretizations and solvers)\n\nSolve with a convenience wrapper (recommended to start):\nsol = fem1d_solve(; kwargs...)\nsol = fem2d_solve(; kwargs...)\nsol = spectral1d_solve(; kwargs...)\nsol = spectral2d_solve(; kwargs...)\nOr call the general solver directly:\nsol = amgb(geometry; kwargs...) → AMGBSOL\nThe solution can be plotted by calling plot(sol). If using amgb() directly, you must construct a suitable geometry object:\ngeometry = fem1d(; L=4)         → 1D FEM on [-1, 1] with 2^L elements\ngeometry = fem2d(; L=2, K=...)  → 2D FEM (quadratic + bubble triangles)\ngeometry = spectral1d(; n=16)   → 1D spectral (Chebyshev/Clenshaw–Curtis)\ngeometry = spectral2d(; n=4)    → 2D spectral (tensor Chebyshev)\n\nQuick examples\n\n# 1D FEM p-Laplace\nz = fem1d_solve(L=5, p=1.0).z\n\n# 2D spectral p-Laplace\nz = spectral2d_solve(n=8, p=2.0).z\n\n# 2D FEM with custom boundary data\ng_custom(x) = [sin(π*x[1])*sin(π*x[2]), 10.0]\nz = fem2d_solve(L=3; p=1.0, g=g_custom).z\n\n# Time-dependent (implicit Euler)\nsol = parabolic_solve(fem2d(L=3); h=0.1)\n# plot(sol) animates the first component\n\nInputs and defaults (high level)\n\np::Real = 1.0: exponent in the p-Laplace term\ng, f: boundary/initial data and forcing; either as functions g(x), f(x) or as grids g_grid, f_grid\nD and state_variables: symbolic specifications of which operators act on which variables (sane defaults provided based on the geometry’s dimension)\nQ: convex set (by default, a p-Laplace-compatible set via convex_Euclidian_power)\nverbose, logfile: visualization and logging\nAdvanced control: tol, t, t_feasibility, line_search, stopping_criterion, finalize\n\nWhat you get back\n\nStatic solvers (amgb, *_solve) return an AMGBSOL with fields:\nz::Matrix: solution on the finest grid (nodes × components)\nSOL_main, SOL_feasibility: per-phase diagnostics\nlog::String: textual log for debugging\ngeometry: the Geometry used to construct the multilevel operators\nThe solution object supports plot(sol) to visualize the first component.\nThe time-dependent solver parabolic_solve returns a ParabolicSOL with fields:\ngeometry, ts::Vector, u::Array(nodes × components × timesteps)\nCall plot(parabolic_sol) to animate using ts (see plot docs for timing options).\n\nUtilities\n\ninterpolate(geometry, z, points): evaluate the discrete solution at arbitrary points\nplot(sol) or plot(geometry, z): plot 1D curves or 2D surfaces\nplot(geometry, ts, U; frame_time=..., embed_limit=..., printer=...): animate a time sequence at absolute times ts (seconds), e.g., from parabolic_solve\nConvex set helpers: convex_Euclidian_power, convex_linear, convex_piecewise, intersect\n\nErrors and diagnostics\n\nThrows AMGBConvergenceFailure if the feasibility subproblem or the main solve cannot converge\nSet verbose=true for a progress bar; inspect SOL_main/feasibility and log for details\n\nSee also\n\nDiscretizations: fem1d, fem2d, spectral1d, spectral2d\nSolvers: amgb, fem1d_solve, fem2d_solve, spectral1d_solve, spectral2d_solve, parabolic_solve\nConvex: convex_Euclidian_power, convex_linear, convex_piecewise, intersect\nVisualization & sampling: plot, interpolate\n\n\n\n\n\n","category":"module"},{"location":"#Types-reference","page":"Home","title":"Types reference","text":"","category":"section"},{"location":"#MultiGridBarrier.AMGBConvergenceFailure","page":"Home","title":"MultiGridBarrier.AMGBConvergenceFailure","text":"AMGBConvergenceFailure <: Exception\n\nThrown when the AMGB solver fails to converge (feasibility or main phase). Includes a descriptive message about the failure.\n\n\n\n\n\n","category":"type"},{"location":"#MultiGridBarrier.Convex","page":"Home","title":"MultiGridBarrier.Convex","text":"Convex{T}\n\nContainer for a convex constraint set used by AMGB.\n\nFields:\n\nbarrier(x, y): barrier of the set\ncobarrier(x, yhat): barrier with slack for feasibility\nslack(x, y): initial slack value\n\nConstruct via helpers like convex_linear, convex_Euclidian_power, convex_piecewise, or intersect.\n\n\n\n\n\n","category":"type"},{"location":"#MultiGridBarrier.FEM1D","page":"Home","title":"MultiGridBarrier.FEM1D","text":"FEM1D{T}\n\n1D FEM geometry descriptor. Field: L::Int (levels). Use with amgb.\n\n\n\n\n\n","category":"type"},{"location":"#MultiGridBarrier.FEM2D","page":"Home","title":"MultiGridBarrier.FEM2D","text":"FEM2D{T}\n\n2D FEM geometry descriptor for quadratic+bubble triangles. Fields: K::Matrix{T} (3n×2 mesh), L::Int (levels). Use with amgb.\n\n\n\n\n\n","category":"type"},{"location":"#MultiGridBarrier.Geometry","page":"Home","title":"MultiGridBarrier.Geometry","text":"Geometry{T,M,Discretization}\n\nContainer for discretization geometry and the multigrid transfer machinery used by AMGB.\n\nConstructed by high-level front-ends like fem1d, fem2d, spectral1d, and spectral2d. It collects the physical/sample points, quadrature weights, per-level subspace embeddings, discrete operators (e.g. identity and derivatives), and intergrid transfer operators (refine/coarsen).\n\nType parameters\n\nT: scalar numeric type (e.g. Float64)\nM: matrix type used for linear operators (e.g. SparseMatrixCSC{T,Int} or Matrix{T})\nDiscretization: front-end descriptor (e.g. FEM1D{T}, FEM2D{T}, SPECTRAL1D{T}, SPECTRAL2D{T})\n\nFields\n\ndiscretization::Discretization: Discretization descriptor that encodes dimension and grid construction\nx::Matrix{T}: Sample/mesh points on the finest level; size is (n_nodes, dim)\nw::Vector{T}: Quadrature weights matching x (length n_nodes)\nsubspaces::Dict{Symbol,Vector{M}}: Per-level selection/embedding matrices for function spaces (keys commonly include :dirichlet, :full, :uniform). Each value is a vector of length L with one matrix per level.\noperators::Dict{Symbol,M}: Discrete operators defined on the finest level (e.g. :id, :dx, :dy). Operators at other levels are obtained via coarsen_fine * operator * refine_fine inside amg.\nrefine::Vector{M}: Level-to-level refinement (prolongation) matrices for the primary state space\ncoarsen::Vector{M}: Level-to-level coarsening (restriction) matrices for the primary state space\n\nNotes\n\nGeometry is consumed by amg to build an AMG hierarchy and by utilities like interpolate and plot.\nThe length of refine/coarsen equals the number of levels L; the last entry is typically the identity.\n\n\n\n\n\n","category":"type"},{"location":"#MultiGridBarrier.SPECTRAL1D","page":"Home","title":"MultiGridBarrier.SPECTRAL1D","text":"SPECTRAL1D{T}\n\n1D spectral geometry descriptor (Chebyshev). Field: n::Int (nodes). Use with amgb.\n\n\n\n\n\n","category":"type"},{"location":"#MultiGridBarrier.SPECTRAL2D","page":"Home","title":"MultiGridBarrier.SPECTRAL2D","text":"SPECTRAL2D{T}\n\n2D spectral geometry descriptor (tensor Chebyshev). Field: n::Int (nodes per dim). Use with amgb.\n\n\n\n\n\n","category":"type"},{"location":"#Functions-reference","page":"Home","title":"Functions reference","text":"","category":"section"},{"location":"#Base.intersect-Union{Tuple{T}, Tuple{Convex{T}, Vararg{Any}}} where T","page":"Home","title":"Base.intersect","text":"intersect(U::Convex{T}, rest...) where {T}\n\nReturn the intersection of convex domains as a single Convex{T}. Equivalent to convex_piecewise with all pieces active.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.amgb-Union{Tuple{}, Tuple{Geometry{T, Mat, Discretization}}, Tuple{Discretization}, Tuple{Mat}, Tuple{T}} where {T, Mat, Discretization}","page":"Home","title":"MultiGridBarrier.amgb","text":"amgb(geometry::Geometry{T,Mat,Discretization}; kwargs...) where {T, Mat, Discretization}\n\nAlgebraic MultiGrid Barrier (AMGB) solver for nonlinear convex optimization problems in function spaces using multigrid barrier methods.\n\nThis is the main high-level entry point for solving p-Laplace and related problems using the barrier method with multigrid acceleration. The solver operates in two phases:\n\nFeasibility phase: Finds an interior point for the constraint set (if needed)\nMain optimization phase: Solves the barrier-augmented optimization problem\n\nArguments\n\ngeometry: Discretization geometry (default: fem1d()). Options:\nfem1d(L=n): 1D finite elements with 2^L elements\nfem2d(L=n, K=mesh): 2D finite elements\nspectral1d(n=m): 1D spectral with m nodes\nspectral2d(n=m): 2D spectral with m×m nodes\n\nKeyword Arguments\n\nProblem Specification\n\ndim::Integer = amg_dim(geometry.discretization): Problem dimension (1 or 2), auto-detected from geometry\nstate_variables::Matrix{Symbol} = [:u :dirichlet; :s :full]: Solution components and their function spaces\nD::Matrix{Symbol} = default_D[dim]: Differential operators to apply to state variables\nx::Matrix{T} = geometry.x: Mesh/sample points where f and g are evaluated when they are functions\n\nProblem Data\n\np::T = 1.0: Exponent for p-Laplace operator (p ≥ 1)\ng::Function = default_g(T)[dim]: Boundary conditions/initial guess (function of spatial coordinates)\ng_grid::Matrix{T}: Alternative to g, directly provide values on grid (default: g evaluated at x)\nf::Function = default_f(T)[dim]: Forcing term/cost functional (function of spatial coordinates)\nf_grid::Matrix{T}: Alternative to f, directly provide values on grid (default: f evaluated at x)\nQ::Convex{T} = convex_Euclidian_power(T, idx=2:dim+2, p=x->p): Convex constraint set\n\nOutput Control\n\nverbose::Bool = true: Display progress bar during solving\nlogfile = devnull: IO stream for logging (default: no file logging)\n\nSolver Control\n\nPassthrough Arguments\n\nAdditional keyword arguments are passed through to internal solver components:\n\ntol = sqrt(eps(T)): Stopping tolerance; the method stops once 1/t < tol where t is the barrier parameter\nt = T(0.1): Initial barrier parameter for the main solve\nt_feasibility = t: Initial barrier parameter for the feasibility solve\nmaxit = 10000: Maximum number of barrier iterations\nkappa = T(10.0): Initial step size multiplier for barrier parameter t. Adapted dynamically but never exceeds this initial value\nc0 = T(0): Base offset added to the objective (c0 + t*c)\nearly_stop = z->false: Function z -> Bool; if true, the iteration halts early (e.g., to stop feasibility phase when interior point found)\nmax_newton = ceil((log2(-log2(eps(T))))+2): Maximum Newton iterations per inner solve\nstopping_criterion = stopping_inexact(sqrt(minimum(M[1].w))/2, T(0.5)): Stopping criterion for Newton solver. Options:\nstopping_exact(theta): Check if objective decreased and gradient norm fell below tolerance\nstopping_inexact(lambda_tol, theta): Inexact Newton with mesh-dependent tolerance\nline_search = linesearch_backtracking(T): Line search strategy. Options:\nlinesearch_backtracking(T): Backtracking line search (default)\nlinesearch_illinois(T): Illinois algorithm-based line search\nfinalize = stopping_exact(T(0.5)): Finalization stopping criterion for the last Newton solve (stricter convergence)\n\nDefault Values\n\nThe defaults for f, g, and D depend on the problem dimension:\n\n1D Problems\n\nf(x) = [0.5, 0.0, 1.0] - Forcing term\ng(x) = [x[1], 2] - Boundary conditions\nD = [:u :id; :u :dx; :s :id] - Identity, derivative, identity\n\n2D Problems\n\nf(x) = [0.5, 0.0, 0.0, 1.0] - Forcing term\ng(x) = [x[1]²+x[2]², 100.0] - Boundary conditions\nD = [:u :id; :u :dx; :u :dy; :s :id] - Identity, x-derivative, y-derivative, identity\n\nReturns\n\nSolution object with fields:\n\nz: Solution matrix of size (n_nodes, n_components) containing the computed solution\nSOL_feasibility: Feasibility phase results (nothing if the initial point was already feasible), otherwise a solution object (see below)\nSOL_main: Main optimization phase results as a solution object (see below)\nlog: String containing detailed iteration log for debugging\ngeometry: The input geometry object\n\nEach solution object (SOL_feasibility and SOL_main) is a NamedTuple containing:\n\nz: Solution vector (flattened; for feasibility phase includes auxiliary slack variable)\nz_unfinalized: Solution before final refinement step\nc: Cost functional used in this phase\nits: Iteration counts across levels and barrier steps (L×k matrix where L is number of levels, k is number of barrier iterations)\nts: Sequence of barrier parameters t used (length k)\nkappas: Step size multipliers used at each iteration (length k)\ntimes: Wall-clock timestamps for each iteration (length k)\nt_begin, t_end, t_elapsed: Timing information for this phase\npassed: Boolean array indicating phase 1 success at each level\nc_dot_Dz: Values of ⟨c, D*z⟩ at each barrier iteration (length k)\n\nAlgorithm Overview\n\nThe AMGB method combines:\n\nInterior point method: Uses logarithmic barriers to handle constraints\nMultigrid acceleration: Solves on hierarchy of grids from coarse to fine\nDamped Newton iteration: Inner solver with line search for robustness\n\nThe solver automatically handles:\n\nConstruction of appropriate discretization and multigrid hierarchy\nFeasibility restoration when initial point is infeasible\nAdaptive barrier parameter updates with step size control\nConvergence monitoring across multiple grid levels\nProgress reporting (when verbose=true) and logging (to logfile if specified)\n\nErrors\n\nThrows AMGBConvergenceFailure if:\n\nThe feasibility problem cannot be solved (problem may be infeasible)\nThe main optimization fails to converge within maxit iterations\nNewton iteration fails at any grid level\n\nExamples\n\n# Solve 1D p-Laplace problem with p=1.5 using FEM\nz = amgb(fem1d(L=4); p=1.5).z\n\n# Solve 2D problem with spectral elements\nz = amgb(spectral2d(n=8); p=2.0).z\n\n# Custom boundary conditions\ng_custom(x) = [sin(π*x[1])*sin(π*x[2]), 10.0]\nz = amgb(fem2d(L=3); g=g_custom).z\n\n# Get detailed solution information\nsol = amgb(fem1d(L=3); verbose=true)\nprintln(\"Iterations: \", sum(sol.SOL_main.its))\nprintln(\"Final barrier parameter: \", sol.SOL_main.ts[end])\n\n# Visualize the first component\nplot(sol)\n\n# Log iterations to a file\nopen(\"solver.log\", \"w\") do io\n    amgb(fem2d(L=2); logfile=io, verbose=false)\nend\n\nSee Also\n\nfem1d_solve, fem2d_solve, spectral1d_solve, spectral2d_solve: Convenience wrappers for specific discretizations\nConvex: Constraint set specification type\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.apply_D-Union{Tuple{T}, Tuple{Any, Vector{T}}} where T","page":"Home","title":"MultiGridBarrier.apply_D","text":"apply_D(D,z::Vector{T}) where {T} = hcat([D[k]*z for k in 1:length(D)]...)\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.convex_Euclidian_power-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.convex_Euclidian_power","text":"convex_Euclidian_power(::Type{T}=Float64; idx=Colon(), A=(x)->I, b=(x)->T(0), p=x->T(2))\n\nCreate a convex set defined by Euclidean norm power constraints.\n\nConstructs a Convex{T} object representing the power cone: {y : s ≥ ‖q‖₂^p} where [q; s] = A(x)*y[idx] + b(x)\n\nThis is the fundamental constraint for p-Laplace problems where we need s ≥ ‖∇u‖^p for some scalar field u.\n\nArguments\n\nT::Type=Float64: Numeric type for computations\n\nKeyword Arguments\n\nidx=Colon(): Indices of y to which transformation applies\nA::Function: Matrix function x -> A(x) for linear transformation\nb::Function: Vector function x -> b(x) for affine shift\np::Function: Exponent function x -> p(x) where p(x) ≥ 1\n\nReturns\n\nConvex{T} object with logarithmic barrier for the power cone\n\nMathematical Details\n\nThe barrier function is:\n\nFor p = 2: -log(s² - ‖q‖²)\nFor p ≠ 2: -log(s^(2/p) - ‖q‖²) - μ(p)*log(s) where μ(p) = 0 if p∈{1,2}, 1 if p<2, 2 if p>2\n\nExamples\n\n# Standard p-Laplace constraint: s ≥ ‖∇u‖^p\nQ = convex_Euclidian_power(; idx=2:4, p=x->1.5)\n\n# Spatially varying exponent\np_var(x) = 1.0 + 0.5 * x[1]  # variable p\nQ = convex_Euclidian_power(; p=p_var)\n\n# Second-order cone constraint: s ≥ ‖q‖₂\nQ = convex_Euclidian_power(; p=x->1.0)\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.convex_linear-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.convex_linear","text":"convex_linear(::Type{T}=Float64; idx=Colon(), A=(x)->I, b=(x)->T(0))\n\nCreate a convex set defined by linear inequality constraints.\n\nDefines F(x, y) = A(x) * y[idx] + b(x). The interior of the set is given by F(x, y) > 0 (a logarithmic barrier is applied to each component of F). The boundary F(x, y) = 0 corresponds to constraint activation.\n\nArguments\n\nT::Type=Float64: Numeric type for computations\n\nKeyword Arguments\n\nidx=Colon(): Indices of y to which constraints apply (default: all)\nA::Function: Matrix function x -> A(x) for constraint coefficients\nb::Function: Vector function x -> b(x) for constraint bounds\n\nReturns\n\nConvex{T} object with appropriate barrier functions\n\nExamples\n\n# Box constraints in 2D: -1 ≤ y ≤ 1\nA_box(x) = [1.0 0.0; 0.0 1.0; -1.0 0.0; 0.0 -1.0]\nb_box(x) = [1.0, 1.0, 1.0, 1.0]\nQ = convex_linear(; A=A_box, b=b_box, idx=1:2)\n\n# Single linear constraint: y[1] + 2*y[2] ≤ 3\n# Choose F = 3 - (y1 + 2*y2) > 0\nA_single(x) = [-1.0 -2.0]\nb_single(x) = [3.0]\nQ = convex_linear(; A=A_single, b=b_single, idx=1:2)\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.convex_piecewise-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.convex_piecewise","text":"convex_piecewise(::Type{T}=Float64; Q::Vector{Convex{T}}, select::Function=(tr=fill(true,length(Q));x->tr)) where {T}\n\nBuild a Convex{T} that combines multiple convex domains with spatial selectivity.\n\nArguments\n\nQ::Vector{Convex{T}}: a vector of convex pieces to be combined.\nselect::Function: a function x -> Vector{Bool} indicating which pieces are active at x. Default: all pieces active everywhere (equivalent to intersection).\n\nSemantics\n\nFor sel = select(x), the resulting convex domain has:\n\nbarrier(x, y) = ∑(Q[k].barrier(x, y) for k where sel[k])\ncobarrier(x, yhat) = ∑(Q[k].cobarrier(x, yhat) for k where sel[k])  \nslack(x, y) = max(Q[k].slack(x, y) for k where sel[k])\n\nThe slack is the maximum over active pieces, ensuring a single slack value suffices for feasibility at each x.\n\nUse cases\n\nIntersections (default): All pieces active everywhere creates Q₁ ∩ Q₂ ∩ ...\nSpatial switching: Different constraints in different regions\nConditional constraints: Activate constraints based on solution state\n\nExamples\n\n# Intersection (using default select)\nU = convex_Euclidian_power(Float64; idx=[1, 3], p = x->2)\nV = convex_linear(Float64; A = x->A_matrix, b = x->b_vector)\nQint = convex_piecewise(Float64; Q = [U, V])  # U ∩ V everywhere\n\n# Region-dependent constraints\nQ_left = convex_Euclidian_power(Float64; p = x->1.5)  \nQ_right = convex_Euclidian_power(Float64; p = x->2.0)\nselect(x) = [x[1] < 0, x[1] >= 0]  # left half vs right half\nQreg = convex_piecewise(Float64; Q = [Q_left, Q_right], select = select)\n\n# Conditional activation\nQ_base = convex_linear(Float64; A = x->I, b = x->-ones(2))\nQ_extra = convex_Euclidian_power(Float64; p = x->3)\nselect(x) = [true, norm(x) > 0.5]  # extra constraint outside radius 0.5\nQcond = convex_piecewise(Float64; Q = [Q_base, Q_extra], select = select)\n\nSee also: intersect, convex_linear, convex_Euclidian_power.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.fem1d-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.fem1d","text":"fem1d(::Type{T}=Float64; L=4, kwargs...)\n\nConstruct 1D FEM geometry (piecewise linear) on [-1, 1]. Returns a Geometry suitable for use with amgb. Keyword L sets 2^L elements.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.fem1d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.fem1d_solve","text":"fem1d_solve(::Type{T}=Float64;rest...) where {T} = amgb(fem1d(T;rest...);rest...)\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.fem2d-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.fem2d","text":"fem2d(::Type{T}=Float64; L=2, K=T[-1 -1;1 -1;-1 1;1 -1;1 1;-1 1], kwargs...)\n\nConstruct 2D FEM geometry (quadratic + bubble) on a triangular mesh. Returns a Geometry suitable for use with amgb. Keywords: L levels, K 3n×2 vertices.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.fem2d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.fem2d_solve","text":"fem2d_solve(::Type{T}=Float64;rest...) where {T} = amgb(fem2d(T;rest...);rest...)\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.interpolate","page":"Home","title":"MultiGridBarrier.interpolate","text":"interpolate(M::Geometry, z::Vector, t)\n\nInterpolate a solution vector at specified points.\n\nGiven a solution z on the mesh M, evaluates the solution at new points t using the appropriate interpolation method for the discretization.\n\nSupported discretizations\n\n1D FEM (FEM1D): piecewise-linear interpolation\n1D spectral (SPECTRAL1D): spectral polynomial interpolation\n2D spectral (SPECTRAL2D): tensor-product spectral interpolation\n\nNote: 2D FEM interpolation is not currently provided.\n\nArguments\n\nM::Geometry: The geometry containing grid and basis information\nz::Vector: Solution vector on the finest grid (length must match number of DOFs)\nt: Evaluation points. Format depends on dimension:\n1D: scalar or Vector{T} of x-coordinates\n2D spectral: Matrix{T} where each row is [x, y]\n\nReturns\n\nInterpolated values at the specified points. Shape matches input t.\n\nExamples\n\n# 1D interpolation (FEM)\ngeom = fem1d(L=3)\nz = sin.(π .* vec(geom.x))\ny = interpolate(geom, z, 0.5)\ny_vec = interpolate(geom, z, [-0.5, 0.0, 0.5])\n\n# 2D interpolation (spectral)\ngeom = spectral2d(n=4)\nz = exp.(-geom.x[:,1].^2 .- geom.x[:,2].^2)\npoints = [0.0 0.0; 0.5 0.5; -0.5 0.5]\nvals = interpolate(geom, z, points)\n\n\n\n\n\n","category":"function"},{"location":"#MultiGridBarrier.parabolic_solve-Union{Tuple{}, Tuple{Geometry{T, Mat, Discretization}}, Tuple{Discretization}, Tuple{Mat}, Tuple{T}} where {T, Mat, Discretization}","page":"Home","title":"MultiGridBarrier.parabolic_solve","text":"parabolic_solve(geometry::Geometry{T,Mat,Discretization}=fem2d(); kwargs...)\n\nSolve time-dependent p-Laplace problems using implicit Euler timestepping.\n\nSolves the parabolic PDE:\n\nu_t - nabla cdot (nabla u_2^p-2nabla u) = -f_1\n\nusing implicit Euler discretization and barrier methods.\n\nArguments\n\ngeometry: Discretization geometry (default: fem2d()).\n\nKeyword Arguments\n\nDiscretization\n\nstate_variables: State variables (default: [:u :dirichlet; :s1 :full; :s2 :full]).\nD: Differential operators (default depends on spatial dimension).\ndim::Int: Spatial dimension (auto-detected from geometry).\n\nTime Integration\n\nt0::T=0: Initial time.\nt1::T=1: Final time.\nh::T=0.2: Time step size.\nts::AbstractVector{T}=t0:h:t1: Time grid; override to provide a custom, nonuniform, nondecreasing sequence.\n\nProblem Parameters\n\np::T=1: Exponent for the p-Laplacian.\nf1: Source term function of signature (t, x) -> T (default: (t,x)->T(0.5)).\ng: Initial/boundary conditions function of signature (t, x) -> Vector{T} (default depends on dimension).\nQ: Convex constraints (default: appropriate for p-Laplace).\n\nOutput Control\n\nverbose::Bool=true: Show a progress bar during time stepping.\n\nAdditional Parameters\n\nrest...: Passed through to amgb for each time step.\n\nReturns\n\nA ParabolicSOL with fields:\n\ngeometry: the Geometry used.\nts::Vector{T}: time stamps (seconds).\nu::Array{T,3}: solution tensor of size (n_nodes, n_components, n_timesteps).\n\nAnimate with plot(sol) (or plot(sol, k) for component k). To save to a file, use the plotting printer, e.g. plot(sol; printer=anim->anim.save(\"out.mp4\")).\n\nMathematical Formulation\n\nThe implicit Euler scheme u_t approx (u_k+1-u_k)h gives:\n\nu_k+1 - hnabla cdot (nabla u_k+1^p-2nabla u_k+1) = u_k - h f_1\n\nWe minimize the functional:\n\nJ(u) = int_Omega tfrac12u^2 + tfrachpnabla u^p + (h f_1 - u_k)u  dx\n\nWith slack variables s_1 ge u^2 and s_2 ge nabla u^p, this becomes:\n\nmin int_Omega tfrac12s_1 + tfrachps_2 + (h f_1 - u_k)u  dx\n\nExamples\n\n# Basic 2D heat equation (p=2)\nsol = parabolic_solve(; p=2.0, h=0.1)\n\n# 1D p-Laplace with custom parameters\nsol = parabolic_solve(fem1d(L=5); p=1.5, h=0.05, t1=2.0)\n\n# Spectral discretization\nsol = parabolic_solve(spectral2d(n=8); verbose=true)\n\n# Custom initial condition\ng_init(t, x) = [exp(-10*(x[1]^2 + x[2]^2)), 0, 0]\nsol = parabolic_solve(; g=g_init)\n\nSee Also\n\namgb: Single time step solver\nplot: Animation and plotting function\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.spectral1d-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.spectral1d","text":"spectral1d(::Type{T}=Float64; n=16, kwargs...)\n\nConstruct 1D spectral geometry with n Chebyshev nodes (degree n-1). Returns a Geometry suitable for use with amgb.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.spectral1d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.spectral1d_solve","text":"spectral1d_solve(::Type{T}=Float64;rest...) where {T} = amgb(spectral1d(T;rest...);rest...)\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.spectral2d-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.spectral2d","text":"spectral2d(::Type{T}=Float64; n=4, kwargs...)\n\nConstruct 2D spectral geometry with n×n Chebyshev nodes on [-1,1]^2. Returns a Geometry suitable for use with amgb.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.spectral2d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.spectral2d_solve","text":"spectral2d_solve(::Type{T}=Float64;rest...) where {T} = amgb(spectral2d(T;rest...);rest...)\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.stopping_exact-Tuple{T} where T","page":"Home","title":"MultiGridBarrier.stopping_exact","text":"stopping_exact(theta::T) where {T}\n\nCreate an exact stopping criterion for Newton methods.\n\nArguments\n\ntheta : tolerance parameter for gradient norm relative decrease (type T).\n\nReturns\n\nA stopping criterion function with signature: stop(ymin, ynext, gmin, gnext, n, ndecmin, ndec) -> Bool\n\nwhere:\n\nymin : minimum objective value seen so far.\nynext : current objective value.\ngmin : minimum gradient norm seen so far.\ngnext : current gradient vector.\nn : current Newton direction.\nndecmin : square root of minimum Newton decrement seen so far.\nndec : square root of current Newton decrement.\n\nAlgorithm\n\nReturns true (stop) if both conditions hold:\n\nNo objective improvement: ynext ≥ ymin\nGradient norm stagnation: ‖gnext‖ ≥ theta * gmin\n\nNotes\n\nThis criterion is \"exact\" in the sense that it requires both objective and gradient stagnation before stopping, making it suitable for high-precision optimization. Typical values of theta are in the range [0.1, 0.9].\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.stopping_inexact-Union{Tuple{T}, Tuple{T, T}} where T","page":"Home","title":"MultiGridBarrier.stopping_inexact","text":"stopping_inexact(lambda_tol::T, theta::T) where {T}\n\nCreate an inexact stopping criterion for Newton methods that combines Newton decrement and exact stopping conditions.\n\nArguments\n\nlambda_tol : tolerance for the Newton decrement (type T).\ntheta : tolerance parameter for the exact stopping criterion (type T).\n\nReturns\n\nA stopping criterion function with signature: stop(ymin, ynext, gmin, gnext, n, ndecmin, ndec) -> Bool\n\nwhere:\n\nymin : minimum objective value seen so far.\nynext : current objective value.\ngmin : minimum gradient norm seen so far.\ngnext : current gradient vector.\nn : current Newton direction.\nndecmin : square root of minimum Newton decrement seen so far.\nndec : square root of current Newton decrement (√(gᵀH⁻¹g)).\n\nAlgorithm\n\nReturns true (stop) if either condition holds:\n\nNewton decrement condition: ndec < lambda_tol\nExact stopping condition: stopping_exact(theta) is satisfied\n\nNotes\n\nThis criterion is \"inexact\" because it allows early termination based on the Newton decrement, which provides a quadratic convergence estimate. The Newton decrement λ = √(gᵀH⁻¹g) approximates the distance to the optimum in the Newton metric. Typical values: lambda_tol ∈ [1e-6, 1e-3], theta ∈ [0.1, 0.9].\n\n\n\n\n\n","category":"method"},{"location":"#PyPlot.plot","page":"Home","title":"PyPlot.plot","text":"plot(sol::AMGBSOL, k::Int=1; kwargs...)\nplot(sol::ParabolicSOL, k::Int=1; kwargs...)\nplot(M::Geometry, z::Vector; kwargs...)\nplot(M::Geometry, ts::AbstractVector, U::Matrix; frame_time=..., embed_limit=..., printer=...)\n\nVisualize solutions and time sequences on meshes.\n\n1D problems: Line plot. For spectral methods, you can specify evaluation points with x=-1:0.01:1.\n2D FEM: Triangulated surface plot using the mesh structure.\n2D spectral: 3D surface plot. You can specify evaluation grids with x=-1:0.01:1, y=-1:0.01:1.\n\nTime sequences (animation):\n\nCall plot(M, ts, U; frame_time=1/30, printer=anim->nothing) where U has columns as frames and ts are absolute times in seconds (non-uniform allowed).\nOr simply call plot(sol) where sol is a ParabolicSOL returned by parabolic_solve (uses sol.ts).\nAnimation advances at a fixed frame rate given by frame_time (seconds per video frame). For irregular ts, each video frame shows the latest data frame with timestamp ≤ current video time.\nThe printer callback receives the Matplotlib animation object; use it to display or save (e.g., anim.save(\"out.mp4\")).\nembed_limit controls the maximum embedded HTML5 video size in megabytes.\n\nWhen sol is a solution object returned by amgb or the *_solve helpers, plot(sol,k) plots the kth component sol.z[:, k] using sol.geometry. plot(sol) uses the default k=1.\n\nAll other keyword arguments are passed to the underlying PyPlot functions.\n\n\n\n\n\n","category":"function"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
