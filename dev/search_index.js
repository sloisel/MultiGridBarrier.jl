var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"using Markdown\nusing Pkg\nusing MultiGridBarrier\nv = string(pkgversion(MultiGridBarrier))\nmd\"# MultiGridBarrier $v\"\n\nMultiGridBarrier is a Julia module for solving nonlinear convex optimization problems in function spaces, such as p-Laplace problems. When regularity conditions are satisfied, the solvers are quasi-optimal.\n\nThe MultiGridBarrier module features finite element and spectral discretizations in 1d, 2d, and 3d.","category":"section"},{"location":"#Citation","page":"Home","title":"Citation","text":"If you use this package in your research, please cite:\n\nS. Loisel, \"The spectral barrier method to solve analytic convex optimization problems in function spaces,\" Numerische Mathematik, 2025. DOI: 10.1007/s00211-025-01508-0\n\nBibTeX:\n\n@article{Loisel2025,\n  author = {Loisel, Sébastien},\n  title = {The spectral barrier method to solve analytic convex optimization problems in function spaces},\n  journal = {Numerische Mathematik},\n  year = {2025},\n  doi = {10.1007/s00211-025-01508-0}\n}","category":"section"},{"location":"#Finite-elements","page":"Home","title":"Finite elements","text":"After installing MultiGridBarrier with the Julia package manager, in a Jupyter notebook, one solves a 1d p-Laplace problem as follows:\n\nusing PyPlot # hide\nusing MultiGridBarrier\nplot(fem1d_solve(L=5,p=1.0,verbose=false));\nsavefig(\"fem1d.svg\"); nothing # hide\nclose() #hide\n\n(Image: )\n\nA 2d p-Laplace problem:\n\nplot(fem2d_solve(L=3,p=1.0,verbose=false));\nsavefig(\"fem2d.svg\"); nothing # hide\nclose() #hide\n\n(Image: )","category":"section"},{"location":"#Spectral-elements","page":"Home","title":"Spectral elements","text":"Solve a 1d p-Laplace problem using spectral methods as follows:\n\nplot(spectral1d_solve(n=40,p=1.0,verbose=false));\nsavefig(\"spectral1d.svg\"); nothing # hide\nclose() #hide\n\n(Image: )\n\nA 2d p-Laplace problem:\n\nplot(spectral2d_solve(n=5,p=1.5,verbose=false));\nsavefig(\"spectral2d.svg\"); nothing # hide\nclose() #hide\n\n(Image: )","category":"section"},{"location":"#Solving-\\infty-Laplacians","page":"Home","title":"Solving infty-Laplacians","text":"For p geq 1 and domain Omega, the solution u of the p-Laplace problem is the minimizer of J(u) = nabla u_L^p(Omega)^p + int_Omega fu where u is in a suitable space of function satisfying, e.g. Dirichlet conditions, and f is a forcing. This definition must be modified for the infty-Laplace problem. Here we show how to minimize: J(u) = nabla u_L^infty(Omega)^p + int_Omega fu We put p=1 for simplicity.\n\nplot(fem1d_solve(L=5,p=1.0,state_variables=[:u :dirichlet; :s :uniform],verbose=false));\nsavefig(\"fem1dinfty.svg\"); nothing # hide\nclose() #hide\n\n(Image: )","category":"section"},{"location":"#Parabolic-problems","page":"Home","title":"Parabolic problems","text":"A time-dependent problem:\n\nplot(parabolic_solve(fem2d(L=3);h=0.1,verbose=false))","category":"section"},{"location":"#3D-Finite-Elements","page":"Home","title":"3D Finite Elements","text":"The Mesh3d submodule provides 3D hexahedral finite elements using PyVista for visualization.\n\nsol = fem3d_solve(L=2, verbose=false)\nfig = plot(sol)\nsavefig(fig, \"fem3d_demo.png\"); nothing # hide\n\n(Image: )\n\nA time-dependent 3D problem:\n\nplot(parabolic_solve(fem3d(L=2);h=0.1,verbose=false))","category":"section"},{"location":"#Module-reference","page":"Home","title":"Module reference","text":"","category":"section"},{"location":"#Types-reference","page":"Home","title":"Types reference","text":"","category":"section"},{"location":"#Functions-reference","page":"Home","title":"Functions reference","text":"","category":"section"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"#MultiGridBarrier.MultiGridBarrier","page":"Home","title":"MultiGridBarrier.MultiGridBarrier","text":"module MultiGridBarrier\n\nMultiGridBarrier solves nonlinear convex optimization problems in function spaces using a barrier (interior-point) method accelerated by a multigrid hierarchy constructed from your chosen discretization (FEM or spectral). The package provides simple, high-level entry points as well as a general solver that accept a \"geometry\" and optional keywords.\n\nA gentle introduction via the p-Laplacian\n\nFor a domain Ω ⊂ ℝᵈ and p ≥ 1, consider the variational problem\n\nmin_u  J(u) = int_Omega nabla u_2^p + fu  dx\n\nsubject to appropriate boundary conditions (e.g., homogeneous Dirichlet). The Euler–Lagrange equation gives the p-Laplace PDE:\n\nnabla cdot big(nabla u_2^p-2nabla ubig) = tfrac1pf quad textin  Omega\n\nwith the specified boundary conditions. This connection is obtained by integration by parts applied to the first variation of J(u).\n\nConstrained linear reformulation with a slack variable\n\nIntroduce a slack s(x) geq nabla u(x)_2^p and rewrite the objective using s:\n\nmin_us  int_Omega s + fu  dx\nquad textsubject toquad s ge nabla u_2^p\n\nThis is a convex optimization problem with a linear objective and convex constraints. In discrete form, we bundle the state into z, and apply a block \"differential\" operator D so that\n\nD z = beginbmatrix u  nabla u  s endbmatrix\nqquad\nc^top = beginbmatrix f  0  1 endbmatrix\n\nThe problem becomes\n\nmin_z int_Omega c(x)^top  (D z)(x)  dx\nquad textsubject toquad (uqs) in mathcalQ =  s ge q_2^p  textpointwise\n\nwhich MultiGridBarrier solves by a barrier method. An illustrative (simple) barrier for mathcalQ is\n\nmathcalF(qs) = -logbig(s^2p - q_2^2big) - 2log s\n\nand the method minimizes the barrier-augmented functional\n\nint_Omega t c(x)^top (D z)(x) + mathcalFbig((D z)(x)big)  dx\n\nfor increasing barrier parameter t. Internally, the solve proceeds on a hierarchy of grids with damped Newton steps and line search, but these details are abstracted away.\n\nHow to use it (discretizations and solvers)\n\nSolve with a convenience wrapper (recommended to start):\nsol = fem1d_solve(; kwargs...)\nsol = fem2d_solve(; kwargs...)\nsol = spectral1d_solve(; kwargs...)\nsol = spectral2d_solve(; kwargs...)\nOr call the general solver directly:\nsol = amgb(geometry; kwargs...) → AMGBSOL\nThe solution can be plotted by calling plot(sol). If using amgb() directly, you must construct a suitable geometry object:\ngeometry = fem1d(; L=4)         → 1D FEM on [-1, 1] with 2^L elements\ngeometry = fem2d(; L=2, K=...)  → 2D FEM (quadratic + bubble triangles)\ngeometry = spectral1d(; n=16)   → 1D spectral (Chebyshev/Clenshaw–Curtis)\ngeometry = spectral2d(; n=4)    → 2D spectral (tensor Chebyshev)\n\nQuick examples\n\n# 1D FEM p-Laplace\nz = fem1d_solve(L=5, p=1.0).z\n\n# 2D spectral p-Laplace\nz = spectral2d_solve(n=8, p=2.0).z\n\n# 2D FEM with custom boundary data\ng_custom(x) = [sin(π*x[1])*sin(π*x[2]), 10.0]\nz = fem2d_solve(L=3; p=1.0, g=g_custom).z\n\n# Time-dependent (implicit Euler)\nsol = parabolic_solve(fem2d(L=3); h=0.1)\n# plot(sol) animates the first component\n\nInputs and defaults (high level)\n\np::Real = 1.0: exponent in the p-Laplace term\ng, f: boundary/initial data and forcing; either as functions g(x), f(x) or as grids g_grid, f_grid\nD and state_variables: symbolic specifications of which operators act on which variables (sane defaults provided based on the geometry’s dimension)\nQ: convex set (by default, a p-Laplace-compatible set via convex_Euclidian_power)\nverbose, logfile: visualization and logging\nAdvanced control: tol, t, t_feasibility, line_search, stopping_criterion, finalize\n\nWhat you get back\n\nStatic solvers (amgb, *_solve) return an AMGBSOL with fields:\nz::X (typically Matrix{T}): solution on the finest grid (nodes × components)\nSOL_main, SOL_feasibility: per-phase diagnostics\nlog::String: textual log for debugging\ngeometry: the Geometry used to construct the multilevel operators\nThe solution object supports plot(sol) to visualize the first component.\nThe time-dependent solver parabolic_solve returns a ParabolicSOL with fields:\ngeometry, ts::Vector, u::Array(nodes × components × timesteps)\nCall plot(parabolic_sol) to animate using ts (see plot docs for timing options).\n\nUtilities\n\ninterpolate(geometry, z, points): evaluate the discrete solution at arbitrary points\nplot(sol) or plot(geometry, z): plot 1D curves or 2D surfaces\nplot(geometry, ts, U; frame_time=..., embed_limit=..., printer=...): animate a time sequence at absolute times ts (seconds), e.g., from parabolic_solve\nConvex set helpers: convex_Euclidian_power, convex_linear, convex_piecewise, intersect\n\nErrors and diagnostics\n\nThrows AMGBConvergenceFailure if the feasibility subproblem or the main solve cannot converge\nSet verbose=true for a progress bar; inspect SOL_main/feasibility and log for details\n\nSee also\n\nDiscretizations: fem1d, fem2d, spectral1d, spectral2d\nSolvers: amgb, fem1d_solve, fem2d_solve, spectral1d_solve, spectral2d_solve, parabolic_solve\nConvex: convex_Euclidian_power, convex_linear, convex_piecewise, intersect\nVisualization & sampling: plot, interpolate\n\n\n\n\n\n","category":"module"},{"location":"#MultiGridBarrier.Mesh3d","page":"Home","title":"MultiGridBarrier.Mesh3d","text":"module Mesh3d\n\nA submodule of MultiGridBarrier providing 3D hexahedral finite element discretization.\n\nExports:\n\nFEM3D: Discretization type for 3D hexahedral finite elements\nfem3d: Create a 3D FEM geometry\nfem3d_solve: Solve a 3D PDE using the Spectral Barrier Method\nplot, savefig: Plotting functions for 3D solutions\nHTML5anim: Animation type for time-dependent solutions\n\n\n\n\n\n","category":"module"},{"location":"#MultiGridBarrier.AMGBConvergenceFailure","page":"Home","title":"MultiGridBarrier.AMGBConvergenceFailure","text":"AMGBConvergenceFailure <: Exception\n\nThrown when the AMGB solver fails to converge (feasibility or main phase). Includes a descriptive message about the failure.\n\n\n\n\n\n","category":"type"},{"location":"#MultiGridBarrier.Convex","page":"Home","title":"MultiGridBarrier.Convex","text":"Convex{T, Args}\n\nContainer for a convex constraint set used by AMGB.\n\nFields:\n\nbarrier: (F0, F1, F2) - value, gradient, Hessian functions\ncobarrier: (F0, F1, F2) - with slack for feasibility\nslack: initial slack function\nargs: tuple of parameter arrays, splatted to maprowsgpu\n\nBarrier functions receive (args_rows..., y) where args_rows are per-vertex parameter data (via broadcasting), and y is the solution SVector. This enables true GPU execution without scalar indexing.\n\nConstruct via helpers like convex_linear, convex_Euclidian_power, convex_piecewise, or intersect. These helpers return Vector{Convex{T}} with one Convex per multigrid level.\n\n\n\n\n\n","category":"type"},{"location":"#MultiGridBarrier.EuclidianPowerBarrier","page":"Home","title":"MultiGridBarrier.EuclidianPowerBarrier","text":"EuclidianPowerBarrier{NZ,NZM1,IDX}\n\nGPU-compatible functor for barrier function evaluation. Encodes dimension NZ and index type IDX as type parameters.\n\n\n\n\n\n","category":"type"},{"location":"#MultiGridBarrier.EuclidianPowerBarrierGrad","page":"Home","title":"MultiGridBarrier.EuclidianPowerBarrierGrad","text":"EuclidianPowerBarrierGrad{NZ,NZM1,IDX,CoreGrad}\n\nGPU-compatible functor for barrier gradient evaluation.\n\n\n\n\n\n","category":"type"},{"location":"#MultiGridBarrier.EuclidianPowerBarrierHess","page":"Home","title":"MultiGridBarrier.EuclidianPowerBarrierHess","text":"EuclidianPowerBarrierHess{NZ,NZM1,IDX,CoreHess}\n\nGPU-compatible functor for barrier Hessian evaluation.\n\n\n\n\n\n","category":"type"},{"location":"#MultiGridBarrier.EuclidianPowerCobarrier","page":"Home","title":"MultiGridBarrier.EuclidianPowerCobarrier","text":"EuclidianPowerCobarrier{NZ,NZM1,IDX}\n\nGPU-compatible functor for cobarrier function evaluation.\n\n\n\n\n\n","category":"type"},{"location":"#MultiGridBarrier.EuclidianPowerCobarrierGrad","page":"Home","title":"MultiGridBarrier.EuclidianPowerCobarrierGrad","text":"EuclidianPowerCobarrierGrad{NZ,NZM1,IDX,CoreGrad}\n\nGPU-compatible functor for cobarrier gradient evaluation.\n\n\n\n\n\n","category":"type"},{"location":"#MultiGridBarrier.EuclidianPowerCobarrierHess","page":"Home","title":"MultiGridBarrier.EuclidianPowerCobarrierHess","text":"EuclidianPowerCobarrierHess{NZ,NZM1,IDX,CoreHess}\n\nGPU-compatible functor for cobarrier Hessian evaluation.\n\n\n\n\n\n","category":"type"},{"location":"#MultiGridBarrier.EuclidianPowerSlack","page":"Home","title":"MultiGridBarrier.EuclidianPowerSlack","text":"EuclidianPowerSlack{NZ,NZM1,IDX}\n\nGPU-compatible functor for slack computation.\n\n\n\n\n\n","category":"type"},{"location":"#MultiGridBarrier.FEM1D","page":"Home","title":"MultiGridBarrier.FEM1D","text":"FEM1D{T}\n\n1D FEM geometry descriptor. Field: L::Int (levels). Use with amgb.\n\n\n\n\n\n","category":"type"},{"location":"#MultiGridBarrier.FEM2D","page":"Home","title":"MultiGridBarrier.FEM2D","text":"FEM2D{T}\n\n2D FEM geometry descriptor for quadratic+bubble triangles. Fields: K::Matrix{T} (3n×2 mesh), L::Int (levels). Use with amgb.\n\n\n\n\n\n","category":"type"},{"location":"#MultiGridBarrier.Geometry","page":"Home","title":"MultiGridBarrier.Geometry","text":"Geometry{T,X,W,M,Discretization}\n\nContainer for discretization geometry and the multigrid transfer machinery used by AMGB.\n\nConstructed by high-level front-ends like fem1d, fem2d, spectral1d, and spectral2d. It collects the physical/sample points, quadrature weights, per-level subspace embeddings, discrete operators (e.g. identity and derivatives), and intergrid transfer operators (refine/coarsen).\n\nType parameters\n\nT: scalar numeric type (e.g. Float64)\nX: type of the point storage for x (typically Matrix{T}; may be any AbstractArray with size (n_nodes, dim))\nW: type of the weight storage for w (typically Vector{T}; may be any AbstractVector)\nM: matrix type used for linear operators (e.g. SparseMatrixCSC{T,Int} or Matrix{T})\nDiscretization: front-end descriptor (e.g. FEM1D{T}, FEM2D{T}, SPECTRAL1D{T}, SPECTRAL2D{T})\n\nFields\n\ndiscretization::Discretization: Discretization descriptor that encodes dimension and grid construction\nx::X: Sample/mesh points on the finest level; size is (n_nodes, dim)\nw::W: Quadrature weights matching x (length n_nodes)\nsubspaces::Dict{Symbol,Vector{M}}: Per-level selection/embedding matrices for function spaces (keys commonly include :dirichlet, :full, :uniform). Each value is a vector of length L with one matrix per level.\noperators::Dict{Symbol,M}: Discrete operators defined on the finest level (e.g. :id, :dx, :dy). Operators at other levels are obtained via coarsen_fine * operator * refine_fine inside amg.\nrefine::Vector{M}: Level-to-level refinement (prolongation) matrices for the primary state space\ncoarsen::Vector{M}: Level-to-level coarsening (restriction) matrices for the primary state space\n\nNotes\n\nGeometry is consumed by amg to build an AMG hierarchy and by utilities like interpolate and plot.\nThe length of refine/coarsen equals the number of levels L; the last entry is typically the identity.\n\n\n\n\n\n","category":"type"},{"location":"#MultiGridBarrier.ParabolicSOL","page":"Home","title":"MultiGridBarrier.ParabolicSOL","text":"ParabolicSOL{T,X,W,Mat,Discretization}\n\nSolution structure returned by parabolic_solve.\n\nFields\n\ngeometry::Geometry{T,X,W,Mat,Discretization}: the discretization geometry.\nts::Vector{T}: time stamps for each solution snapshot.\nu::Vector{X}: list of solution matrices, one per timestep. Each matrix has size (n_nodes, n_components).\n\nPlotting\n\nUse plot(sol) to create an HTML5 animation, or plot(sol, k) to animate component k.\n\n\n\n\n\n","category":"type"},{"location":"#MultiGridBarrier.SPECTRAL1D","page":"Home","title":"MultiGridBarrier.SPECTRAL1D","text":"SPECTRAL1D{T}\n\n1D spectral geometry descriptor (Chebyshev). Field: n::Int (nodes). Use with amgb.\n\n\n\n\n\n","category":"type"},{"location":"#MultiGridBarrier.SPECTRAL2D","page":"Home","title":"MultiGridBarrier.SPECTRAL2D","text":"SPECTRAL2D{T}\n\n2D spectral geometry descriptor (tensor Chebyshev). Field: n::Int (nodes per dim). Use with amgb.\n\n\n\n\n\n","category":"type"},{"location":"#MultiGridBarrier.Mesh3d.FEM3D","page":"Home","title":"MultiGridBarrier.Mesh3d.FEM3D","text":"FEM3D{T}\n\nDiscretization type for 3D hexahedral finite elements.\n\nFields\n\nk::Int: Polynomial order of elements.\nK::Matrix{T}: Coarse mesh vertices (N x 3).\nL::Int: Number of multigrid levels.\n\n\n\n\n\n","category":"type"},{"location":"#Base.intersect-Union{Tuple{T}, Tuple{Geometry, Vector{<:Convex{T}}, Vararg{Vector{<:Convex{T}}}}} where T","page":"Home","title":"Base.intersect","text":"intersect(geometry::Geometry, U::Vector{Convex{T}}, rest...) where {T}\n\nReturn the intersection of convex domain vectors as a single Vector{Convex{T}}. Equivalent to convex_piecewise with all pieces active at all vertices.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.Log-Tuple{T} where T","page":"Home","title":"MultiGridBarrier.Log","text":"Log(x::T) where {T} = x<=0 ? T(-Inf) : Base.log(x)     # \"Convex programmer's log\"\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier._ep_get_z_and_parts-Union{Tuple{TT}, Tuple{N}, Tuple{NZM1}, Tuple{NZ}, Tuple{StaticArraysCore.SMatrix{NZ, NZ, TT}, StaticArraysCore.SVector{NZ, TT}, Colon, StaticArraysCore.SVector{N, TT}, Val{NZM1}}} where {NZ, NZM1, N, TT}","page":"Home","title":"MultiGridBarrier._ep_get_z_and_parts","text":"_ep_get_z_and_parts(Ax, bx, idx, y, nz_m1_val)\n\nGPU-compatible helper to compute z = Ax * y[idx] + bx and split into (q, s). Dispatches on idx type for optimal GPU code generation.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier._raw_array-Tuple{Any}","page":"Home","title":"MultiGridBarrier._raw_array","text":"_raw_array(x)\n\nExtract the raw array from an MPI wrapper, or return x unchanged for non-MPI types. This is needed for GPU kernels: barriers must capture only isbits-compatible arrays (like MtlVector/MtlMatrix), not MPI wrappers that contain non-isbits partition data.\n\nFor non-MPI types, returns x unchanged. MultiGridBarrierMPI specializes this to extract .v from VectorMPI and .A from MatrixMPI.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier._safe_pow-Union{Tuple{T}, Tuple{T, T}} where T","page":"Home","title":"MultiGridBarrier._safe_pow","text":"_safe_pow(s::T, α::T) where T\n\nGPU-compatible power function: compute s^α using exp(α * log(s)). Avoids boxing issues with non-integer exponents on GPU.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier._scatter_cobarrier_gradient-Union{Tuple{NP1}, Tuple{T}, Tuple{N}, Tuple{Colon, StaticArraysCore.SVector{N, T}, T, Val{NP1}}} where {N, T, NP1}","page":"Home","title":"MultiGridBarrier._scatter_cobarrier_gradient","text":"_scatter_cobarrier_gradient(idx, grad, g_slack, ::Val{NP1})\n\nGPU-compatible helper: scatter cobarrier gradient with slack term. Builds full gradient of size NP1 where positions idx get grad and position NP1 gets g_slack.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier._scatter_cobarrier_hessian-Union{Tuple{NP1}, Tuple{T}, Tuple{M}, Tuple{MM}, Tuple{Colon, StaticArraysCore.SVector{MM, T}, StaticArraysCore.SVector{M, T}, T, Val{M}, Val{NP1}}} where {MM, M, T, NP1}","page":"Home","title":"MultiGridBarrier._scatter_cobarrier_hessian","text":"_scatter_cobarrier_hessian(idx, H_idx_flat, cross, H_ss, ::Val{M}, ::Val{NP1})\n\nGPU-compatible helper: scatter cobarrier Hessian with slack cross terms. Hidxflat is flattened column-major (from AtdiagA), M is size of Hidx. Builds full Hessian of size NP1×NP1 with:\n\nH_idx at positions (idx, idx)\ncross at positions (idx, NP1) and (NP1, idx)\nH_ss at position (NP1, NP1)\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier._scatter_gradient-Union{Tuple{T}, Tuple{N}, Tuple{Colon, StaticArraysCore.SVector{N, T}, Val{N}}} where {N, T}","page":"Home","title":"MultiGridBarrier._scatter_gradient","text":"_scatter_gradient(idx, grad, ::Val{N})\n\nGPU-compatible helper: scatter a gradient vector to full-size SVector. When idx is Colon, returns grad unchanged. When idx is SVector{M,Int}, scatters grad into a zero vector of size N.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier._scatter_hessian-Union{Tuple{T}, Tuple{N}, Tuple{Colon, StaticArraysCore.SMatrix{N, N, T}, Val{N}}} where {N, T}","page":"Home","title":"MultiGridBarrier._scatter_hessian","text":"_scatter_hessian(idx, H, ::Val{N})\n\nGPU-compatible helper: scatter a Hessian matrix to full-size matrix (returned as SVector). When idx is Colon, returns SVector(H). When idx is SVector{M,Int}, scatters H into a zero matrix of size N×N.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier._static_pop-Union{Tuple{NZM1}, Tuple{T}, Tuple{NZ}, Tuple{StaticArraysCore.SVector{NZ, T}, Val{NZM1}}} where {NZ, T, NZM1}","page":"Home","title":"MultiGridBarrier._static_pop","text":"_static_pop(z::SVector{NZ,T}, ::Val{NZM1}) where {NZ,T,NZM1}\n\nGPU-compatible helper: pop the last element from an SVector. Uses compile-time constant NZM1 to avoid dynamic dispatch. Returns an SVector of size NZM1 = NZ-1.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier._to_cpu_array-Tuple{Any}","page":"Home","title":"MultiGridBarrier._to_cpu_array","text":"_to_cpu_array(x)\n\nConvert array to CPU if it's a GPU array, otherwise return unchanged. Barrier functions need CPU arrays for scalar indexing (A[j,:]). For non-GPU arrays, this is a no-op. MultiGridBarrierMPI specializes this to handle GPU arrays.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.amgb-Union{Tuple{}, Tuple{Geometry{T, X, W, Mat, Discretization}}, Tuple{Discretization}, Tuple{Mat}, Tuple{W}, Tuple{X}, Tuple{T}} where {T, X, W, Mat, Discretization}","page":"Home","title":"MultiGridBarrier.amgb","text":"amgb(geometry::Geometry{T,X,W,Mat,Discretization}=fem1d(); kwargs...) where {T, X, W, Mat, Discretization}\n\nAlgebraic MultiGrid Barrier (AMGB) solver for nonlinear convex optimization problems in function spaces using multigrid barrier methods.\n\nThis is the main high-level entry point for solving p-Laplace and related problems using the barrier method with multigrid acceleration. The solver operates in two phases:\n\nFeasibility phase: Finds an interior point for the constraint set (if needed)\nMain optimization phase: Solves the barrier-augmented optimization problem\n\nArguments\n\ngeometry: Discretization geometry (default: fem1d()). Options:\nfem1d(L=n): 1D finite elements with 2^L elements\nfem2d(L=n, K=mesh): 2D finite elements\nspectral1d(n=m): 1D spectral with m nodes\nspectral2d(n=m): 2D spectral with m×m nodes\n\nKeyword Arguments\n\nProblem Specification\n\ndim::Integer = amg_dim(geometry.discretization): Problem dimension (1 or 2), auto-detected from geometry\nstate_variables::Matrix{Symbol} = [:u :dirichlet; :s :full]: Solution components and their function spaces\nD::Matrix{Symbol} = default_D(dim): Differential operators to apply to state variables\nx = geometry.x: Mesh/sample points where f and g are evaluated when they are functions\n\nProblem Data\n\np::T = 1.0: Exponent for p-Laplace operator (p ≥ 1)\ng::Function = default_g(T, dim): Boundary conditions/initial guess (function of spatial coordinates)\ng_grid::X (same container type as x): Alternative to g, directly provide values on grid (default: g evaluated at x)\nf::Function = default_f(T, dim): Forcing term/cost functional (function of spatial coordinates)\nf_grid::X (same container type as x): Alternative to f, directly provide values on grid (default: f evaluated at x)\nQ::Vector{Convex{T}} = convex_Euclidian_power(T; geometry, idx, p): Vector of convex constraint sets (one per multigrid level) with captured parameter grids for GPU compatibility\n\nOutput Control\n\nverbose::Bool = true: Display progress bar during solving\nlogfile = devnull: IO stream for logging (default: no file logging)\n\nSolver Control (passthrough)\n\nAdditional keyword arguments are forwarded to the internal solvers:\n\ntol = sqrt(eps(T)): Barrier tolerance; the method stops once 1/t > 1/tol\nt = T(0.1): Initial barrier parameter for the main solve\nt_feasibility = t: Initial barrier parameter for the feasibility solve\nmaxit = 10000: Maximum number of outer (barrier) iterations\nkappa = T(10.0): Multiplier controlling barrier growth (t ← min(kappa*t, ...))\nearly_stop = z->false: Callback z -> Bool; if true, halt early (e.g. after feasibility is reached)\nmax_newton = ceil((log2(-log2(eps(T))))+2): Max Newton iterations per inner solve\nstopping_criterion = stopping_inexact(sqrt(minimum(M[1].w))/2, T(0.5)): Newton stopping rule\nuse stopping_exact(theta) or stopping_inexact(lambda_tol, theta)\nline_search = linesearch_backtracking(T): Line search strategy (linesearch_backtracking or linesearch_illinois)\nfinalize = stopping_exact(T(0.5)): Extra final Newton pass with stricter stopping\nprogress = x->nothing: Progress callback in [0,1]; when verbose=true this is set internally\nprintlog = (args...)->nothing: Logging callback; overridden by logfile when using amgb\n\nDefault Values\n\nThe defaults for f, g, and D depend on the problem dimension:\n\n1D Problems\n\nf(x) = [0.5, 0.0, 1.0] - Forcing term\ng(x) = [x[1], 2] - Boundary conditions\nD = [:u :id; :u :dx; :s :id] - Identity, derivative, identity\n\n2D Problems\n\nf(x) = [0.5, 0.0, 0.0, 1.0] - Forcing term\ng(x) = [x[1]²+x[2]², 100.0] - Boundary conditions\nD = [:u :id; :u :dx; :u :dy; :s :id] - Identity, x-derivative, y-derivative, identity\n\nReturns\n\nSolution object with fields:\n\nz: Solution matrix of size (n_nodes, n_components) containing the computed solution\nSOL_feasibility: Feasibility phase results (nothing if the initial point was already feasible), otherwise a solution object (see below)\nSOL_main: Main optimization phase results as a solution object (see below)\nlog: String containing detailed iteration log for debugging\ngeometry: The input geometry object\n\nEach solution object (SOL_feasibility and SOL_main) is a NamedTuple containing:\n\nz: Solution vector (flattened; for feasibility phase includes auxiliary slack variable)\nz_unfinalized: Solution before final refinement step\nc: Cost functional used in this phase\nits: Iteration counts across levels and barrier steps (L×k matrix where L is number of levels, k is number of barrier iterations)\nts: Sequence of barrier parameters t used (length k)\nkappas: Step size multipliers used at each iteration (length k)\ntimes: Wall-clock timestamps for each iteration (length k)\nt_begin, t_end, t_elapsed: Timing information for this phase\npassed: Boolean array indicating phase 1 success at each level\nc_dot_Dz: Values of ⟨c, D*z⟩ at each barrier iteration (length k)\n\nAlgorithm Overview\n\nThe AMGB method combines:\n\nInterior point method: Uses logarithmic barriers to handle constraints\nMultigrid acceleration: Solves on hierarchy of grids from coarse to fine\nDamped Newton iteration: Inner solver with line search for robustness\n\nThe solver automatically handles:\n\nConstruction of appropriate discretization and multigrid hierarchy\nFeasibility restoration when initial point is infeasible\nAdaptive barrier parameter updates with step size control\nConvergence monitoring across multiple grid levels\nProgress reporting (when verbose=true) and logging (to logfile if specified)\n\nErrors\n\nThrows AMGBConvergenceFailure if:\n\nThe feasibility problem cannot be solved (problem may be infeasible)\nThe main optimization fails to converge within maxit iterations\nNewton iteration fails at any grid level\n\nExamples\n\n# Solve 1D p-Laplace problem with p=1.5 using FEM\nz = amgb(fem1d(L=4); p=1.5).z\n\n# Solve 2D problem with spectral elements\nz = amgb(spectral2d(n=8); p=2.0).z\n\n# Custom boundary conditions\ng_custom(x) = [sin(π*x[1])*sin(π*x[2]), 10.0]\nz = amgb(fem2d(L=3); g=g_custom).z\n\n# Get detailed solution information\nsol = amgb(fem1d(L=3); verbose=true)\nprintln(\"Iterations: \", sum(sol.SOL_main.its))\nprintln(\"Final barrier parameter: \", sol.SOL_main.ts[end])\n\n# Visualize the first component\nplot(sol)\n\n# Log iterations to a file\nopen(\"solver.log\", \"w\") do io\n    amgb(fem2d(L=2); logfile=io, verbose=false)\nend\n\nSee Also\n\nfem1d_solve, fem2d_solve, spectral1d_solve, spectral2d_solve: Convenience wrappers for specific discretizations\nConvex: Constraint set specification type\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.apply_D-Tuple{Any, Any}","page":"Home","title":"MultiGridBarrier.apply_D","text":"apply_D(D,z) = hcat([D[k]*z for k in 1:length(D)]...)\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.barrier-Union{Tuple{Convex{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.barrier","text":"barrier(Q::Convex{T}) -> Barrier\n\nCreate a Barrier from a Convex constraint specification.\n\nThe Convex's barrier functions receive row data via broadcasting: F0(args_rows..., y) where args_rows are per-vertex parameter data (from Q.args) and y is the solution SVector at that vertex.\n\nThis enables true GPU execution without scalar indexing - Q.args are splatted to maprowsgpu which broadcasts them together.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.convex_Euclidian_power-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.convex_Euclidian_power","text":"convex_Euclidian_power(::Type{T}=Float64; geometry, idx=Colon(), A=(x)->I, b=(x)->T(0), p=x->T(2), ...)\n\nCreate a convex set defined by Euclidean norm power constraints, with GPU support.\n\nConstructs a Vector{Convex{T}} (one per multigrid level) representing the power cone: {y : s ≥ ‖q‖₂^p} where [q; s] = A(x)*y[idx] + b(x)\n\nThis is the fundamental constraint for p-Laplace problems where we need s ≥ ‖∇u‖^p for some scalar field u.\n\nArguments\n\nT::Type=Float64: Numeric type for computations\n\nKeyword Arguments\n\ngeometry::Geometry: Required. The multigrid geometry (provides grid and coarsen operators)\nidx=Colon(): Indices of y to which transformation applies\nA::Function: Matrix function x -> A(x) for linear transformation\nb::Function: Vector function x -> b(x) for affine shift\np::Function: Exponent function x -> p(x) where p(x) ≥ 1\nA_grid, b_grid, p_grid: Optional pre-computed grids (computed from A,b,p if not provided)\n\nReturns\n\nVector{Convex{T}} with one Convex per multigrid level. Each level's barriers capture their level's pre-computed parameter grids (A_l, b_l, p_l) and receive (j::Integer, y::SVector) where j is the vertex index.\n\nMathematical Details\n\nThe barrier function is:\n\nFor p = 2: -log(s² - ‖q‖²)\nFor p ≠ 2: -log(s^(2/p) - ‖q‖²) - μ(p)*log(s) where μ(p) = 0 if p∈{1,2}, 1 if p<2, 2 if p>2\n\nExamples\n\n# Standard p-Laplace constraint with GPU support\ngeometry = fem1d(Float32; L=5)\nQ = convex_Euclidian_power(Float32; geometry=geometry, idx=default_idx(1), p=x->1.5f0)\n\n# Q is now Vector{Convex{Float32}} with one per level\n# Each Q[l] has barriers that capture level-l pre-computed arrays\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.convex_piecewise-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.convex_piecewise","text":"convex_piecewise(::Type{T}=Float64; Q::Tuple{Vararg{Vector{Convex{T}}}}, geometry, select::Function=x->(true,...)) where {T}\n\nBuild a Vector{Convex{T}} (one per level) that combines multiple convex domains with spatial selectivity.\n\nArguments\n\nQ::Tuple{Vararg{Vector{Convex{T}}}}: tuple of convex piece vectors. Each element is a Vector{Convex{T}} of length L (one per level).\ngeometry::Geometry: geometry object with coarsen operators (determines L levels).\nselect::Function: a function x -> Tuple{Bool,...} indicating which pieces are active at spatial position x.\nselect_grid: (optional) pre-computed selection grid for each level. If not provided, computed from select function.\n\nSemantics\n\nFor each level l, the resulting Convex has:\n\nbarrier(j, y) = ∑(Q[k][l].barrier(j, y) for k where sel_l[j][k])\ncobarrier(j, yhat) = ∑(Q[k][l].cobarrier(j, yhat) for k where sel_l[j][k])\nslack(j, y) = max(Q[k][l].slack(j, y) for k where sel_l[j][k])\n\nThe slack is the maximum over active pieces, ensuring a single slack value suffices for feasibility.\n\nExamples\n\n# Intersection of two convex domains\nU = convex_Euclidian_power(Float64; geometry=geo, idx=SVector(1, 3), p=x->2)\nV = convex_linear(Float64; geometry=geo, A=x->A_matrix, b=x->b_vector)\nselect_both(x) = (true, true)\nQint = convex_piecewise(Float64; Q=(U, V), geometry=geo, select=select_both)\n\n# Region-dependent constraints\nQ_left = convex_Euclidian_power(Float64; geometry=geo, p=x->1.5)\nQ_right = convex_Euclidian_power(Float64; geometry=geo, p=x->2.0)\nselect(x) = (x[1] < 0, x[1] >= 0)\nQreg = convex_piecewise(Float64; Q=(Q_left, Q_right), geometry=geo, select=select)\n\nSee also: intersect, convex_linear, convex_Euclidian_power.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.fem1d-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.fem1d","text":"fem1d(::Type{T}=Float64; L=4, kwargs...)\n\nConstruct 1D FEM geometry (piecewise linear) on [-1, 1]. Returns a Geometry suitable for use with amgb. Keyword L sets 2^L elements.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.fem1d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.fem1d_solve","text":"fem1d_solve(::Type{T}=Float64;rest...) where {T} = amgb(fem1d(T;rest...);rest...)\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.fem2d-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.fem2d","text":"fem2d(::Type{T}=Float64; L=2, K=T[-1 -1;1 -1;-1 1;1 -1;1 1;-1 1], kwargs...)\n\nConstruct 2D FEM geometry (quadratic + bubble) on a triangular mesh. Returns a Geometry suitable for use with amgb. Keywords: L levels, K 3n×2 vertices.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.fem2d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.fem2d_solve","text":"fem2d_solve(::Type{T}=Float64;rest...) where {T} = amgb(fem2d(T;rest...);rest...)\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.interpolate","page":"Home","title":"MultiGridBarrier.interpolate","text":"interpolate(M::Geometry, z::Vector, t)\n\nInterpolate a solution vector at specified points.\n\nGiven a solution z on the mesh M, evaluates the solution at new points t using the appropriate interpolation method for the discretization.\n\nSupported discretizations\n\n1D FEM (FEM1D): piecewise-linear interpolation\n1D spectral (SPECTRAL1D): spectral polynomial interpolation\n2D spectral (SPECTRAL2D): tensor-product spectral interpolation\n\nNote: 2D FEM interpolation is not currently provided.\n\nArguments\n\nM::Geometry: The geometry containing grid and basis information\nz::Vector: Solution vector on the finest grid (length must match number of DOFs)\nt: Evaluation points. Format depends on dimension:\n1D: scalar or Vector{T} of x-coordinates\n2D spectral: Matrix{T} where each row is [x, y]\n\nReturns\n\nInterpolated values at the specified points. Shape matches input t.\n\nExamples\n\n# 1D interpolation (FEM)\ngeom = fem1d(L=3)\nz = sin.(π .* vec(geom.x))\ny = interpolate(geom, z, 0.5)\ny_vec = interpolate(geom, z, [-0.5, 0.0, 0.5])\n\n# 2D interpolation (spectral)\ngeom = spectral2d(n=4)\nz = exp.(-geom.x[:,1].^2 .- geom.x[:,2].^2)\npoints = [0.0 0.0; 0.5 0.5; -0.5 0.5]\nvals = interpolate(geom, z, points)\n\n\n\n\n\n","category":"function"},{"location":"#MultiGridBarrier.multigrid_from_fine_grid-Tuple{Geometry, Any}","page":"Home","title":"MultiGridBarrier.multigrid_from_fine_grid","text":"multigrid_from_fine_grid(geometry, f_grid_fine)\n\nCoarsen a fine-level grid value to all multigrid levels.\n\nGiven a value computed on the finest grid (e.g., pre-computed function values), applies the geometry's coarsening operators to produce values at each level.\n\nArguments\n\ngeometry::Geometry: The multigrid geometry containing coarsening operators\nf_grid_fine: Values on the finest grid (VectorMPI or MatrixMPI)\n\nReturns\n\nVector of length L (number of levels), where index L is the finest level and index 1 is the coarsest level\n\nExample\n\n# Pre-compute p(x) on fine grid, then coarsen to all levels\np_grid_fine = map_rows(p, geometry.x)\np_grid_all = multigrid_from_fine_grid(geometry, p_grid_fine)\n# p_grid_all[L] is fine level, p_grid_all[1] is coarsest\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.parabolic_solve-Union{Tuple{}, Tuple{Geometry{T, X, W, Mat, Discretization}}, Tuple{Discretization}, Tuple{Mat}, Tuple{W}, Tuple{X}, Tuple{T}} where {T, X, W, Mat, Discretization}","page":"Home","title":"MultiGridBarrier.parabolic_solve","text":"parabolic_solve(geometry::Geometry{T,X,W,Mat,Discretization}=fem2d(); kwargs...) where {T, X, W, Mat, Discretization}\n\nSolve time-dependent p-Laplace problems using implicit Euler timestepping.\n\nSolves the parabolic PDE:\n\nu_t - nabla cdot (nabla u_2^p-2nabla u) = -f_1\n\nusing implicit Euler discretization and barrier methods.\n\nArguments\n\ngeometry: Discretization geometry (default: fem2d()).\n\nKeyword Arguments\n\nDiscretization\n\nstate_variables: State variables (default: [:u :dirichlet; :s1 :full; :s2 :full]).\nD: Differential operators (default depends on spatial dimension).\ndim::Int: Spatial dimension (auto-detected from geometry).\n\nTime Integration\n\nt0::T=0: Initial time.\nt1::T=1: Final time.\nh::T=0.2: Time step size.\nts::AbstractVector{T}=t0:h:t1: Time grid; override to provide a custom, nonuniform, nondecreasing sequence.\n\nProblem Parameters\n\np::T=1: Exponent for the p-Laplacian.\nf1: Source term function of signature (t, x) -> T (default: (t,x)->T(0.5)).\ng: Initial/boundary conditions function of signature (t, x) -> Vector{T} (default depends on dimension).\nQ: Convex constraints (default: appropriate for p-Laplace).\n\nOutput Control\n\nverbose::Bool=true: Show a progress bar during time stepping.\n\nAdditional Parameters\n\nrest...: Passed through to amgb for each time step.\n\nReturns\n\nA ParabolicSOL with fields:\n\ngeometry: the Geometry used.\nts::Vector{T}: time stamps.\nu::Vector{Matrix{T}}: list of solution matrices, one per timestep, each of size (n_nodes, n_components).\n\nAnimate with plot(sol) (or plot(sol, k) for component k). To save to a file, use the plotting printer, e.g. plot(sol; printer=anim->anim.save(\"out.mp4\")).\n\nMathematical Formulation\n\nThe implicit Euler scheme u_t approx (u_k+1-u_k)h gives:\n\nu_k+1 - hnabla cdot (nabla u_k+1^p-2nabla u_k+1) = u_k - h f_1\n\nWe minimize the functional:\n\nJ(u) = int_Omega tfrac12u^2 + tfrachpnabla u^p + (h f_1 - u_k)u  dx\n\nWith slack variables s_1 ge u^2 and s_2 ge nabla u^p, this becomes:\n\nmin int_Omega tfrac12s_1 + tfrachps_2 + (h f_1 - u_k)u  dx\n\nExamples\n\n# Basic 2D heat equation (p=2)\nsol = parabolic_solve(; p=2.0, h=0.1)\n\n# 1D p-Laplace with custom parameters\nsol = parabolic_solve(fem1d(L=5); p=1.5, h=0.05, t1=2.0)\n\n# Spectral discretization\nsol = parabolic_solve(spectral2d(n=8); verbose=true)\n\n# Custom initial condition\ng_init(t, x) = [exp(-10*(x[1]^2 + x[2]^2)), 0, 0]\nsol = parabolic_solve(; g=g_init)\n\nSee Also\n\namgb: Single time step solver\nplot: Animation and plotting function\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.spectral1d-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.spectral1d","text":"spectral1d(::Type{T}=Float64; n=16, kwargs...)\n\nConstruct 1D spectral geometry with n Chebyshev nodes (degree n-1). Returns a Geometry suitable for use with amgb.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.spectral1d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.spectral1d_solve","text":"spectral1d_solve(::Type{T}=Float64;rest...) where {T} = amgb(spectral1d(T;rest...);rest...)\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.spectral2d-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.spectral2d","text":"spectral2d(::Type{T}=Float64; n=4, kwargs...)\n\nConstruct 2D spectral geometry with n×n Chebyshev nodes on [-1,1]^2. Returns a Geometry suitable for use with amgb.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.spectral2d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.spectral2d_solve","text":"spectral2d_solve(::Type{T}=Float64;rest...) where {T} = amgb(spectral2d(T;rest...);rest...)\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.stopping_exact-Tuple{T} where T","page":"Home","title":"MultiGridBarrier.stopping_exact","text":"stopping_exact(theta::T) where {T}\n\nCreate an exact stopping criterion for Newton methods.\n\nArguments\n\ntheta : tolerance parameter for gradient norm relative decrease (type T).\n\nReturns\n\nA stopping criterion function with signature: stop(ymin, ynext, gmin, gnext, n, ndecmin, ndec) -> Bool\n\nwhere:\n\nymin : minimum objective value seen so far.\nynext : current objective value.\ngmin : minimum gradient norm seen so far.\ngnext : current gradient vector.\nn : current Newton direction.\nndecmin : square root of minimum Newton decrement seen so far.\nndec : square root of current Newton decrement.\n\nAlgorithm\n\nReturns true (stop) if both conditions hold:\n\nNo objective improvement: ynext ≥ ymin\nGradient norm stagnation: ‖gnext‖ ≥ theta * gmin\n\nNotes\n\nThis criterion is \"exact\" in the sense that it requires both objective and gradient stagnation before stopping, making it suitable for high-precision optimization. Typical values of theta are in the range [0.1, 0.9].\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.stopping_inexact-Union{Tuple{T}, Tuple{T, T}} where T","page":"Home","title":"MultiGridBarrier.stopping_inexact","text":"stopping_inexact(lambda_tol::T, theta::T) where {T}\n\nCreate an inexact stopping criterion for Newton methods that combines Newton decrement and exact stopping conditions.\n\nArguments\n\nlambda_tol : tolerance for the Newton decrement (type T).\ntheta : tolerance parameter for the exact stopping criterion (type T).\n\nReturns\n\nA stopping criterion function with signature: stop(ymin, ynext, gmin, gnext, n, ndecmin, ndec) -> Bool\n\nwhere:\n\nymin : minimum objective value seen so far.\nynext : current objective value.\ngmin : minimum gradient norm seen so far.\ngnext : current gradient vector.\nn : current Newton direction.\nndecmin : square root of minimum Newton decrement seen so far.\nndec : square root of current Newton decrement (√(gᵀH⁻¹g)).\n\nAlgorithm\n\nReturns true (stop) if either condition holds:\n\nNewton decrement condition: ndec < lambda_tol\nExact stopping condition: stopping_exact(theta) is satisfied\n\nNotes\n\nThis criterion is \"inexact\" because it allows early termination based on the Newton decrement, which provides a quadratic convergence estimate. The Newton decrement λ = √(gᵀH⁻¹g) approximates the distance to the optimum in the Newton metric. Typical values: lambda_tol ∈ [1e-6, 1e-3], theta ∈ [0.1, 0.9].\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.vertex_indices-Tuple{AbstractMatrix}","page":"Home","title":"MultiGridBarrier.vertex_indices","text":"vertex_indices(A::AbstractMatrix)\n\nCreate a vector of vertex indices (1:n) for use with barrier functions. For non-MPI arrays, returns a simple Vector{Int}.\n\n\n\n\n\n","category":"method"},{"location":"#PyPlot.plot","page":"Home","title":"PyPlot.plot","text":"plot(sol::AMGBSOL, k::Int=1; kwargs...)\nplot(sol::ParabolicSOL, k::Int=1; kwargs...)\nplot(M::Geometry, z::Vector; kwargs...)\nplot(M::Geometry, ts::AbstractVector, U::Matrix; frame_time=..., embed_limit=..., printer=...)\n\nVisualize solutions and time sequences on meshes.\n\n1D problems: Line plot. For spectral methods, you can specify evaluation points with x=-1:0.01:1.\n2D FEM: Triangulated surface plot using the mesh structure.\n2D spectral: 3D surface plot. You can specify evaluation grids with x=-1:0.01:1, y=-1:0.01:1.\n\nTime sequences (animation):\n\nCall plot(M, ts, U; frame_time=1/30, printer=anim->nothing) where U has columns as frames and ts are absolute times in seconds (non-uniform allowed).\nOr simply call plot(sol) where sol is a ParabolicSOL returned by parabolic_solve (uses sol.ts).\nAnimation advances at a fixed frame rate given by frame_time (seconds per video frame). For irregular ts, each video frame shows the latest data frame with timestamp ≤ current video time.\nThe printer callback receives the Matplotlib animation object; use it to display or save (e.g., anim.save(\"out.mp4\")).\nembed_limit controls the maximum embedded HTML5 video size in megabytes.\n\nWhen sol is a solution object returned by amgb or the *_solve helpers, plot(sol,k) plots the kth component sol.z[:, k] using sol.geometry. plot(sol) uses the default k=1.\n\nAll other keyword arguments are passed to the underlying PyPlot functions.\n\n\n\n\n\n","category":"function"},{"location":"#MultiGridBarrier.Mesh3d.build_operators-Union{Tuple{T}, Tuple{Matrix{T}, MultiGridBarrier.Mesh3d.ReferenceElement{T}}} where T","page":"Home","title":"MultiGridBarrier.Mesh3d.build_operators","text":"build_operators(x::Matrix{T}, ref_el::ReferenceElement{T})\n\nBuild differential operators for the mesh x using the reference element ref_el.\n\nReturns a Dict{Symbol, SparseMatrixCSC} with keys :dx, :dy, :dz, and :id.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.Mesh3d.cube_mesh-Tuple{Int64}","page":"Home","title":"MultiGridBarrier.Mesh3d.cube_mesh","text":"cube_mesh(k::Int)\n\nGenerate a single hexahedral element (cube [-1,1]^3) with Q_k discretization. Returns the vertices x (flattened) and weights w (reference weights).\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.Mesh3d.deduplicate_vertices-Union{Tuple{Matrix{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.Mesh3d.deduplicate_vertices","text":"deduplicate_vertices(x::Matrix{T}; tol=1e-12)\n\nIdentify unique vertices in the mesh x (Nx3). Returns:\n\nunique_x: Matrix of unique vertices.\nnode_map: Vector of indices mapping original rows to unique rows.\ncounts: Multiplicity of each unique vertex.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.Mesh3d.evaluate_field-Union{Tuple{M}, Tuple{W}, Tuple{X}, Tuple{T}, Tuple{Geometry{T, X, W, M, FEM3D{T}}, Vector{T}, Vector{T}}} where {T, X, W, M}","page":"Home","title":"MultiGridBarrier.Mesh3d.evaluate_field","text":"evaluate_field(g::Geometry, u::Vector{T}, x_eval::Vector{T})\n\nEvaluate the finite element field u at point x_eval. Returns the value and a flag indicating if the point was found.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.Mesh3d.fem3d-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.Mesh3d.fem3d","text":"fem3d(::Type{T}=Float64; L::Int=2, K=nothing, k::Int=3, rest...)\n\nCreate a Geometry object for Q_k hexahedral elements with L multigrid levels.\n\nArguments\n\nT: Floating-point type (default Float64).\nL: Number of multigrid levels.\nK: Coarse Q1 mesh as an N x 3 matrix, where N is a multiple of 8 (8 vertices per hexahedron).      If nothing, defaults to a single cube [-1,1]^3.\nk: Polynomial order of elements (default 3).\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.Mesh3d.fem3d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.Mesh3d.fem3d_solve","text":"fem3d_solve(::Type{T}=Float64; rest...) where {T}\n\nSolve a 3D PDE using the Spectral Barrier Method.\n\nArguments\n\nT: Floating-point type for computations (default Float64).\nrest...: Keyword arguments passed to fem3d (e.g., L, k) and amgb (e.g., D, f, g, maxiter, verbose).\n\nReturns\n\nAn AMGBSOL object containing the solution field z and convergence history.\n\nSee amgb for the full list of keyword arguments and their defaults.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.Mesh3d.get_boundary_nodes-Union{Tuple{T}, Tuple{Matrix{T}, Int64}} where T","page":"Home","title":"MultiGridBarrier.Mesh3d.get_boundary_nodes","text":"get_boundary_nodes(x::Matrix{T}, k::Int; tol=1e-12)\n\nIdentify indices of unique nodes that lie on the boundary of the domain. Returns:\n\nboundary_indices: Vector of indices into unique_x (from deduplicate_vertices).\nunique_x: The unique vertices.\nnode_map: Map from broken to unique.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.Mesh3d.interpolate_element-Tuple{Any, Any, Any}","page":"Home","title":"MultiGridBarrier.Mesh3d.interpolate_element","text":"interpolate_element(parent_nodes, parent_x, child_xi)\n\nInterpolate position in a parent element defined by parent_nodes (reference) and parent_x (physical) at reference coordinates child_xi. Assumes tensor product structure.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.Mesh3d.inverse_map_element-Tuple{Any, Any, Any}","page":"Home","title":"MultiGridBarrier.Mesh3d.inverse_map_element","text":"inverse_map_element(nodes_1d, x_elem, x_target; tol=1e-10, max_iter=20)\n\nFind reference coordinates xi such that the mapping of x_elem at xi equals x_target. Uses Newton-Raphson method. Returns (xi, success).\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.Mesh3d.promote_to_Qk-Union{Tuple{T}, Tuple{Matrix{T}, Int64}} where T","page":"Home","title":"MultiGridBarrier.Mesh3d.promote_to_Qk","text":"promote_to_Qk(K_q1::Matrix{T}, k::Int)\n\nPromote a Q1 mesh K_q1 (N x 3, where N is a multiple of 8) to a Qk mesh. Each group of 8 rows in `Kq1` represents one linear hexahedron. Returns a new mesh (M x 3) where each element is replaced by (k+1)^3 nodes located at the mapped Chebyshev-Lobatto points.\n\n\n\n\n\n","category":"method"}]
}
