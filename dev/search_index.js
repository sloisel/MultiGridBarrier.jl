var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"using Markdown\nusing Pkg\nusing MultiGridBarrier\nv = string(pkgversion(MultiGridBarrier))\nmd\"# MultiGridBarrier $v\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"MultiGridBarrier is a Julia module for solving nonlinear convex optimization problems in function spaces, such as p-Laplace problems. When regularity conditions are satisfied, the solvers are quasi-optimal.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The MultiGridBarrier module features finite element and spectral discretizations in 1d and 2d.","category":"page"},{"location":"#Finite-elements","page":"Home","title":"Finite elements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"After installing MultiGridBarrier with the Julia package manager, in a Jupyter notebook, one solves a 1d p-Laplace problem as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using PyPlot # hide\nusing MultiGridBarrier\nfem1d_solve(L=5,p=1.0,verbose=false);\nsavefig(\"fem1d.svg\"); nothing # hide\nclose() #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"A 2d p-Laplace problem:","category":"page"},{"location":"","page":"Home","title":"Home","text":"fem2d_solve(L=3,p=1.0,verbose=false);\nsavefig(\"fem2d.svg\"); nothing # hide\nclose() #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#Spectral-elements","page":"Home","title":"Spectral elements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Solve a 1d p-Laplace problem using spectral methods as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"spectral1d_solve(n=40,p=1.0,verbose=false);\nsavefig(\"spectral1d.svg\"); nothing # hide\nclose() #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"A 2d p-Laplace problem:","category":"page"},{"location":"","page":"Home","title":"Home","text":"spectral2d_solve(n=5,p=1.5,verbose=false);\nsavefig(\"spectral2d.svg\"); nothing # hide\nclose() #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#Solving-\\infty-Laplacians","page":"Home","title":"Solving infty-Laplacians","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For p geq 1 and domain Omega, the solution u of the p-Laplace problem is the minimizer of J(u) = nabla u_L^p(Omega)^p + int_Omega fu where u is in a suitable space of function satisfying, e.g. Dirichlet conditions, and f is a forcing. This definition must be modified for the infty-Laplace problem. Here we show how to minimize: J(u) = nabla u_L^infty(Omega)^p + int_Omega fu We put p=1 for simplicity.","category":"page"},{"location":"","page":"Home","title":"Home","text":"fem1d_solve(L=5,p=1.0,state_variables=[:u :dirichlet; :s :uniform],verbose=false);\nsavefig(\"fem1dinfty.svg\"); nothing # hide\nclose() #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#Parabolic-problems","page":"Home","title":"Parabolic problems","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A time-dependent problem:","category":"page"},{"location":"","page":"Home","title":"Home","text":"parabolic_solve(h=0.1,L=3,printer=anim->anim.save(\"parabolic.mp4\"),verbose=false);\nclose() #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"<video src=\"parabolic.mp4\" width=\"600\" controls autoplay loop></video>","category":"page"},{"location":"#Module-reference","page":"Home","title":"Module reference","text":"","category":"section"},{"location":"#MultiGridBarrier.MultiGridBarrier","page":"Home","title":"MultiGridBarrier.MultiGridBarrier","text":"module MultiGridBarrier\n\nModule MultiGridBarrier solves convex optimization problems in function spaces, for example, solving p-Laplace problems. We recommend to start with the functions fem1d_solve(), fem2d_solve(), spectral1d_solve(), spectral2d_solve(). These functions are sufficient to solve p-Laplace problems in 1d or 2d, using finite or spectral elements.\n\nFor more general use, the user will need to familiarize themselves with the basic ideas of convex optimization.\n\nOverview of convex optimization in function spaces by MultiGrid Barrier method.\n\nThe general idea is to build a multigrid hierarchy, represented by an AMG object, and barrier for a convex set, represented by a Barrier object, and then solve a convex optimization problem using the amgb() solver.\n\nTo generate the multigrid hierarchy represented by the AMG object, use either fem1d(), fem2d(), spectral1d() or spectral2d() functions. These constructors will assemble suitable AMG objects for either FEM or spectral discretizations, in 1d or 2d. One should think of these four constructors as being specialized in constructing some specific function spaces. A user can use the amg() constructor directly if custom function spaces are required, but this is more difficult.\n\nWe now describe the barrier function.\n\nAssume that Omega subset mathbbR^d is some open set. Consider the example of the p-Laplace problem on Omega. Let f(x) be a \"forcing\" (a function) on Omega, and 1 leq p  infty. One wishes to solve the minimization problem\n\nbeginequation\ninf_u int_Omega fu + nabla u_2^p  dx tag1\nendequation\n\nGenerally speaking, u will range in some function space, e.g. a space of differentiable functions satisfying homogeneous Dirichlet conditions. Under some conditions, minimizing (1) is equivalent to solving the p-Laplace PDE:\n\nnabla cdot (nabla u_2^p-2nabla u) = 1 over p f\n\nWe introduce the \"slack function\" s(x) and replace (1) with the following equivalent problem:\n\nbeginequation\ninf_s(x) geq nabla u(x)_2^p int_Omega fu + s  dx tag2\nendequation\n\nDefine the convex set mathcalQ =  (u(x)q(x)s(x))    s(x) geq q(x)_2^p , and\n\nz = beginbmatrix u  s endbmatrix qquad\nc^T = f01 qquad\nDz = beginbmatrix u  nabla u  s endbmatrix\n\nThen, (2) can be rewritten as\n\nbeginequation\ninf_Dz in mathcalQ int_Omega c^T(x)Dz(x)  dx tag3\nendequation\n\nRecall that a barrier for mathcalQ is a convex function mathcalF on mathcalQ such that mathcalF  infty in the interior of mathcalQ and mathcalF = infty on the boundary of mathcalQ. A barrier for the p-Laplace problem is:\n\nmathcalF(uqs) = int_Omega -log(s^2 over p - q_2^2) - 2log s  dx = int_Omega F(Dz(x))  dx\n\nThe central path z^*(t) minimizes, for each fixed t0, the quantity\n\nint_Omega tc^TDz + F(Dz)  dx\n\nAs t to infty, z^*(t) forms a minimizing sequence (or filter) for (3). We think of the function c(x) as the \"functional\" that we seek to minimize.\n\nThe Convex{T} type describes various convex sets (denoted Q above) by way of functions barrier(), cobarrier() and slack(). barrier is indeed a barrier for Q, cobarrier() is a barrier for a related feasibility problems, and slack() is used in solving the feasibility problem. Convex{T} objects can be created using the various convex_...() constructors, e.g. convex_Euclidian_power() for the p-Laplace problem.\n\nOnce one has AMG and Convex objects, and a suitable \"functional\" c, one uses the amgb() function to solve the optimization problem by the MultiGrid Barrier method, a variant of the barrier method (or interior point method) that is quasi-optimal for sufficiently regular problems.\n\n\n\n\n\n","category":"module"},{"location":"#Types-reference","page":"Home","title":"Types reference","text":"","category":"section"},{"location":"#MultiGridBarrier.AMG","page":"Home","title":"MultiGridBarrier.AMG","text":"@kwdef struct AMG{T,M,Geometry}\n    ...\nend\n\nObjects of this type should probably be assembled by the constructor amg().\n\nA multigrid with L levels. Denote by l between 1 and L, a grid level. Fields are:\n\nx::Matrix{T} the vertices of the fine grid.\nw::Vector{T} corresponding quadrature weights.\nR_fine::Array{M,1} an array of L matrices. The columns of R_fine[l] are basis functions for the function space on grid level l, interpolated to the fine grid.\nR_coarse::Array{M,1} an array of L matrices. The columns of R_coarse[l] are basis functions for the function space on grid level l. Unlike R_fine[l], these basis functions are on grid level l, not interpolated to the fine grid.\nD::Array{M,2} an array of differential operators. For example, if the barrier parameters are to be u,ux,s, with ux the derivative of u, then D[l,:] = [I,Dx,I], where Dx is a numerical differentiation operator on grid level l.  \nrefine_u::Array{M,1} an array of L grid refinement matrices. If x[l] has n[l] vertices, then refine_u[l] is n[l+1] by n[l].\ncoarsen_u::Array{M,1} an array of L grid coarsening matrices. coarsen_u[l] is n[l] by n[l+1].\nrefine_z::Array{M,1} an array of L grid refining matrices for the \"state vector\" z. For example, if z contains the state functions u and s, then there are k=2 state functions, and refine_z[l] is k*n[l+1] by k*n[l].\ncoarsen_z::Array{M,1} an array of L grid coarsening matrices for the \"state vector\" z. coarsen_z[l] is k*n[l] by k*n[l+1].\n\nThese various matrices must satisfy a wide variety of algebraic relations. For this reason, it is recommended to use the constructor amg().\n\n\n\n\n\n","category":"type"},{"location":"#MultiGridBarrier.Barrier","page":"Home","title":"MultiGridBarrier.Barrier","text":"Barrier\n\nA type for holding barrier functions. Fields are:\n\nf0::Function\nf1::Function\nf2::Function\n\nf0 is the barrier function itself, while f1 is its gradient and f2 is the Hessian.\n\n\n\n\n\n","category":"type"},{"location":"#MultiGridBarrier.Convex","page":"Home","title":"MultiGridBarrier.Convex","text":"struct Convex\n    barrier::Function\n    cobarrier::Function\n    slack::Function\nend\n\nThe Convex data structure represents a convex domain Q implicitly by way of three functions. The barrier function is a barrier for Q. cobarrier is a barrier for the feasibility subproblem, and slack is a function that initializes a valid slack value for the feasibility subproblem. The various convex_ functions can be used to generate various convex domains.\n\nThese functions are called as follows: barrier(x,y). x is a vertex in a grid, as per the AMG object. y is some vector. For each fixed x variable, y -> barrier(x,y) defines a barrier for a convex set in y.\n\n\n\n\n\n","category":"type"},{"location":"#MultiGridBarrier.FEM1D","page":"Home","title":"MultiGridBarrier.FEM1D","text":"abstract type FEM1D end\n\n\n\n\n\n","category":"type"},{"location":"#MultiGridBarrier.FEM2D","page":"Home","title":"MultiGridBarrier.FEM2D","text":"abstract type FEM2D end\n\n\n\n\n\n","category":"type"},{"location":"#MultiGridBarrier.SPECTRAL1D","page":"Home","title":"MultiGridBarrier.SPECTRAL1D","text":"abstract type SPECTRAL1D end\n\n\n\n\n\n","category":"type"},{"location":"#MultiGridBarrier.SPECTRAL2D","page":"Home","title":"MultiGridBarrier.SPECTRAL2D","text":"abstract type SPECTRAL2D end\n\n\n\n\n\n","category":"type"},{"location":"#Functions-reference","page":"Home","title":"Functions reference","text":"","category":"section"},{"location":"#MultiGridBarrier.amg-Union{Tuple{Type{Geometry}}, Tuple{Geometry}, Tuple{M}, Tuple{T}} where {T, M, Geometry}","page":"Home","title":"MultiGridBarrier.amg","text":"function amg(::Type{Geometry};\n    x::Matrix{T},\n    w::Vector{T},\n    state_variables::Matrix{Symbol},\n    D::Matrix{Symbol},\n    subspaces::Dict{Symbol,Vector{M}},\n    operators::Dict{Symbol,M},\n    refine::Vector{M},\n    coarsen::Vector{M},\n    full_space=:full,\n    id_operator=:id,\n    feasibility_slack=:feasibility_slack,\n    generate_feasibility=true) where {T,M,Geometry}\n\nConstruct an AMG object for use with the amgb solver. In many cases, this constructor is not called directly by the user. For 1d and 2d finite elements, use the fem1d() or fem2d(). For 1d and 2d spectral elements, use  spectral1d() or spectral2d(). You use amg() directly if you are implementing your own function spaces.\n\nThe AMG object shall represent all L grid levels of the multigrid hierarchy. Parameters are:\n\nx: the vertices of the fine grid.\nw: the quadrature weights for the fine grid.\nstate_variables: a matrix of symbols. The first column indicates the names of the state vectors or functions, and the second column indicates the names of the corresponding subspaces. A typical example is: state_variables = [:u :dirichlet; :s :full]. This would define the solution as being functions named u(x) and s(x). The u function would lie in the space :dirichlet, presumably consisting of functions with homogeneous Dirichlet conditions. The s function would lie in the space :full, presumably being the full function space, without boundary conditions.\nD: a matrix of symbols. The first column indicates the names of various state variables, and the second column indicates the corresponding differentiation operator(s). For example: D = [:u :id ; :u :dx ; :s :id]. This would indicate that the barrier should be called as F(x,y) with y = [u,ux,s], where ux denotes the derivative of u with respect to the space variable x.\nsubspaces: a Dict mapping each subspace symbol to an array of L matrices, e.g. for each l, subspaces[:dirichlet][l] is a matrix whose columns span the homogeneous Dirichlet subspace of grid level l.\noperators: a Dict mapping each differential operator symbol to a matrix, e.g. operators[:id] is an identity matrix, while operators[:dx] is a numerical differentiation matrix, on the fine grid level L.\nrefine: an array of length L of matrices. For each l, refine[l] interpolates from grid level l to grid level l+1. refine[L] should be the identity, and coarsen[l]*refine[l] should be the identity.\ncoarsen: an array of length L of matrices. For each l, coarsen[l] interpolates or projects from grid level l+1 to grid level l. coarsen[L] should be the identity.\ngenerate_feasibility: if true, amg() returns a pair M of AMG objects. M[1] is an AMG object to be used for the main optimization problem, while M[2] is an AMG object for the preliminary feasibility sub problem. In this case, amg() also needs to be provided with the following additional information: feasibility_slack is the name of a special slack variable that must be unique to the feasibility subproblem (default: :feasibility_slack); full_space is the name of the \"full\" vector space (i.e. no boundary conditions, default: :full); and id_operator is the name of the identity operator (default: :id).\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.amg_construct-Union{Tuple{T}, Tuple{Type{T}, Type{FEM1D}}} where T","page":"Home","title":"MultiGridBarrier.amg_construct","text":"amg_construct(::Type{T},::Type{FEM1D};rest...) where {T} = fem1d(T;rest...)\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.amg_construct-Union{Tuple{T}, Tuple{Type{T}, Type{FEM2D}}} where T","page":"Home","title":"MultiGridBarrier.amg_construct","text":"amg_construct(::Type{T},::Type{FEM2D};rest...) where {T} = fem2d(T;rest...)\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.amg_construct-Union{Tuple{T}, Tuple{Type{T}, Type{SPECTRAL1D}}} where T","page":"Home","title":"MultiGridBarrier.amg_construct","text":"amg_construct(::Type{T},::Type{SPECTRAL1D};rest...) where {T} = spectral1d(T;rest...)\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.amg_construct-Union{Tuple{T}, Tuple{Type{T}, Type{SPECTRAL2D}}} where T","page":"Home","title":"MultiGridBarrier.amg_construct","text":"amg_construct(::Type{T},::Type{SPECTRAL2D},L,n,K) where {T} = spectral2d(T,n=n,L=L)\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.amg_dim-Tuple{Type{FEM1D}}","page":"Home","title":"MultiGridBarrier.amg_dim","text":"amg_dim(::Type{FEM1D}) = 1\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.amg_dim-Tuple{Type{FEM2D}}","page":"Home","title":"MultiGridBarrier.amg_dim","text":"amg_dim(::Type{FEM2D}) = 2\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.amg_dim-Tuple{Type{SPECTRAL1D}}","page":"Home","title":"MultiGridBarrier.amg_dim","text":"amg_dim(::Type{SPECTRAL1D}) = 1\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.amg_dim-Tuple{Type{SPECTRAL2D}}","page":"Home","title":"MultiGridBarrier.amg_dim","text":"amg_dim(::Type{SPECTRAL2D}) = 2\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.amg_plot-Union{Tuple{Mat}, Tuple{T}, Tuple{AMG{T, Mat, FEM1D}, Vector{T}}} where {T, Mat}","page":"Home","title":"MultiGridBarrier.amg_plot","text":"amg_plot(M::AMG{T,Mat,FEM1D}, z::Vector{T}) where {T,Mat} = plot(M.x[end],z)\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.amg_plot-Union{Tuple{Mat}, Tuple{T}, Tuple{AMG{T, Mat, FEM2D}, Array{T}}} where {T, Mat}","page":"Home","title":"MultiGridBarrier.amg_plot","text":"function amg_plot(M::AMG{T, Mat,FEM2D}, z::Vector{T}) where {T,Mat}\n\nPlot a piecewise quadratic (plus cubic \"bubble\") solution z on the given mesh. Note that the solution is drawn as (linear) triangles, even though the underlying solution is piecewise cubic. To obtain a more accurate depiction, especially when the mesh is coarse, it would be preferable to apply a few levels of additional subdivision, so as to capture the curve of the quadratic basis functions.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.amg_plot-Union{Tuple{Mat}, Tuple{T}, Tuple{AMG{T, Mat, SPECTRAL1D}, Any}} where {T, Mat}","page":"Home","title":"MultiGridBarrier.amg_plot","text":"function amg_plot(M::AMG{T,Mat,SPECTRAL1D},y;x=Array(-1:T(0.01):1),rest...) where {T,Mat}\n\nPlot a solution using pyplot.\n\nM: a mesh.\nx: x values where the solution should be evaluated and plotted.\ny: the solution, to be interpolated at the given x values via spectral1d_interp.\nrest... parameters are passed directly to pyplot.plot.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.amg_plot-Union{Tuple{Mat}, Tuple{T}, Tuple{AMG{T, Mat, SPECTRAL2D}, Vector{T}}} where {T, Mat}","page":"Home","title":"MultiGridBarrier.amg_plot","text":"function amg_plot(M::AMG{T,Mat,SPECTRAL2D},z::Vector{T};x=-1:T(0.01):1,y=-1:T(0.01):1,rest...) where {T,Mat}\n\nPlot a 2d solution.\n\nM a 2d mesh.\nx, y should be ranges like -1:0.01:1.\nz the solution to plot.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.amg_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.amg_solve","text":"amg_solve(::Type{T}=Float64;\n          L::Integer=2,\n          n=nothing,\n          method=FEM1D,\n          K=nothing,\n          state_variables::Matrix{Symbol} = [:u :dirichlet;\n                                             :s :full],\n          dim::Integer = amg_dim(method),\n          D::Matrix{Symbol} = default_D[dim],\n          M = amg_construct(T, method;\n                            L=L, n=n, K=K,\n                            state_variables=state_variables, D=D),\n          p::T = T(1.0),\n          g::Union{Function, Matrix{T}} = default_g(T)[dim],\n          f::Union{Function, Matrix{T}} = default_f(T)[dim],\n          Q::Convex{T} = convex_Euclidian_power(T, idx=2:dim+2, p=x->p),\n          show=true,\n          return_details=false,\n          rest...) where {T}\n\nConvenience interface to the MultiGridBarrier module.   This function builds a discretization and calls amgb with the appropriate defaults.   For a quick start on p-Laplace problems, simply call:\n\namg_solve()\n\nKeyword arguments\n\nL=2 : number of times to subdivide the base mesh.\nn : number of quadrature nodes along each axis (only for spectral methods). If set, L is ignored.\nmethod=FEM1D : discretization method. One of FEM1D, FEM2D, SPECTRAL1D, SPECTRAL2D.\nK : initial mesh (only relevant for FEM2D).\nstate_variables : symbolic description of solution components (default [:u :dirichlet; :s :full]).\ndim : problem dimension (1 or 2). Used only to determine defaults for f, g, Q, and D.\nD : differential operators (default depends on dim).\nM : AMG hierarchy, constructed automatically unless supplied explicitly.\np=1.0 : parameter for the p-Laplace operator (used only if Q is not overridden).\ng : boundary conditions. Either a function (evaluated at mesh points) or a matrix. Defaults depend on dim.\nf : forcing / cost functional. Either a function (evaluated at mesh points) or a matrix. Defaults depend on dim.\nQ : convex domain for the variational problem. Defaults to convex_Euclidian_power, matching p-Laplace problems.\nshow=true : if true, plot the computed solution.\nreturn_details=false :\nif false, return the solution z as a matrix.\nif true, return the detailed named tuple from amgb.\nrest... : any further keyword arguments are forwarded to amgb.\n\nDefaults\n\nThe defaults for f, g, and D depend on the spatial dimension:\n\ndim 1 2\nf (x)->T[0.5,0.0,1.0] (x)->T[0.5,0.0,0.0,1.0]\ng (x)->T[x[1],2] (x)->T[x[1]^2+x[2]^2,100.0]\nD [:u :id [:u :id\n :u :dx :u :dx\n :s :id] :u :dy\n  :s :id]\n\nReturns\n\nIf return_details=false (default): the solution z (matrix).\nIf return_details=true: the full solution object from amgb, which includes fields like z, SOL_feasibility, and SOL_main.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.amgb-Union{Tuple{Geometry}, Tuple{Mat}, Tuple{T}, Tuple{Tuple{AMG{T, Mat, Geometry}, AMG{T, Mat, Geometry}}, Union{Matrix{T}, Function}, Union{Matrix{T}, Function}, Convex}} where {T, Mat, Geometry}","page":"Home","title":"MultiGridBarrier.amgb","text":"amgb(M::Tuple{AMG{T,Mat,Geometry}, AMG{T,Mat,Geometry}},\n     f::Union{Function, Matrix{T}},\n     g::Union{Function, Matrix{T}},\n     Q::Convex;\n     x::Matrix{T}=M[1].x,\n     t=T(0.1),\n     t_feasibility=t,\n     verbose=true,\n     return_details=false,\n     stopping_criterion,\n     line_search,\n     finalize,\n     logfile=devnull,\n     rest...) where {T,Mat,Geometry}\n\nAlgebraic MultiGrid Barrier (AMGB) driver.\n\nHigh-level wrapper around amgb_core that:\n\nBuilds the initial guess z0 and cost functional c0 from g and f.\nSolves a feasibility subproblem on M[2] if needed.\nSolves the main optimization problem on M[1].\nOptionally reports progress and logs diagnostics.\n\nArguments\n\nM: a tuple (M_main, M_feas) of AMG hierarchies.\nM[1] encodes the main problem.\nM[2] encodes the feasibility subproblem.\nf: objective functional to minimize. May be a function (evaluated at rows of x) or a precomputed matrix.\ng: boundary/initial data. May be a function (evaluated at rows of x) or a precomputed matrix.\nQ: convex domain describing admissible states.\n\nKeyword arguments\n\nx: mesh/sample points where f and g are evaluated when they are functions (default: M[1].x).\nt: initial barrier parameter for the main solve.\nt_feasibility: initial barrier parameter for the feasibility solve.\nverbose: show a progress bar if true.\nreturn_details: if true, return detailed results from both solves.\nstopping_criterion: stopping criterion for the Newton solver (has a default based on mesh parameters).\nline_search: line search strategy (default: linesearch_backtracking).\nfinalize: finalization stopping criterion (default: stopping_exact(T(0.1))).\nlogfile: IO stream for logging (default: devnull).\nrest...: additional keyword arguments forwarded to amgb_core (e.g., tolerances, other options).\n\nInitialization\n\nIf f/g are functions, c0 and z0 are built by evaluating on each row of x:\n\nm = size(M[1].x, 1)\nfor k in 1:m\n    z0[k, :] .= g(x[k, :])\n    c0[k, :] .= f(x[k, :])\nend\n\nIf f/g are matrices, they are used directly (their shapes must match the discretization implied by M[1]).\n\nFeasibility handling\n\nThe routine checks barrier admissibility. If any point is infeasible under Q, a feasibility problem is automatically constructed and solved on M[2] (using an internal slack augmentation and an early-stop criterion). If feasibility is already satisfied, this step is skipped.\n\nReturns\n\nIf return_details == false (default):\n\nreturns z, an m × n matrix, where m = size(x,1) and n is the number of state variables in the discretization.\n\nIf return_details == true:\n\nreturns a named tuple (z, SOL_feasibility, SOL_main,log) where SOL_feasibility is nothing if no feasibility step was needed. The SOL_* objects are the detailed results returned by amgb_core. log is a string log of the iterations, useful for debugging purposes.\n\nErrors\n\nThrows AMGBConvergenceFailure if either the feasibility or main solve fails to converge.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.amgb_core-Union{Tuple{Geometry}, Tuple{Mat}, Tuple{T}, Tuple{Barrier, AMG{T, Mat, Geometry}, Matrix{T}, Vector{T}, Matrix{T}}} where {T, Mat, Geometry}","page":"Home","title":"MultiGridBarrier.amgb_core","text":"amgb_core(B::Barrier,\n          M::AMG{T,Mat,Geometry},\n          x::Matrix{T},\n          z::Array{T,1},\n          c::Array{T,2};\n          tol,\n          t,\n          maxit,\n          kappa,\n          early_stop,\n          progress,\n          c0,\n          max_newton,\n          finalize,\n          printlog,\n          args...) where {T,Mat,Geometry}\n\nAlgebraic MultiGrid Barrier (AMGB) method.\n\nArguments\n\nB : a Barrier object.\nM : an AMG hierarchy.\nx : a matrix with the same number of rows as M.x. Typically x = M.x.\nz : initial iterate, which must be admissible (B.f0(z) < ∞).\nc : objective functional to minimize. Concretely, the method minimizes the integral of c .* (D*z) (with D the differential operator in M), subject to barrier feasibility.\n\nKeyword arguments\n\ntol : stopping tolerance; the method stops once 1/t < tol.\nt : initial barrier parameter.\nmaxit : maximum number of barrier iterations.\nkappa : initial step size multiplier for t. Adapted dynamically but never exceeds this initial value.\nearly_stop : function z -> Bool; if true, the iteration halts early (e.g. in feasibility mode).\nprogress : callback receiving a scalar in [0,1] for reporting progress (default: no-op).\nc0 : base offset added to the objective (c0 + t*c).\nmax_newton : maximum Newton iterations per inner solve (default depends on problem data).\nfinalize : finalization stopping criterion for the last Newton solve.\nprintlog : logging function.\nargs... : extra keyword arguments passed to inner routines (amgb_phase1, amgb_step).\n\nReturns\n\nA named tuple SOL with fields:\n\nz : the computed solution.\nz_unfinalized: the solution before finalization.\nc : the input functional.\nits : iteration counts across levels and barrier steps.\nts : sequence of barrier parameters t.\nkappas : step size multipliers used.\ntimes : wall-clock timestamps of iterations.\nM : the AMG hierarchy.\nt_begin, t_end, t_elapsed : timing information.\npassed : whether phase 1 succeeded.\nc_dot_Dz : recorded values of ⟨c, D*z⟩ at each iteration.\n\nThrows AMGBConvergenceFailure if convergence is not achieved.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.apply_D-Union{Tuple{T}, Tuple{Any, Vector{T}}} where T","page":"Home","title":"MultiGridBarrier.apply_D","text":"apply_D(D,z) = hcat([D[k]*z for k in 1:length(D)]...)\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.barrier-Tuple{Any}","page":"Home","title":"MultiGridBarrier.barrier","text":"function barrier(F;\n    F1=(x,y)->ForwardDiff.gradient(z->F(x,z),y),\n    F2=(x,y)->ForwardDiff.hessian(z->F(x,z),y))\n\nConstructor for barriers.\n\nF is the actual barrier function. It should take parameters (x,y).\nF1 is the gradient of F with respect to y.\nF2 is the Hessian of F with  respect to y.\n\nBy default, F1 and F2 are automatically generated by the module ForwardDiff.\n\nA more specific description of the Barrier object is as follows. The function Barrier.f0 has parameters:\n\nfunction Barrier.f0(z,x,w,c,R,D,z0)\n\nHere, R is a matrix and D is an array of matrices; x is a matrix of quadrature nodes with weights w, and c is a matrix describing the functional we seek to minimize. The value of Barrier.f0 is given by:\n\n        p = length(w)\n        n = length(D)\n        Rz = z0+R*z\n        Dz = hcat([D[k]*Rz for k=1:n]...)\n        y = [F(x[k,:],Dz[k,:]) for k=1:p]\n        dot(w,y)+sum([dot(w.*c[:,k],Dz[:,k]) for k=1:n])\n\nThus, Barrier.f0 can be regarded as a quadrature approximation of the integral\n\nint_Omega left(sum_k=1^nc_k(x)v_k(x)right) + F(xv_1(x)ldotsv_n(x))  dx text where  v_k = D_k(z_0 + Rz)\n\nFunctions Barrier.f1 and Barrier.f2 are the gradient and Hessian, respectively, of Barrier.f0, with respect to the z parameter. If the underlying matrices are sparse, then sparse arithmetic is used for Barrier.f2.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.convex_Euclidian_power-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.convex_Euclidian_power","text":"function convex_Euclidian_power(::Type{T}=Float64;idx=Colon(),A::Function=(x)->I,b::Function=(x)->T(0),p::Function=x->T(2)) where {T}\n\nGenerate a Convex object corresponding to the convex set defined by zend geq z1end-1_2^p where z = A(x)*yidx + b(x).\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.convex_linear-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.convex_linear","text":"function convex_linear(::Type{T}=Float64;idx=Colon(),A::Function=(x)->I,b::Function=(x)->T(0)) where {T}\n\nGenerate a Convex structure corresponding to the convex domain A(x,k)*y[idx] .+ b(x,k) ≤ 0.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.fem1d-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.fem1d","text":"function fem1d(::Type{T}=Float64; L::Int=4, n=nothing, K=nothing,                     statevariables = [:u :dirichlet                                        :s :full],                     D = [:u :id                          :u :dx                          :s :id],                     generatefeasibility=true) where {T}\n\nConstruct an AMG object for a 1d piecewise linear finite element grid. The interval is [-1,1]. Parameters are:\n\nL: divide the interval into 2^L subintervals (L for Levels).\nstate_variables: the \"state vector\" consists of functions, by default this is u(x) and s(x), on the finite element grid.\nD: the set of differential operators. The barrier function F will eventually be called with the parameters F(x,Dz), where z is the state vector. By default, this results in F(x,u,ux,s), where ux is the derivative of u.\ngenerate_feasibility: if true, returns a pair M of AMG objects. M[1] is the AMG object for the main problem, and M[2] is for the feasibility subproblem.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.fem1d_interp-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, T}} where T","page":"Home","title":"MultiGridBarrier.fem1d_interp","text":"function fem1d_interp(x::Vector{T},\n                  y::Vector{T},\n                  t::T) where{T}\n\nInterpolate a 1d piecewise linear function at the given t value. If u(xi) is the piecewise linear function such that u(x[k])=y[k] then this function returns u(t).\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.fem1d_interp-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector{T}}} where T","page":"Home","title":"MultiGridBarrier.fem1d_interp","text":"function fem1d_interp(x::Vector{T},\n                  y::Vector{T},\n                  t::Vector{T}) where{T}\n\nReturns [fem1d_interp(x,y,t[k]) for k=1:length(t)].\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.fem1d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.fem1d_solve","text":"fem1d_solve(::Type{T}=Float64;rest...) where {T} = amg_solve(T;method=FEM1D,rest...)\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.fem2d-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.fem2d","text":"function fem2d(::Type{T}, L::Int, K::Matrix{T};\n                state_variables = [:u :dirichlet\n                                   :s :full],\n                D = [:u :id\n                     :u :dx\n                     :u :dy\n                     :s :id],\n                generate_feasibility=true) where {T}\n\nConstruct an AMG object for a 2d finite element grid on the domain K with piecewise quadratic elements. Parameters are:\n\nK: a triangular mesh. If there are n triangles, then K should be a 3n by 2 matrix of vertices. The first column of K represents x coordinates, the second column represents y coordinates.\nL: number of refinement levels (L for Levels).\nstate_variables: the \"state vector\" consists of functions, by default this is u(x) and s(x), on the finite element grid.\nD: the set of differential operators. The barrier function F will eventually be called with the parameters F(x,y,Dz), where z is the state vector. By default, this results in F(x,y,u,ux,uy,s), where (ux,uy) is the gradient of u.\ngenerate_feasibility: if true, returns a pair M of AMG objects. M[1] is the AMG object for the main problem, and M[2] is for the feasibility subproblem.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.fem2d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.fem2d_solve","text":"fem2d_solve(::Type{T}=Float64;rest...) where {T} = amg_solve(T;method=FEM2D,rest...)\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.illinois-Union{Tuple{T}, Tuple{Any, T, T}} where T","page":"Home","title":"MultiGridBarrier.illinois","text":"function illinois(f,a::T,b::T;fa=f(a),fb=f(b),maxit=10000) where {T}\n\nFind a root of f between a and b using the Illinois algorithm. If f(a)*f(b)>=0, returns b.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.newton-Union{Tuple{Mat}, Tuple{T}, Tuple{Type{Mat}, Function, Function, Function, Vector{T}}} where {T, Mat}","page":"Home","title":"MultiGridBarrier.newton","text":"newton(::Type{Mat},\n       F0::Function,\n       F1::Function,\n       F2::Function,\n       x::Array{T,1};\n       maxit=10000,\n       stopping_criterion=stopping_exact(T(0.1)),\n       line_search=linesearch_illinois,\n       printlog) where {T,Mat}\n\nDamped Newton iteration for unconstrained minimization of a differentiable function.\n\nArguments\n\nF0 : objective function.\nF1 : gradient of F0.\nF2 : Hessian of F0 (must return a matrix of type Mat).\nx  : starting point (vector of type T).\n\nKeyword arguments\n\nmaxit : maximum number of iterations (default: 10,000).\nstopping_criterion : user-defined predicate deciding when to stop. The default is stopping_exact(T(0.1)) which checks whether the objective decreased and the gradient norm fell sufficiently.\nline_search : line search strategy (default: linesearch_illinois). The alternative is linesearch_backtracking.\nprintlog : logging function.\n\nNotes\n\nThe iteration stops if the stopping_criterion is satisfied or if maxit iterations are exceeded.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.parabolic_plot-Union{Tuple{Geometry}, Tuple{Mat}, Tuple{T}, Tuple{Any, AMG{T, Mat, Geometry}, Matrix{T}}} where {T, Mat, Geometry}","page":"Home","title":"MultiGridBarrier.parabolic_plot","text":"function parabolic_plot(method,M::AMG{T, Mat,Geometry}, U::Matrix{T}; \n    interval=200, embed_limit=200.0,\n    printer=(animation)->display(\"text/html\", animation.to_html5_video(embed_limit=embed_limit))) where {T,Mat,Geometry}\n\nAnimate the solution of the parabolic problem.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.parabolic_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.parabolic_solve","text":"function parabolic_solve(::Type{T}=Float64;\n    method = FEM2D,\n    state_variables = [:u  :dirichlet\n                       :s1 :full\n                       :s2 :full],\n    dim = amg_dim(method),\n    f1 = x->T(0.5),\n    f_default = default_f_parabolic[dim],\n    p = T(1),\n    h = T(0.2),\n    f = (t,x)->f_default(h*f1(x)-x[1+dim],T(0.5),h/p),\n    g = default_g_parabolic[dim],\n    D = default_D_parabolic[dim],\n    L = 2,\n    t0 = T(0),\n    t1 = T(1),\n    M = amg_construct(T,method,L=L,D=D,state_variables=state_variables),\n    Q = (convex_Euclidian_power(;idx=[1,2+dim],p=x->T(2)) \n        ∩ convex_Euclidian_power(;idx=vcat(2:1+dim,3+dim),p=x->p)),\n    verbose = true,\n    show = true,\n    interval = 200,\n    printer=(animation)->display(\"text/html\", animation.to_html5_video(embed_limit=200.0)),\n    rest...) where {T}\n\nSolves a parabolic (i.e. time-dependent) p-Laplace problem of the form:\n\nu_t - nabla cdot (nabla u_2^p-2nabla u) = -f_1\n\nWe use the implicit Euler scheme u_t approx (u_k+1-u_k)h to arrive at:\n\nu_k+1 - hnabla cdot (nabla u_k+1_2^p-2nabla u_k+1) = u_k-hf_1\n\nAccording to the calculus of variation, we look for a weak solution minimizing\n\nJ(u) = int_Omega1 over 2 u^2 + h 1 over p nabla u_2^p + (hf_1-u_k)u  dx\n\nWe introduce the slack functions s_1 geq u^2 and s_2 geq nabla u_2^p and minimize instead\n\nint_Omega 1 over 2s_1 + h over p s_2 + (hf_1-u_k)u  dx\n\nThe canonical form is:\n\nz = beginbmatrix u  s_1  s_2 endbmatrix\nqquad\nf^T = lefthf_1-u_k001 over 2h over pright\nqquad\nDz = beginbmatrix u  u_x  u_y  s_1  s_2 endbmatrix\nqquad\ng = beginbmatrix g_1  0  0 endbmatrix\n\nHere, g_1 encodes boundary conditions for u. Then we minimize:\n\nint_Omega f^TDz\n\nThe named arguments rest... are passed verbatim to amg_solve.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.spectral1d-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.spectral1d","text":"function spectral1d(::Type{T}=Float64; n=nothing, L::Integer=2,\n                K=nothing,\n                state_variables = [:u :dirichlet\n                                   :s :full],\n                D = [:u :id\n                     :u :dx\n                     :s :id],\n                generate_feasibility=true) where {T}\n\nConstruct an AMG object for a 1d spectral grid of polynomials of degree n-1. See also fem1d for a description of the parameters state_variables and D.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.spectral1d_interp-Union{Tuple{Mat}, Tuple{T}, Tuple{AMG{T, Mat, SPECTRAL1D}, Vector{T}, Any}} where {T, Mat}","page":"Home","title":"MultiGridBarrier.spectral1d_interp","text":"function spectral1d_interp(MM::AMG{T,Mat,SPECTRAL1D}, y::Vector{T},x) where {T,Mat}\n\nA function to interpolate a solution y at some point(s) x.\n\nMM the mesh of the solution.\ny the solution.\nx point(s) at which the solution should be evaluated.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.spectral1d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.spectral1d_solve","text":"spectral1d_solve(::Type{T}=Float64;rest...) where {T} = amg_solve(T;method=SPECTRAL1D,rest...)\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.spectral2d-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.spectral2d","text":"function spectral2d(::Type{T}=Float64; n=nothing,                     L::Integer=2,                     K=nothing,                     statevariables = [:u :dirichlet                                        :s :full],                     D = [:u :id                          :u :dx                          :u :dy                          :s :id],                     generatefeasibility=true) where {T}\n\nConstruct an AMG object for a 2d spectral grid of degree n-1. See also fem2d for a description of state_variables and D.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.spectral2d_interp-Union{Tuple{Mat}, Tuple{T}, Tuple{AMG{T, Mat, SPECTRAL2D}, Vector{T}, Matrix{T}}} where {T, Mat}","page":"Home","title":"MultiGridBarrier.spectral2d_interp","text":"function spectral2d_interp(MM::AMG{T,Mat,SPECTRAL2D},z::Vector{T},x::Matrix{T}) where {T,Mat}\n\nInterpolate a solution z at point(s) x, given the mesh MM. See also spectral1d_interp.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.spectral2d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.spectral2d_solve","text":"spectral2d_solve(::Type{T}=Float64;rest...) where {T} = amg_solve(T;method=SPECTRAL2D,rest...)\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.stopping_exact-Tuple{T} where T","page":"Home","title":"MultiGridBarrier.stopping_exact","text":"stopping_exact(theta::T) where {T}\n\nCreate an exact stopping criterion for Newton methods.\n\nArguments\n\ntheta : tolerance parameter for gradient norm relative decrease (type T).\n\nReturns\n\nA stopping criterion function with signature: stop(ymin, ynext, gmin, gnext, n, ndecmin, ndec) -> Bool\n\nwhere:\n\nymin : minimum objective value seen so far.\nynext : current objective value.\ngmin : minimum gradient norm seen so far.\ngnext : current gradient vector.\nn : current Newton direction.\nndecmin : square root of minimum Newton decrement seen so far.\nndec : square root of current Newton decrement.\n\nAlgorithm\n\nReturns true (stop) if both conditions hold:\n\nNo objective improvement: ynext ≥ ymin\nGradient norm stagnation: ‖gnext‖ ≥ theta * gmin\n\nNotes\n\nThis criterion is \"exact\" in the sense that it requires both objective and gradient stagnation before stopping, making it suitable for high-precision optimization. Typical values of theta are in the range [0.1, 0.9].\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.stopping_inexact-Union{Tuple{T}, Tuple{T, T}} where T","page":"Home","title":"MultiGridBarrier.stopping_inexact","text":"stopping_inexact(lambda_tol::T, theta::T) where {T}\n\nCreate an inexact stopping criterion for Newton methods that combines Newton decrement and exact stopping conditions.\n\nArguments\n\nlambda_tol : tolerance for the Newton decrement (type T).\ntheta : tolerance parameter for the exact stopping criterion (type T).\n\nReturns\n\nA stopping criterion function with signature: stop(ymin, ynext, gmin, gnext, n, ndecmin, ndec) -> Bool\n\nwhere:\n\nymin : minimum objective value seen so far.\nynext : current objective value.\ngmin : minimum gradient norm seen so far.\ngnext : current gradient vector.\nn : current Newton direction.\nndecmin : square root of minimum Newton decrement seen so far.\nndec : square root of current Newton decrement (√(gᵀH⁻¹g)).\n\nAlgorithm\n\nReturns true (stop) if either condition holds:\n\nNewton decrement condition: ndec < lambda_tol\nExact stopping condition: stopping_exact(theta) is satisfied\n\nNotes\n\nThis criterion is \"inexact\" because it allows early termination based on the Newton decrement, which provides a quadratic convergence estimate. The Newton decrement λ = √(gᵀH⁻¹g) approximates the distance to the optimum in the Newton metric. Typical values: lambda_tol ∈ [1e-6, 1e-3], theta ∈ [0.1, 0.9].\n\n\n\n\n\n","category":"method"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
