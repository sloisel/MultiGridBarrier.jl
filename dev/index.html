<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · MultiGridBarrier.jl</title><meta name="title" content="Home · MultiGridBarrier.jl"/><meta property="og:title" content="Home · MultiGridBarrier.jl"/><meta property="twitter:title" content="Home · MultiGridBarrier.jl"/><meta name="description" content="Documentation for MultiGridBarrier.jl."/><meta property="og:description" content="Documentation for MultiGridBarrier.jl."/><meta property="twitter:description" content="Documentation for MultiGridBarrier.jl."/><meta property="og:url" content="https://sloisel.github.io/MultiGridBarrier.jl/"/><meta property="twitter:url" content="https://sloisel.github.io/MultiGridBarrier.jl/"/><link rel="canonical" href="https://sloisel.github.io/MultiGridBarrier.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>MultiGridBarrier.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/sloisel/MultiGridBarrier.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="MultiGridBarrier"><a class="docs-heading-anchor" href="#MultiGridBarrier">MultiGridBarrier</a><a id="MultiGridBarrier-1"></a><a class="docs-heading-anchor-permalink" href="#MultiGridBarrier" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/sloisel/MultiGridBarrier.jl">MultiGridBarrier</a>.</p><ul><li><a href="#MultiGridBarrier.AMG"><code>MultiGridBarrier.AMG</code></a></li><li><a href="#MultiGridBarrier.Barrier"><code>MultiGridBarrier.Barrier</code></a></li><li><a href="#MultiGridBarrier.amg-Union{Tuple{}, Tuple{M}, Tuple{T}} where {T, M}"><code>MultiGridBarrier.amg</code></a></li><li><a href="#MultiGridBarrier.amgb-Union{Tuple{Mat}, Tuple{T}, Tuple{Barrier, AMG{T, Mat}, Vector{T}, Matrix{T}}} where {T, Mat}"><code>MultiGridBarrier.amgb</code></a></li><li><a href="#MultiGridBarrier.barrier-Tuple{Any}"><code>MultiGridBarrier.barrier</code></a></li><li><a href="#MultiGridBarrier.damped_newton-Union{Tuple{T}, Tuple{Function, Function, Function, Vector{T}}} where T"><code>MultiGridBarrier.damped_newton</code></a></li><li><a href="#MultiGridBarrier.fem1d-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T"><code>MultiGridBarrier.fem1d</code></a></li><li><a href="#MultiGridBarrier.fem2d-Union{Tuple{T}, Tuple{Type{T}, Int64, Matrix{T}}} where T"><code>MultiGridBarrier.fem2d</code></a></li><li><a href="#MultiGridBarrier.fem_interp1d-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, T}} where T"><code>MultiGridBarrier.fem_interp1d</code></a></li><li><a href="#MultiGridBarrier.fem_interp1d-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector{T}}} where T"><code>MultiGridBarrier.fem_interp1d</code></a></li><li><a href="#MultiGridBarrier.fem_plot_2d-Union{Tuple{Mat}, Tuple{T}, Tuple{AMG{T, Mat}, Array{T}}} where {T, Mat}"><code>MultiGridBarrier.fem_plot_2d</code></a></li><li><a href="#MultiGridBarrier.fem_solve_1d-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.fem_solve_1d</code></a></li><li><a href="#MultiGridBarrier.fem_solve_2d-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.fem_solve_2d</code></a></li><li><a href="#MultiGridBarrier.interp1d-Union{Tuple{Mat}, Tuple{T}, Tuple{AMG{T, Mat}, Vector{T}, Any}} where {T, Mat}"><code>MultiGridBarrier.interp1d</code></a></li><li><a href="#MultiGridBarrier.interp2d-Union{Tuple{Mat}, Tuple{T}, Tuple{AMG{T, Mat}, Vector{T}, Matrix{T}}} where {T, Mat}"><code>MultiGridBarrier.interp2d</code></a></li><li><a href="#MultiGridBarrier.plot1d-Union{Tuple{Mat}, Tuple{T}, Tuple{AMG{T, Mat}, Any, Any, Vararg{Any}}} where {T, Mat}"><code>MultiGridBarrier.plot1d</code></a></li><li><a href="#MultiGridBarrier.plot2d-Union{Tuple{Mat}, Tuple{T}, Tuple{AMG{T, Mat}, Any, Any, Vector{T}}} where {T, Mat}"><code>MultiGridBarrier.plot2d</code></a></li><li><a href="#MultiGridBarrier.spectral_solve_1d-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.spectral_solve_1d</code></a></li><li><a href="#MultiGridBarrier.spectral_solve_2d-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.spectral_solve_2d</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.AMG" href="#MultiGridBarrier.AMG"><code>MultiGridBarrier.AMG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">@kwdef struct AMG{T,M}
    ...
end</code></pre><p>Objects of this type should probably be assembled by the constructor <code>amg()</code>.</p><p>A multigrid with <code>L</code> level. Denote by <code>l</code> between 1 and <code>L</code>, a grid level. Fields are:</p><ul><li><code>x::Array{Array{T,2},1}</code> an array of <code>L</code> matrices. <code>x[l]</code> stores the vertices of the grid at multigrid level <code>l</code>.</li><li><code>w::Array{Array{T,1},1}</code> an array of <code>L</code> quadrature weights. <code>w[l]</code> corresponds to <code>x[l]</code>.</li><li><code>R_fine::Array{M,1}</code> an array of <code>L</code> matrices. The columns of <code>R_fine[l]</code> are basis functions for the function space on grid level <code>l</code>, interpolated to the fine grid.</li><li><code>R_coarse::Array{M,1}</code> an array of <code>L</code> matrices. The columns of <code>R_coarse[l]</code> are basis functions for the function space on grid level <code>l</code>. Unlike <code>R_fine[l]</code>, these basis functions are on grid level <code>l</code>, not interpolated to the fine grid.</li><li><code>D::Array{M,2}</code> an array of differential operators. For example, if the barrier parameters are to be <code>u,ux,s</code>, with <code>ux</code> the derivative of <code>u</code>, then <code>D[l,:] = [I,Dx,I]</code>, where <code>Dx</code> is a numerical differentiation operator on grid level <code>l</code>.  </li><li><code>refine_u::Array{M,1}</code> an array of <code>L</code> grid refinement matrices. If <code>x[l]</code> has <code>n[l]</code> vertices, then <code>refine_u[l]</code> is <code>n[l+1]</code> by <code>n[l]</code>.</li><li><code>coarsen_u::Array{M,1}</code> an array of <code>L</code> grid coarsening matrices. <code>coarsen_u[l]</code> is <code>n[l]</code> by <code>n[l+1]</code>.</li><li><code>refine_z::Array{M,1}</code> an array of <code>L</code> grid refining matrices for the &quot;state vector&quot; <code>z</code>. For example, if <code>z</code> contains the state functions <code>u</code> and <code>s</code>, then there are <code>k=2</code> state functions, and <code>refine_z[l]</code> is <code>k*n[l+1]</code> by <code>k*n[l]</code>.</li><li><code>coarsen_z::Array{M,1}</code> an array of <code>L</code> grid coarsening matrices for the &quot;state vector&quot; <code>z</code>. <code>coarsen_z[l]</code> is <code>k*n[l]</code> by <code>k*n[l+1]</code>.</li></ul><p>These various matrices must satisfy a wide variety of algebraic relations. For this reason, it is recommended to use the constructor <code>amg()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/6796a288471efe8e15392adb9d6c1a9f8999dbc9/src/AlgebraicMultiGridBarrier.jl#L27-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.Barrier" href="#MultiGridBarrier.Barrier"><code>MultiGridBarrier.Barrier</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Barrier</code></pre><p>A type for holding barrier functions. Fields are:</p><pre><code class="nohighlight hljs">f0::Function
f1::Function
f2::Function</code></pre><p><code>f0</code> is the barrier function itself, while <code>f1</code> is its gradient and <code>f2</code> is the Hessian.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/6796a288471efe8e15392adb9d6c1a9f8999dbc9/src/AlgebraicMultiGridBarrier.jl#L9-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.amg-Union{Tuple{}, Tuple{M}, Tuple{T}} where {T, M}" href="#MultiGridBarrier.amg-Union{Tuple{}, Tuple{M}, Tuple{T}} where {T, M}"><code>MultiGridBarrier.amg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function amg(;
    x::Array{Array{T,2},1},
    w::Array{T,1},
    state_variables::Array{Symbol,2},
    D::Array{Symbol,2},
    subspaces::Dict{Symbol,Array{M,1}},
    operators::Dict{Symbol,M},
    refine::Array{M,1},
    coarsen::Array{M,1}) where {T,M}</code></pre><p>Construct an <code>AMG</code> object for use with the <code>amgb</code> solver. In many cases, this constructor is not called directly by the user. For 1d and 2d finite elements, use the <code>MultiGridBarrier</code> module. For 1d and 2d spectral elements, use the <code>SpectralBarrierMethod</code> module. You use <code>amg()</code> directly if you are implementing your own function spaces.</p><p>The <code>AMG</code> object shall represent all <code>L</code> grid levels of the multigrid hierarchy. Parameters are:</p><ul><li><code>x</code>: an array of <code>L</code> matrices. <code>x[l]</code> has the vertices of grid level <code>l</code>, one vertex per row.</li><li><code>w</code>: an array of <code>L</code> vectors. <code>w[l]</code> has the quadrature weights for grid level <code>l</code>.</li><li><code>state_variables</code>: a matrix of symbols. The first column indicates the names of the state vectors or functions, and the second column indicates the names of the corresponding subspaces. A typical example is: <code>state_variables = [:u :dirichlet; :s :full]</code>. This would define the solution as being functions named u(x) and s(x). The u function would lie in the space <code>:dirichlet</code>, presumably consisting of functions with homogeneous Dirichlet conditions. The s function would lie in the space <code>:full</code>, presumably being the full function space, without boundary conditions.</li><li><code>D</code>: a matrix of symbols. The first column indicates the names of various state variables, and the second column indicates the corresponding differentiation operator(s). For example: <code>D = [:u :id ; :u :dx ; :s :id]</code>. This would indicate that the barrier should be called as <code>F(x,y)</code> with <code>y = [u,ux,s]</code>, where <code>ux</code> denotes the derivative of <code>u</code> with respect to the space variable <code>x</code>.</li><li><code>subspaces</code>: a <code>Dict</code> mapping each subspace symbol to an array of <code>L</code> matrices, e.g. for each <code>l</code>, <code>subspaces[:dirichlet][l]</code> is a matrix whose columns span the homogeneous Dirichlet subspace of grid level <code>l</code>.</li><li><code>operators</code>: a <code>Dict</code> mapping each differential operator symbol to a matrix, e.g. <code>operators[:id]</code> is an identity matrix, while <code>operators[:dx]</code> is a numerical differentiation matrix, on the fine grid level <code>L</code>.</li><li><code>refine</code>: an array of length <code>L</code> of matrices. For each <code>l</code>, <code>refine[l]</code> interpolates from grid level <code>l</code> to grid level <code>l+1</code>. <code>refine[L]</code> should be the identity, and <code>coarsen[l]*refine[l]</code> should be the identity.</li><li><code>coarsen</code>: an array of length <code>L</code> of matrices. For each <code>l</code>, <code>coarsen[l]</code> interpolates or projects from grid level <code>l+1</code> to grid level <code>l</code>. <code>coarsen[L]</code> should be the identity.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/6796a288471efe8e15392adb9d6c1a9f8999dbc9/src/AlgebraicMultiGridBarrier.jl#L60-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.amgb-Union{Tuple{Mat}, Tuple{T}, Tuple{Barrier, AMG{T, Mat}, Vector{T}, Matrix{T}}} where {T, Mat}" href="#MultiGridBarrier.amgb-Union{Tuple{Mat}, Tuple{T}, Tuple{Barrier, AMG{T, Mat}, Vector{T}, Matrix{T}}} where {T, Mat}"><code>MultiGridBarrier.amgb</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function amgb(B::Barrier,
    M::AMG{T,Mat},
    z::Array{T,1},
    c::Array{T,2};
    tol=(eps(T)),
    t=T(0.1),
    maxit=10000,
    alpha=T(0.5),
    beta=T(0.1),
    kappa=T(10.0),
    verbose=true) where {T,Mat}</code></pre><p>The &quot;Algebraic MultiGrid Barrier&quot; method.</p><ul><li><code>B</code> a Barrier object.</li><li><code>M</code> an AMG object.</li><li><code>z</code> a starting point for the minimization, which should be admissible, i.e. <code>B.f0(z)&lt;∞</code>.</li><li><code>c</code> an objective functional to minimize. Concretely, we minimize the integral of <code>c.*(D*z)</code>, as computed by the finest quadrature in <code>M</code>, subject to <code>B.f0(z)&lt;∞</code>. Here, <code>D</code> is the differential operator provided in <code>M</code>.</li></ul><p>Optional parameters:</p><ul><li><code>t</code>: the initial value of <code>t</code></li><li><code>tol</code>: we stop when <code>1/t&lt;tol</code>.</li><li><code>maxit</code>: the maximum number of <code>t</code> steps.</li><li><code>alpha</code>, <code>beta</code>: parameters of the backtracking line search.</li><li><code>kappa</code>: the initial size of the t-step. Stepsize adaptation is used in the AMGB algorithm, where the t-step size may be made smaller or large, but it will never exceed the initial size provided here.</li><li><code>verbose</code>: set to <code>true</code> to see a progress bar.</li></ul><p>Return value is a named tuple <code>SOL</code> with the following fields:</p><ul><li><code>SOL.converged</code> is <code>true</code> if convergence was obtained, else it is <code>false</code>.</li><li><code>SOL.z</code> the computed solution.</li></ul><p>Further <code>SOL</code> fields contain various statistics about the solve process.</p><p>The following &quot;example usage&quot; is an extremely convoluted way of minimizing x in the interval [-1,1]:</p><pre><code class="nohighlight hljs">using AlgebraicMultiGridBarrier
M = amg(x = [[-1.0 ; 1.0 ;;]],
        w = [1.0,1.0],
        state_variables = [:u :space],
        D = [:u :id],
        subspaces = Dict(:space =&gt; [[1.0 ; -1.0 ;;]]),
        operators = Dict(:id =&gt; [1.0 0.0;0.0 1.0]),
        refine = [[1.0 0.0 ; 0.0 1.0]],
        coarsen = [[1.0 0.0 ; 0.0 1.0]])
B = barrier((x,y)-&gt;-log(1-x[1]*y[1]))
amgb(B,M,[0.0,0.0],[1.0 ; 0.0 ;;])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/6796a288471efe8e15392adb9d6c1a9f8999dbc9/src/AlgebraicMultiGridBarrier.jl#L403-L451">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.barrier-Tuple{Any}" href="#MultiGridBarrier.barrier-Tuple{Any}"><code>MultiGridBarrier.barrier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function barrier(f;
    f1=(x,y)-&gt;ForwardDiff.gradient(z-&gt;f(x,z),y),
    f2=(x,y)-&gt;ForwardDiff.hessian(z-&gt;f(x,z),y))::Barrier</code></pre><p>Constructor for barriers.</p><ul><li><code>f</code> is the actual barrier function. It should take parameters <code>(x,y)</code>.</li><li><code>f1</code> is the gradient of <code>f</code> with respect to <code>y</code>.</li><li><code>f2</code> is the Hessian of <code>f</code> with  respect to <code>y</code>.</li></ul><p>By default, <code>f1</code> and <code>f2</code> are automatically generated by the module <code>ForwardDiff</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/6796a288471efe8e15392adb9d6c1a9f8999dbc9/src/AlgebraicMultiGridBarrier.jl#L144-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.damped_newton-Union{Tuple{T}, Tuple{Function, Function, Function, Vector{T}}} where T" href="#MultiGridBarrier.damped_newton-Union{Tuple{T}, Tuple{Function, Function, Function, Vector{T}}} where T"><code>MultiGridBarrier.damped_newton</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function damped_newton(F0::Function,
                   F1::Function,
                   F2::Function,
                   x::Array{T,1};
                   maxit=10000,
                   alpha=T(0.5),
                   beta=T(0.1)) where {T}</code></pre><p>Damped Newton iteration for minimizing a function.</p><ul><li><code>F0</code> the objective function</li><li><code>F1</code> and <code>F2</code> are the gradient and Hessian of <code>F0</code>, respectively.</li><li><code>x</code> the starting point of the minimization procedure.</li></ul><p>The optional parameters are:</p><ul><li><code>maxit</code>, the iteration aborts with a failure message if convergence is not achieved within <code>maxit</code> iterations.</li><li><code>alpha</code> and <code>beta</code> are the parameters of the backtracking line search.</li><li><code>tol</code> is used as a stopping criterion. We stop when the decrement in the objective is sufficiently small.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/6796a288471efe8e15392adb9d6c1a9f8999dbc9/src/AlgebraicMultiGridBarrier.jl#L327-L346">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.fem1d-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T" href="#MultiGridBarrier.fem1d-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T"><code>MultiGridBarrier.fem1d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function fem1d(::Type{T}, L::Int;
                state_variables = [:u :dirichlet
                                   :s :full],
                D = [:u :id
                     :u :dx
                     :s :id]) where {T}</code></pre><p>Construct an <code>AlgebraicMultiGridBarrier.AMG</code> object for a 1d piecewise linear finite element grid. The interval is [-1,1]. Parameters are:</p><ul><li><code>L</code>: divide the interval into 2^L subintervals (L for Levels).</li><li><code>state_variables</code>: the &quot;state vector&quot; consists of functions, by default this is <code>u(x)</code> and <code>s(x)</code>, on the finite element grid.</li><li><code>D</code>: the set of differential operator. The barrier function <code>F</code> will eventually be called with the parameters <code>F(x,Dz)</code>, where <code>z</code> is the state vector. By default, this results in <code>F(x,u,ux,s)</code>, where <code>ux</code> is the derivative of <code>u</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/6796a288471efe8e15392adb9d6c1a9f8999dbc9/src/FiniteElements.jl#L3-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.fem2d-Union{Tuple{T}, Tuple{Type{T}, Int64, Matrix{T}}} where T" href="#MultiGridBarrier.fem2d-Union{Tuple{T}, Tuple{Type{T}, Int64, Matrix{T}}} where T"><code>MultiGridBarrier.fem2d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function fem2d(::Type{T}, L::Int, K::Matrix{T};
                state_variables = [:u :dirichlet
                                   :s :full],
                D = [:u :id
                     :u :dx
                     :u :dy
                     :s :id]) where {T}</code></pre><p>Construct an <code>AlgebraicMultiGridBarrier.AMG</code> object for a 2d finite element grid on the domain <code>K</code> with piecewise quadratic elements. Parameters are:</p><ul><li><code>K</code>: a triangular mesh. If there are <code>n</code> triangles, then <code>K</code> should be a 3n by 2 matrix of vertices. The first column of <code>K</code> represents <code>x</code> coordinates, the second column represents <code>y</code> coordinates.</li><li><code>L</code>: divide the interval into 2^L subintervals (L for Levels).</li><li><code>state_variables</code>: the &quot;state vector&quot; consists of functions, by default this is <code>u(x)</code> and <code>s(x)</code>, on the finite element grid.</li><li><code>D</code>: the set of differential operator. The barrier function <code>F</code> will eventually be called with the parameters <code>F(x,y,Dz)</code>, where <code>z</code> is the state vector. By default, this results in <code>F(x,y,u,ux,uy,s)</code>, where <code>(ux,uy)</code> is the gradient of <code>u</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/6796a288471efe8e15392adb9d6c1a9f8999dbc9/src/FiniteElements.jl#L220-L235">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.fem_interp1d-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, T}} where T" href="#MultiGridBarrier.fem_interp1d-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, T}} where T"><code>MultiGridBarrier.fem_interp1d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function fem_interp1d(x::Vector{T},
                  y::Vector{T},
                  t::T) where{T}</code></pre><p>Interpolate a 1d piecewise linear function at the given <code>t</code> value. If <code>u(xi)</code> is the piecewise linear function such that <code>u(x[k])=y[k]</code> then this function returns <code>u(t)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/6796a288471efe8e15392adb9d6c1a9f8999dbc9/src/FiniteElements.jl#L99-L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.fem_interp1d-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector{T}}} where T" href="#MultiGridBarrier.fem_interp1d-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector{T}}} where T"><code>MultiGridBarrier.fem_interp1d</code></a> — <span class="docstring-category">Method</span></header><section><div><p>function fem_interp1d(x::Vector{T},                       y::Vector{T},                       t::Vector{T}) where{T}</p><p>Returns <code>[fem_interp1d(x,y,t[k]) for k=1:length(t)]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/6796a288471efe8e15392adb9d6c1a9f8999dbc9/src/FiniteElements.jl#L128-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.fem_plot_2d-Union{Tuple{Mat}, Tuple{T}, Tuple{AMG{T, Mat}, Array{T}}} where {T, Mat}" href="#MultiGridBarrier.fem_plot_2d-Union{Tuple{Mat}, Tuple{T}, Tuple{AMG{T, Mat}, Array{T}}} where {T, Mat}"><code>MultiGridBarrier.fem_plot_2d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function fem_plot_2d(M::AMG{T, Mat}, z::Array{T}) where {T,Mat}</code></pre><p>Plot a piecewise quadratic solution <code>z</code> on the given mesh. Note that the solution is drawn as (linear) triangles, even though the underlying solution is piecewise quadratic. To obtain a more accurate depiction, especially when the mesh is coarse, it would be preferable to apply a few levels of additional subdivision, so as to capture the curve of the quadratic basis functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/6796a288471efe8e15392adb9d6c1a9f8999dbc9/src/FiniteElements.jl#L289-L293">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.fem_solve_1d-Union{Tuple{Type{T}}, Tuple{T}} where T" href="#MultiGridBarrier.fem_solve_1d-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.fem_solve_1d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function fem_solve_1d(::Type{T}; g = x-&gt;x,
    f = x-&gt;T(0.5), maxit=10000, L=2, p=T(1.0),
    verbose=true, show=true, tol=sqrt(eps(T)),
    F = (x,u,ux,s) -&gt; -log(s^(2/p)-ux^2)-2*log(s),
    slack = x-&gt;T(2)) where {T}</code></pre><p>Solve a 1d variational problem on the interval [-1,1] with piecewise linear elements. Parameters are:</p><ul><li><code>g</code> the boundary conditions.</li><li><code>f</code> the forcing function.</li><li><code>maxit</code> a maximum number of iterations used in the solver.</li><li><code>L</code> the number of Levels of grid subdivisions, so that the grid consists of 2^L intervals.</li><li><code>p</code> the parameter of the p-Laplace problem, if that&#39;s what we&#39;re solving.</li><li><code>verbose</code>: set to <code>true</code> to get a progress bar.</li><li><code>tol</code>: a stopping criterion, the barrier method stops when <code>t&gt;1/tol</code>.</li><li><code>F</code>: the barrier. The default barrier solves a p-Laplacian.</li><li><code>slack</code>: an initializer for the slack function <code>s(x)</code>.</li></ul><p>This function returns <code>SOL,B</code>, where <code>SOL</code> is from <code>amgb</code>, and <code>B</code> is the <code>Barrier</code> object obtained from <code>F</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/6796a288471efe8e15392adb9d6c1a9f8999dbc9/src/FiniteElements.jl#L59-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.fem_solve_2d-Union{Tuple{Type{T}}, Tuple{T}} where T" href="#MultiGridBarrier.fem_solve_2d-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.fem_solve_2d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function fem_solve_2d(::Type{T}; 
    K = T[-1 -1;1 -1;-1 1;1 -1;1 1;-1 1],
    g = (x,y)-&gt;x^2+y^2, 
    f = (x,y)-&gt;T(0.5), maxit=10000, L=2, p=T(1.0),
    verbose=true, show=true, tol=sqrt(eps(T)),
    F = (x,y,u,ux,uy,s) -&gt; -log(s^(2/p)-ux^2-uy^2)-2*log(s),
    slack = (x,y)-&gt;T(100)) where {T}</code></pre><p>Solve a 2d variational problem on the domain <code>K</code>, which defaults to the square [-1,1]x[-1,1], with piecewise quadratic elements. Parameters are:</p><ul><li><code>K</code> a triangulation of the domain. For <code>n</code> triangles, <code>K</code> should be a 3n by 2 matrix of vertices.</li><li><code>g</code> the boundary conditions.</li><li><code>f</code> the forcing function.</li><li><code>maxit</code> a maximum number of iterations used in the solver.</li><li><code>L</code> the number of Levels of grid subdivisions, so that the grid consists of <code>N = n*4^L</code> quadratic triangular elements. Each elements is quadratic, plus a bump function, so each element consists of 7 vertices, i.e. there are <code>7*N</code> vertices in total.</li><li><code>p</code> the parameter of the p-Laplace problem, if that&#39;s what we&#39;re solving.</li><li><code>verbose</code>: set to <code>true</code> to get a progress bar.</li><li><code>tol</code>: a stopping criterion, the barrier method stops when <code>t&gt;1/tol</code>.</li><li><code>F</code>: the barrier. The default barrier solves a p-Laplacian.</li><li><code>slack</code>: an initializer for the slack function <code>s(x)</code>.</li></ul><p>This function returns <code>SOL,B</code>, where <code>SOL</code> is from <code>amgb</code>, and <code>B</code> is the <code>Barrier</code> object obtained from <code>F</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/6796a288471efe8e15392adb9d6c1a9f8999dbc9/src/FiniteElements.jl#L308-L330">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.interp1d-Union{Tuple{Mat}, Tuple{T}, Tuple{AMG{T, Mat}, Vector{T}, Any}} where {T, Mat}" href="#MultiGridBarrier.interp1d-Union{Tuple{Mat}, Tuple{T}, Tuple{AMG{T, Mat}, Vector{T}, Any}} where {T, Mat}"><code>MultiGridBarrier.interp1d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function interp1d(MM::AMG{T,Mat}, y::Array{T,1},x) where {T,Mat}</code></pre><p>A function to interpolate a solution <code>y</code> at some point(s) <code>x</code>.</p><ul><li><code>MM</code> the mesh of the solution.</li><li><code>y</code> the solution.</li><li><code>x</code> point(s) at which the solution should be evaluated.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/6796a288471efe8e15392adb9d6c1a9f8999dbc9/src/SpectralBarrierMethod.jl#L122-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.interp2d-Union{Tuple{Mat}, Tuple{T}, Tuple{AMG{T, Mat}, Vector{T}, Matrix{T}}} where {T, Mat}" href="#MultiGridBarrier.interp2d-Union{Tuple{Mat}, Tuple{T}, Tuple{AMG{T, Mat}, Vector{T}, Matrix{T}}} where {T, Mat}"><code>MultiGridBarrier.interp2d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function interp2d(MM::AMG{T,Mat},z::Array{T,1},x::Array{T,2}) where {T,Mat}</code></pre><p>Interpolate a solution <code>z</code> at point(s) <code>x</code>, given the mesh <code>MM</code>. See also <code>interp1d</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/6796a288471efe8e15392adb9d6c1a9f8999dbc9/src/SpectralBarrierMethod.jl#L235-L240">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.plot1d-Union{Tuple{Mat}, Tuple{T}, Tuple{AMG{T, Mat}, Any, Any, Vararg{Any}}} where {T, Mat}" href="#MultiGridBarrier.plot1d-Union{Tuple{Mat}, Tuple{T}, Tuple{AMG{T, Mat}, Any, Any, Vararg{Any}}} where {T, Mat}"><code>MultiGridBarrier.plot1d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function plot1d(M::AMG{T,Mat},x,y,rest...) where {T,Mat}</code></pre><p>Plot a solution using <code>pyplot</code>.</p><ul><li><code>M</code>: a mesh.</li><li><code>x</code>: x values where the solution should be evaluated and plotted.</li><li><code>y</code>: the solution, to be interpolated at the given <code>x</code> values via <code>interp1d</code>.</li><li><code>rest...</code> parameters are passed directly to <code>pyplot.plot</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/6796a288471efe8e15392adb9d6c1a9f8999dbc9/src/SpectralBarrierMethod.jl#L147-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.plot2d-Union{Tuple{Mat}, Tuple{T}, Tuple{AMG{T, Mat}, Any, Any, Vector{T}}} where {T, Mat}" href="#MultiGridBarrier.plot2d-Union{Tuple{Mat}, Tuple{T}, Tuple{AMG{T, Mat}, Any, Any, Vector{T}}} where {T, Mat}"><code>MultiGridBarrier.plot2d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function plot2d(M::Mesh{T},x,y,z::Array{T,1};rest...) where {T}</code></pre><p>Plot a 2d solution.</p><ul><li><code>M</code> a 2d mesh.</li><li><code>x</code>, <code>y</code> should be ranges like -1:0.01:1.</li><li><code>z</code> the solution to plot.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/6796a288471efe8e15392adb9d6c1a9f8999dbc9/src/SpectralBarrierMethod.jl#L274-L282">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.spectral_solve_1d-Union{Tuple{Type{T}}, Tuple{T}} where T" href="#MultiGridBarrier.spectral_solve_1d-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.spectral_solve_1d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function spectral_solve_1d(::Type{T}; g = x-&gt;x,
    f = x-&gt;T(0.5), maxit=10000, n=4, p=T(1.0),
    verbose=true, show=true, tol=sqrt(eps(T)),
    F = (x,u,ux,s) -&gt; -log(s^(2/p)-ux^2)-2*log(s),
    slack = x-&gt;T(2)) where {T}</code></pre><p>Solves a p-Laplace problem in d=1 dimension with the given value of p and  plot the result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/6796a288471efe8e15392adb9d6c1a9f8999dbc9/src/SpectralBarrierMethod.jl#L161-L170">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.spectral_solve_2d-Union{Tuple{Type{T}}, Tuple{T}} where T" href="#MultiGridBarrier.spectral_solve_2d-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.spectral_solve_2d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function spectral_solve_2d(::Type{T}; g = (x,y)-&gt;x^2+y^2, 
    f = (x,y)-&gt;T(0.5), maxit=10000, n=4, p=T(1.0),
    verbose=true, show=true, tol=sqrt(eps(T)),
    F = (x,y,u,ux,uy,s) -&gt; -log(s^(2/p)-ux^2-uy^2)-2*log(s),
    slack = (x,y)-&gt;T(10)) where {T}</code></pre><p>Solves a p-Laplace problem in d=2 dimensions with the given value of p and  plot the result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/6796a288471efe8e15392adb9d6c1a9f8999dbc9/src/SpectralBarrierMethod.jl#L296-L305">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Tuesday 28 May 2024 09:50">Tuesday 28 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
