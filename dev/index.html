<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · MultiGridBarrier.jl</title><meta name="title" content="Home · MultiGridBarrier.jl"/><meta property="og:title" content="Home · MultiGridBarrier.jl"/><meta property="twitter:title" content="Home · MultiGridBarrier.jl"/><meta name="description" content="Documentation for MultiGridBarrier.jl."/><meta property="og:description" content="Documentation for MultiGridBarrier.jl."/><meta property="twitter:description" content="Documentation for MultiGridBarrier.jl."/><meta property="og:url" content="https://sloisel.github.io/MultiGridBarrier.jl/"/><meta property="twitter:url" content="https://sloisel.github.io/MultiGridBarrier.jl/"/><link rel="canonical" href="https://sloisel.github.io/MultiGridBarrier.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>MultiGridBarrier.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Finite-elements"><span>Finite elements</span></a></li><li><a class="tocitem" href="#Spectral-elements"><span>Spectral elements</span></a></li><li><a class="tocitem" href="#Solving-\\infty-Laplacians"><span>Solving <span>$\infty$</span>-Laplacians</span></a></li><li><a class="tocitem" href="#Parabolic-problems"><span>Parabolic problems</span></a></li><li class="toplevel"><a class="tocitem" href="#Module-reference"><span>Module reference</span></a></li><li class="toplevel"><a class="tocitem" href="#Types-reference"><span>Types reference</span></a></li><li class="toplevel"><a class="tocitem" href="#Functions-reference"><span>Functions reference</span></a></li><li class="toplevel"><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/sloisel/MultiGridBarrier.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1>MultiGridBarrier 0.9.1</h1><p><a href="https://github.com/sloisel/MultiGridBarrier.jl">MultiGridBarrier</a> is a Julia module for solving nonlinear convex optimization problems in function spaces, such as p-Laplace problems. When regularity conditions are satisfied, the solvers are quasi-optimal.</p><p>The <code>MultiGridBarrier</code> module features finite element and spectral discretizations in 1d and 2d.</p><h2 id="Finite-elements"><a class="docs-heading-anchor" href="#Finite-elements">Finite elements</a><a id="Finite-elements-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-elements" title="Permalink"></a></h2><p>After installing <code>MultiGridBarrier</code> with the Julia package manager, in a Jupyter notebook, one solves a 1d p-Laplace problem as follows:</p><pre><code class="language-julia hljs">using MultiGridBarrier
fem1d_solve(L=5,p=1.0,verbose=false);</code></pre><p><img src="fem1d.svg" alt/></p><p>A 2d p-Laplace problem:</p><pre><code class="language-julia hljs">fem2d_solve(L=3,p=1.0,verbose=false);</code></pre><p><img src="fem2d.svg" alt/></p><h2 id="Spectral-elements"><a class="docs-heading-anchor" href="#Spectral-elements">Spectral elements</a><a id="Spectral-elements-1"></a><a class="docs-heading-anchor-permalink" href="#Spectral-elements" title="Permalink"></a></h2><p>Solve a 1d p-Laplace problem using spectral methods as follows:</p><pre><code class="language-julia hljs">spectral1d_solve(n=40,p=1.0,verbose=false);</code></pre><p><img src="spectral1d.svg" alt/></p><p>A 2d p-Laplace problem:</p><pre><code class="language-julia hljs">spectral2d_solve(n=5,p=1.5,verbose=false);</code></pre><p><img src="spectral2d.svg" alt/></p><h2 id="Solving-\\infty-Laplacians"><a class="docs-heading-anchor" href="#Solving-\\infty-Laplacians">Solving <span>$\infty$</span>-Laplacians</a><a id="Solving-\\infty-Laplacians-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-\\infty-Laplacians" title="Permalink"></a></h2><p>For <span>$p \geq 1$</span> and domain <span>$\Omega$</span>, the solution <span>$u$</span> of the <span>$p$</span>-Laplace problem is the minimizer of <span>$J(u) = \|\nabla u\|_{L^p(\Omega)}^p + \int_{\Omega} fu,$</span> where <span>$u$</span> is in a suitable space of function satisfying, e.g. Dirichlet conditions, and <span>$f$</span> is a forcing. This definition must be modified for the <span>$\infty$</span>-Laplace problem. Here we show how to minimize: <span>$J(u) = \|\nabla u\|_{L^\infty(\Omega)}^p + \int_{\Omega} fu.$</span> We put <span>$p=1$</span> for simplicity.</p><pre><code class="language-julia hljs">fem1d_solve(L=5,p=1.0,state_variables=[:u :dirichlet; :s :uniform],verbose=false);</code></pre><p><img src="fem1dinfty.svg" alt/></p><h2 id="Parabolic-problems"><a class="docs-heading-anchor" href="#Parabolic-problems">Parabolic problems</a><a id="Parabolic-problems-1"></a><a class="docs-heading-anchor-permalink" href="#Parabolic-problems" title="Permalink"></a></h2><p>A time-dependent problem:</p><pre><code class="language-julia hljs">parabolic_solve(h=0.1,L=3,printer=anim-&gt;anim.save(&quot;parabolic.mp4&quot;),verbose=false);</code></pre><video src="parabolic.mp4" width="600" controls autoplay loop></video><h1 id="Module-reference"><a class="docs-heading-anchor" href="#Module-reference">Module reference</a><a id="Module-reference-1"></a><a class="docs-heading-anchor-permalink" href="#Module-reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.MultiGridBarrier" href="#MultiGridBarrier.MultiGridBarrier"><code>MultiGridBarrier.MultiGridBarrier</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">module MultiGridBarrier</code></pre><p>Module <code>MultiGridBarrier</code> solves convex optimization problems in function spaces, for example, solving p-Laplace problems. We recommend to start with the functions <code>fem1d_solve()</code>, <code>fem2d_solve()</code>, <code>spectral1d_solve()</code>, <code>spectral2d_solve()</code>. These functions are sufficient to solve p-Laplace problems in 1d or 2d, using finite or spectral elements.</p><p>For more general use, the user will need to familiarize themselves with the basic ideas of convex optimization.</p><ul><li>Overview of convex optimization in function spaces by MultiGrid Barrier method.</li></ul><p>The general idea is to build a multigrid hierarchy, represented by an <code>AMG</code> object, and barrier for a convex set, represented by a <code>Barrier</code> object, and then solve a convex optimization problem using the <code>amgb()</code> solver.</p><p>To generate the multigrid hierarchy represented by the <code>AMG</code> object, use either <code>fem1d()</code>, <code>fem2d()</code>, <code>spectral1d()</code> or <code>spectral2d()</code> functions. These constructors will assemble suitable <code>AMG</code> objects for either FEM or spectral discretizations, in 1d or 2d. One should think of these four constructors as being specialized in constructing some specific function spaces. A user can use the <code>amg()</code> constructor directly if custom function spaces are required, but this is more difficult.</p><p>We now describe the barrier function.</p><p>Assume that <span>$\Omega \subset \mathbb{R}^d$</span> is some open set. Consider the example of the p-Laplace problem on <span>$\Omega$</span>. Let <span>$f(x)$</span> be a &quot;forcing&quot; (a function) on <span>$\Omega$</span>, and <span>$1 \leq p &lt; \infty$</span>. One wishes to solve the minimization problem</p><p class="math-container">\[\begin{equation}
\inf_u \int_{\Omega} fu + \|\nabla u\|_2^p \, dx. \tag{1}
\end{equation}\]</p><p>Generally speaking, <span>$u$</span> will range in some function space, e.g. a space of differentiable functions satisfying homogeneous Dirichlet conditions. Under some conditions, minimizing (1) is equivalent to solving the p-Laplace PDE:</p><p class="math-container">\[\nabla \cdot (\|\nabla u\|_2^{p-2}\nabla u) = {1 \over p} f.\]</p><p>We introduce the &quot;slack function&quot; <span>$s(x)$</span> and replace (1) with the following equivalent problem:</p><p class="math-container">\[\begin{equation}
\inf_{s(x) \geq \|\nabla u(x)\|_2^p} \int_{\Omega} fu + s \, dx. \tag{2}
\end{equation}\]</p><p>Define the convex set <span>$\mathcal{Q} = \{ (u(x),q(x),s(x)) \; : \; s(x) \geq \|q(x)\|_2^p \}$</span>, and</p><p class="math-container">\[z = \begin{bmatrix} u \\ s \end{bmatrix}, \qquad
c^T = [f,0,1], \qquad
Dz = \begin{bmatrix} u \\ \nabla u \\ s \end{bmatrix}.\]</p><p>Then, (2) can be rewritten as</p><p class="math-container">\[\begin{equation}
\inf_{Dz \in \mathcal{Q}} \int_{\Omega} c^T(x)Dz(x) \, dx. \tag{3}
\end{equation}\]</p><p>Recall that a barrier for <span>$\mathcal{Q}$</span> is a convex function <span>$\mathcal{F}$</span> on <span>$\mathcal{Q}$</span> such that <span>$\mathcal{F} &lt; \infty$</span> in the interior of <span>$\mathcal{Q}$</span> and <span>$\mathcal{F} = \infty$</span> on the boundary of <span>$\mathcal{Q}$</span>. A barrier for the p-Laplace problem is:</p><p class="math-container">\[\mathcal{F}(u,q,s) = \int_{\Omega} -\log(s^{2 \over p} - \|q\|_2^2) - 2\log s \, dx = \int_{\Omega} F(Dz(x)) \, dx.\]</p><p>The central path <span>$z^*(t)$</span> minimizes, for each fixed <span>$t&gt;0$</span>, the quantity</p><p class="math-container">\[\int_{\Omega} tc^TDz + F(Dz) \, dx.\]</p><p>As <span>$t \to \infty$</span>, <span>$z^*(t)$</span> forms a minimizing sequence (or filter) for (3). We think of the function <span>$c(x)$</span> as the &quot;functional&quot; that we seek to minimize.</p><p>The <code>Convex{T}</code> type describes various convex sets (denoted <span>$Q$</span> above) by way of functions <code>barrier()</code>, <code>cobarrier()</code> and <code>slack()</code>. <code>barrier</code> is indeed a barrier for <span>$Q$</span>, <code>cobarrier()</code> is a barrier for a related feasibility problems, and <code>slack()</code> is used in solving the feasibility problem. <code>Convex{T}</code> objects can be created using the various <code>convex_...()</code> constructors, e.g. <code>convex_Euclidian_power()</code> for the p-Laplace problem.</p><p>Once one has <code>AMG</code> and <code>Convex</code> objects, and a suitable &quot;functional&quot; <code>c</code>, one uses the <code>amgb()</code> function to solve the optimization problem by the MultiGrid Barrier method, a variant of the barrier method (or interior point method) that is quasi-optimal for sufficiently regular problems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/MultiGridBarrier.jl#L1-L58">source</a></section></article><h1 id="Types-reference"><a class="docs-heading-anchor" href="#Types-reference">Types reference</a><a id="Types-reference-1"></a><a class="docs-heading-anchor-permalink" href="#Types-reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.AMG" href="#MultiGridBarrier.AMG"><code>MultiGridBarrier.AMG</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@kwdef struct AMG{T,M,Geometry}
    ...
end</code></pre><p>Objects of this type should probably be assembled by the constructor <code>amg()</code>.</p><p>A multigrid with <code>L</code> levels. Denote by <code>l</code> between 1 and <code>L</code>, a grid level. Fields are:</p><ul><li><code>x::Matrix{T}</code> the vertices of the fine grid.</li><li><code>w::Vector{T}</code> corresponding quadrature weights.</li><li><code>R_fine::Array{M,1}</code> an array of <code>L</code> matrices. The columns of <code>R_fine[l]</code> are basis functions for the function space on grid level <code>l</code>, interpolated to the fine grid.</li><li><code>R_coarse::Array{M,1}</code> an array of <code>L</code> matrices. The columns of <code>R_coarse[l]</code> are basis functions for the function space on grid level <code>l</code>. Unlike <code>R_fine[l]</code>, these basis functions are on grid level <code>l</code>, not interpolated to the fine grid.</li><li><code>D::Array{M,2}</code> an array of differential operators. For example, if the barrier parameters are to be <code>u,ux,s</code>, with <code>ux</code> the derivative of <code>u</code>, then <code>D[l,:] = [I,Dx,I]</code>, where <code>Dx</code> is a numerical differentiation operator on grid level <code>l</code>.  </li><li><code>refine_u::Array{M,1}</code> an array of <code>L</code> grid refinement matrices. If <code>x[l]</code> has <code>n[l]</code> vertices, then <code>refine_u[l]</code> is <code>n[l+1]</code> by <code>n[l]</code>.</li><li><code>coarsen_u::Array{M,1}</code> an array of <code>L</code> grid coarsening matrices. <code>coarsen_u[l]</code> is <code>n[l]</code> by <code>n[l+1]</code>.</li><li><code>refine_z::Array{M,1}</code> an array of <code>L</code> grid refining matrices for the &quot;state vector&quot; <code>z</code>. For example, if <code>z</code> contains the state functions <code>u</code> and <code>s</code>, then there are <code>k=2</code> state functions, and <code>refine_z[l]</code> is <code>k*n[l+1]</code> by <code>k*n[l]</code>.</li><li><code>coarsen_z::Array{M,1}</code> an array of <code>L</code> grid coarsening matrices for the &quot;state vector&quot; <code>z</code>. <code>coarsen_z[l]</code> is <code>k*n[l]</code> by <code>k*n[l+1]</code>.</li></ul><p>These various matrices must satisfy a wide variety of algebraic relations. For this reason, it is recommended to use the constructor <code>amg()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/AlgebraicMultiGridBarrier.jl#L38-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.Barrier" href="#MultiGridBarrier.Barrier"><code>MultiGridBarrier.Barrier</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Barrier</code></pre><p>A type for holding barrier functions. Fields are:</p><pre><code class="nohighlight hljs">f0::Function
f1::Function
f2::Function</code></pre><p><code>f0</code> is the barrier function itself, while <code>f1</code> is its gradient and <code>f2</code> is the Hessian.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/AlgebraicMultiGridBarrier.jl#L20-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.Convex" href="#MultiGridBarrier.Convex"><code>MultiGridBarrier.Convex</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Convex
    barrier::Function
    cobarrier::Function
    slack::Function
end</code></pre><p>The <code>Convex</code> data structure represents a convex domain <span>$Q$</span> implicitly by way of three functions. The <code>barrier</code> function is a barrier for <span>$Q$</span>. <code>cobarrier</code> is a barrier for the feasibility subproblem, and <code>slack</code> is a function that initializes a valid slack value for the feasibility subproblem. The various <code>convex_</code> functions can be used to generate various convex domains.</p><p>These functions are called as follows: <code>barrier(x,y)</code>. <code>x</code> is a vertex in a grid, as per the <code>AMG</code> object. <code>y</code> is some vector. For each fixed <code>x</code> variable, <code>y -&gt; barrier(x,y)</code> defines a barrier for a convex set in <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/AlgebraicMultiGridBarrier.jl#L176-L186">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.FEM1D" href="#MultiGridBarrier.FEM1D"><code>MultiGridBarrier.FEM1D</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type FEM1D end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/fem1d.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.FEM2D" href="#MultiGridBarrier.FEM2D"><code>MultiGridBarrier.FEM2D</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type FEM2D end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/fem2d.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.SPECTRAL1D" href="#MultiGridBarrier.SPECTRAL1D"><code>MultiGridBarrier.SPECTRAL1D</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type SPECTRAL1D end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/spectral1d.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.SPECTRAL2D" href="#MultiGridBarrier.SPECTRAL2D"><code>MultiGridBarrier.SPECTRAL2D</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type SPECTRAL2D end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/spectral2d.jl#L3">source</a></section></article><h1 id="Functions-reference"><a class="docs-heading-anchor" href="#Functions-reference">Functions reference</a><a id="Functions-reference-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.intersect-Union{Tuple{T}, Tuple{Convex{T}, Vararg{Any}}} where T" href="#Base.intersect-Union{Tuple{T}, Tuple{Convex{T}, Vararg{Any}}} where T"><code>Base.intersect</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.intersect(U::Convex{T}, rest...) where {T}</code></pre><p>Intersection of arbitrarily many convex domains.</p><p>Returns a <code>Convex{T}</code> that enforces all given domains at each <code>x</code>. Internally this is implemented via <code>convex_piecewise</code> with <code>select(x) = [true, true, ...]</code>, so that:</p><ul><li><code>barrier(x, y) = U.barrier(x, y) + ∑ rest[k].barrier(x, y)</code></li><li><code>cobarrier(x, yhat) = U.cobarrier(x, yhat) + ∑ rest[k].cobarrier(x, yhat)</code></li><li><code>slack(x, y) = max(U.slack(x, y), max(rest[k].slack(x, y) for k))</code></li></ul><p>This lets you compose constraints in a natural way: the resulting domain equals <code>U ∩ V₁ ∩ V₂ ∩ ...</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Intersect two domains
U = convex_Euclidian_power(Float64; idx=[1, 2+dim], p = x-&gt;2)
V = convex_Euclidian_power(Float64; idx=vcat(2:1+dim, 3+dim), p = x-&gt;p)
Q = U ∩ V  # same as intersect(U, V)

# Intersect three or more domains
W = convex_linear(Float64; A = x-&gt;A_matrix, b = x-&gt;b_vector)
Q3 = U ∩ V ∩ W  # same as intersect(U, V, W)

# Works with single domain (returns it unchanged)
Q1 = intersect(U)  # effectively returns U</code></pre><p>See also: <a href="#MultiGridBarrier.convex_piecewise-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>convex_piecewise</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/AlgebraicMultiGridBarrier.jl#L316-L346">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.amg-Union{Tuple{Type{Geometry}}, Tuple{Geometry}, Tuple{M}, Tuple{T}} where {T, M, Geometry}" href="#MultiGridBarrier.amg-Union{Tuple{Type{Geometry}}, Tuple{Geometry}, Tuple{M}, Tuple{T}} where {T, M, Geometry}"><code>MultiGridBarrier.amg</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function amg(::Type{Geometry};
    x::Matrix{T},
    w::Vector{T},
    state_variables::Matrix{Symbol},
    D::Matrix{Symbol},
    subspaces::Dict{Symbol,Vector{M}},
    operators::Dict{Symbol,M},
    refine::Vector{M},
    coarsen::Vector{M},
    full_space=:full,
    id_operator=:id,
    feasibility_slack=:feasibility_slack,
    generate_feasibility=true) where {T,M,Geometry}</code></pre><p>Construct an <code>AMG</code> object for use with the <code>amgb</code> solver. In many cases, this constructor is not called directly by the user. For 1d and 2d finite elements, use the <code>fem1d()</code> or <code>fem2d()</code>. For 1d and 2d spectral elements, use  <code>spectral1d()</code> or <code>spectral2d()</code>. You use <code>amg()</code> directly if you are implementing your own function spaces.</p><p>The <code>AMG</code> object shall represent all <code>L</code> grid levels of the multigrid hierarchy. Parameters are:</p><ul><li><code>x</code>: the vertices of the fine grid.</li><li><code>w</code>: the quadrature weights for the fine grid.</li><li><code>state_variables</code>: a matrix of symbols. The first column indicates the names of the state vectors or functions, and the second column indicates the names of the corresponding subspaces. A typical example is: <code>state_variables = [:u :dirichlet; :s :full]</code>. This would define the solution as being functions named u(x) and s(x). The u function would lie in the space <code>:dirichlet</code>, presumably consisting of functions with homogeneous Dirichlet conditions. The s function would lie in the space <code>:full</code>, presumably being the full function space, without boundary conditions.</li><li><code>D</code>: a matrix of symbols. The first column indicates the names of various state variables, and the second column indicates the corresponding differentiation operator(s). For example: <code>D = [:u :id ; :u :dx ; :s :id]</code>. This would indicate that the barrier should be called as <code>F(x,y)</code> with <code>y = [u,ux,s]</code>, where <code>ux</code> denotes the derivative of <code>u</code> with respect to the space variable <code>x</code>.</li><li><code>subspaces</code>: a <code>Dict</code> mapping each subspace symbol to an array of <code>L</code> matrices, e.g. for each <code>l</code>, <code>subspaces[:dirichlet][l]</code> is a matrix whose columns span the homogeneous Dirichlet subspace of grid level <code>l</code>.</li><li><code>operators</code>: a <code>Dict</code> mapping each differential operator symbol to a matrix, e.g. <code>operators[:id]</code> is an identity matrix, while <code>operators[:dx]</code> is a numerical differentiation matrix, on the fine grid level <code>L</code>.</li><li><code>refine</code>: an array of length <code>L</code> of matrices. For each <code>l</code>, <code>refine[l]</code> interpolates from grid level <code>l</code> to grid level <code>l+1</code>. <code>refine[L]</code> should be the identity, and <code>coarsen[l]*refine[l]</code> should be the identity.</li><li><code>coarsen</code>: an array of length <code>L</code> of matrices. For each <code>l</code>, <code>coarsen[l]</code> interpolates or projects from grid level <code>l+1</code> to grid level <code>l</code>. <code>coarsen[L]</code> should be the identity.</li><li><code>generate_feasibility</code>: if true, <code>amg()</code> returns a pair <code>M</code> of <code>AMG</code> objects. <code>M[1]</code> is an <code>AMG</code> object to be used for the main optimization problem, while <code>M[2]</code> is an <code>AMG</code> object for the preliminary feasibility sub problem. In this case, <code>amg()</code> also needs to be provided with the following additional information: <code>feasibility_slack</code> is the name of a special slack variable that must be unique to the feasibility subproblem (default: <code>:feasibility_slack</code>); <code>full_space</code> is the name of the &quot;full&quot; vector space (i.e. no boundary conditions, default: <code>:full</code>); and <code>id_operator</code> is the name of the identity operator (default: <code>:id</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/AlgebraicMultiGridBarrier.jl#L125-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.amg_construct-Union{Tuple{T}, Tuple{Type{T}, Type{FEM1D}}} where T" href="#MultiGridBarrier.amg_construct-Union{Tuple{T}, Tuple{Type{T}, Type{FEM1D}}} where T"><code>MultiGridBarrier.amg_construct</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">amg_construct(::Type{T},::Type{FEM1D};rest...) where {T} = fem1d(T;rest...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/fem1d.jl#L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.amg_construct-Union{Tuple{T}, Tuple{Type{T}, Type{FEM2D}}} where T" href="#MultiGridBarrier.amg_construct-Union{Tuple{T}, Tuple{Type{T}, Type{FEM2D}}} where T"><code>MultiGridBarrier.amg_construct</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">amg_construct(::Type{T},::Type{FEM2D};rest...) where {T} = fem2d(T;rest...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/fem2d.jl#L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.amg_construct-Union{Tuple{T}, Tuple{Type{T}, Type{SPECTRAL1D}}} where T" href="#MultiGridBarrier.amg_construct-Union{Tuple{T}, Tuple{Type{T}, Type{SPECTRAL1D}}} where T"><code>MultiGridBarrier.amg_construct</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">amg_construct(::Type{T},::Type{SPECTRAL1D};rest...) where {T} = spectral1d(T;rest...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/spectral1d.jl#L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.amg_construct-Union{Tuple{T}, Tuple{Type{T}, Type{SPECTRAL2D}}} where T" href="#MultiGridBarrier.amg_construct-Union{Tuple{T}, Tuple{Type{T}, Type{SPECTRAL2D}}} where T"><code>MultiGridBarrier.amg_construct</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">amg_construct(::Type{T},::Type{SPECTRAL2D};rest...) where {T} = spectral2d(T;rest...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/spectral2d.jl#L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.amg_dim-Tuple{Type{FEM1D}}" href="#MultiGridBarrier.amg_dim-Tuple{Type{FEM1D}}"><code>MultiGridBarrier.amg_dim</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">amg_dim(::Type{FEM1D}) = 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/fem1d.jl#L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.amg_dim-Tuple{Type{FEM2D}}" href="#MultiGridBarrier.amg_dim-Tuple{Type{FEM2D}}"><code>MultiGridBarrier.amg_dim</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">amg_dim(::Type{FEM2D}) = 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/fem2d.jl#L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.amg_dim-Tuple{Type{SPECTRAL1D}}" href="#MultiGridBarrier.amg_dim-Tuple{Type{SPECTRAL1D}}"><code>MultiGridBarrier.amg_dim</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">amg_dim(::Type{SPECTRAL1D}) = 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/spectral1d.jl#L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.amg_dim-Tuple{Type{SPECTRAL2D}}" href="#MultiGridBarrier.amg_dim-Tuple{Type{SPECTRAL2D}}"><code>MultiGridBarrier.amg_dim</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">amg_dim(::Type{SPECTRAL2D}) = 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/spectral2d.jl#L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.amg_plot-Union{Tuple{Mat}, Tuple{T}, Tuple{AMG{T, Mat, FEM1D}, Vector{T}}} where {T, Mat}" href="#MultiGridBarrier.amg_plot-Union{Tuple{Mat}, Tuple{T}, Tuple{AMG{T, Mat, FEM1D}, Vector{T}}} where {T, Mat}"><code>MultiGridBarrier.amg_plot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">amg_plot(M::AMG{T,Mat,FEM1D}, z::Vector{T}) where {T,Mat} = plot(M.x,z)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/fem1d.jl#L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.amg_plot-Union{Tuple{Mat}, Tuple{T}, Tuple{AMG{T, Mat, FEM2D}, Array{T}}} where {T, Mat}" href="#MultiGridBarrier.amg_plot-Union{Tuple{Mat}, Tuple{T}, Tuple{AMG{T, Mat, FEM2D}, Array{T}}} where {T, Mat}"><code>MultiGridBarrier.amg_plot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">amg_plot(M::AMG{T, Mat,FEM2D}, z::Array{T}) where {T,Mat}</code></pre><p>Plot a piecewise quadratic (plus cubic &quot;bubble&quot;) solution <code>z</code> on the given mesh. Note that the solution is drawn as (linear) triangles, even though the underlying solution is piecewise cubic. To obtain a more accurate depiction, especially when the mesh is coarse, it would be preferable to apply a few levels of additional subdivision, so as to capture the curve of the quadratic basis functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/fem2d.jl#L170-L174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.amg_plot-Union{Tuple{Mat}, Tuple{T}, Tuple{AMG{T, Mat, SPECTRAL1D}, Any}} where {T, Mat}" href="#MultiGridBarrier.amg_plot-Union{Tuple{Mat}, Tuple{T}, Tuple{AMG{T, Mat, SPECTRAL1D}, Any}} where {T, Mat}"><code>MultiGridBarrier.amg_plot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">amg_plot(M::AMG{T,Mat,SPECTRAL1D},y;x=Array(-1:T(0.01):1),rest...) where {T,Mat}</code></pre><p>Plot a solution using <code>pyplot</code>.</p><ul><li><code>M</code>: a mesh.</li><li><code>x</code>: x values where the solution should be evaluated and plotted.</li><li><code>y</code>: the solution, to be interpolated at the given <code>x</code> values via <code>spectral1d_interp</code>.</li><li><code>rest...</code> parameters are passed directly to <code>pyplot.plot</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/spectral1d.jl#L176-L185">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.amg_plot-Union{Tuple{Mat}, Tuple{T}, Tuple{AMG{T, Mat, SPECTRAL2D}, Vector{T}}} where {T, Mat}" href="#MultiGridBarrier.amg_plot-Union{Tuple{Mat}, Tuple{T}, Tuple{AMG{T, Mat, SPECTRAL2D}, Vector{T}}} where {T, Mat}"><code>MultiGridBarrier.amg_plot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">amg_plot(M::AMG{T,Mat,SPECTRAL2D},z::Array{T,1};x=-1:T(0.01):1,y=-1:T(0.01):1,rest...) where {T,Mat}</code></pre><p>Plot a 2d solution.</p><ul><li><code>M</code> a 2d mesh.</li><li><code>x</code>, <code>y</code> should be ranges like -1:0.01:1.</li><li><code>z</code> the solution to plot.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/spectral2d.jl#L119-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.amgb-Union{Tuple{Geometry}, Tuple{Mat}, Tuple{T}, Tuple{Tuple{AMG{T, Mat, Geometry}, AMG{T, Mat, Geometry}}, Matrix{T}, Matrix{T}, Convex}} where {T, Mat, Geometry}" href="#MultiGridBarrier.amgb-Union{Tuple{Geometry}, Tuple{Mat}, Tuple{T}, Tuple{Tuple{AMG{T, Mat, Geometry}, AMG{T, Mat, Geometry}}, Matrix{T}, Matrix{T}, Convex}} where {T, Mat, Geometry}"><code>MultiGridBarrier.amgb</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">amgb(M::Tuple{AMG{T,Mat,Geometry}, AMG{T,Mat,Geometry}},
     f::Union{Function, Matrix{T}},
     g::Union{Function, Matrix{T}},
     Q::Convex;
     x::Matrix{T}=M[1].x,
     t=T(0.1),
     t_feasibility=t,
     verbose=true,
     return_details=false,
     stopping_criterion,
     line_search,
     finalize,
     logfile=devnull,
     rest...) where {T,Mat,Geometry}</code></pre><p>Algebraic MultiGrid Barrier (AMGB) driver.</p><p>High-level wrapper around <a href="#MultiGridBarrier.amgb_core-Union{Tuple{Geometry}, Tuple{Mat}, Tuple{T}, Tuple{Barrier, AMG{T, Mat, Geometry}, Matrix{T}, Vector{T}, Matrix{T}}} where {T, Mat, Geometry}"><code>amgb_core</code></a> that:</p><ol><li>Builds the initial guess <code>z0</code> and cost functional <code>c0</code> from <code>g</code> and <code>f</code>.</li><li>Solves a feasibility subproblem on <code>M[2]</code> if needed.</li><li>Solves the main optimization problem on <code>M[1]</code>.</li><li>Optionally reports progress and logs diagnostics.</li></ol><p><strong>Arguments</strong></p><ul><li><code>M</code>: a tuple <code>(M_main, M_feas)</code> of <code>AMG</code> hierarchies.<ul><li><code>M[1]</code> encodes the main problem.</li><li><code>M[2]</code> encodes the feasibility subproblem.</li></ul></li><li><code>f</code>: objective functional to minimize. May be a function (evaluated at rows of <code>x</code>) or a precomputed matrix.</li><li><code>g</code>: boundary/initial data. May be a function (evaluated at rows of <code>x</code>) or a precomputed matrix.</li><li><code>Q</code>: convex domain describing admissible states.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>x</code>: mesh/sample points where <code>f</code> and <code>g</code> are evaluated when they are functions (default: <code>M[1].x</code>).</li><li><code>t</code>: initial barrier parameter for the main solve.</li><li><code>t_feasibility</code>: initial barrier parameter for the feasibility solve.</li><li><code>verbose</code>: show a progress bar if <code>true</code>.</li><li><code>return_details</code>: if <code>true</code>, return detailed results from both solves.</li><li><code>stopping_criterion</code>: stopping criterion for the Newton solver (has a default based on mesh parameters).</li><li><code>line_search</code>: line search strategy (default: <code>linesearch_backtracking</code>).</li><li><code>finalize</code>: finalization stopping criterion (default: <code>stopping_exact(T(0.1))</code>).</li><li><code>logfile</code>: IO stream for logging (default: <code>devnull</code>).</li><li><code>rest...</code>: additional keyword arguments forwarded to <a href="#MultiGridBarrier.amgb_core-Union{Tuple{Geometry}, Tuple{Mat}, Tuple{T}, Tuple{Barrier, AMG{T, Mat, Geometry}, Matrix{T}, Vector{T}, Matrix{T}}} where {T, Mat, Geometry}"><code>amgb_core</code></a> (e.g., tolerances, other options).</li></ul><p><strong>Initialization</strong></p><p>If <code>f</code>/<code>g</code> are functions, <code>c0</code> and <code>z0</code> are built by evaluating on each row of <code>x</code>:</p><pre><code class="language-julia hljs">m = size(M[1].x, 1)
for k in 1:m
    z0[k, :] .= g(x[k, :])
    c0[k, :] .= f(x[k, :])
end</code></pre><p>If <code>f/g</code> are matrices, they are used directly (their shapes must match the discretization implied by <code>M[1]</code>).</p><p><strong>Feasibility handling</strong></p><p>The routine checks barrier admissibility. If any point is infeasible under <code>Q</code>, a feasibility problem is automatically constructed and solved on <code>M[2]</code> (using an internal slack augmentation and an early-stop criterion). If feasibility is already satisfied, this step is skipped.</p><p><strong>Returns</strong></p><p>If <code>return_details == false</code> (default):</p><ul><li>returns <code>z</code>, an <code>m × n</code> matrix, where <code>m = size(x,1)</code> and <code>n</code> is the number of state variables in the discretization.</li></ul><p>If <code>return_details == true</code>:</p><ul><li>returns a named tuple <code>(z, SOL_feasibility, SOL_main,log)</code> where <code>SOL_feasibility</code> is nothing if no feasibility step was needed. The <code>SOL_*</code> objects are the detailed results returned by <code>amgb_core</code>. <code>log</code> is a string log of the iterations, useful for debugging purposes.</li></ul><p><strong>Errors</strong></p><p>Throws AMGBConvergenceFailure if either the feasibility or main solve fails to converge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/AlgebraicMultiGridBarrier.jl#L1011-L1093">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.amgb_core-Union{Tuple{Geometry}, Tuple{Mat}, Tuple{T}, Tuple{Barrier, AMG{T, Mat, Geometry}, Matrix{T}, Vector{T}, Matrix{T}}} where {T, Mat, Geometry}" href="#MultiGridBarrier.amgb_core-Union{Tuple{Geometry}, Tuple{Mat}, Tuple{T}, Tuple{Barrier, AMG{T, Mat, Geometry}, Matrix{T}, Vector{T}, Matrix{T}}} where {T, Mat, Geometry}"><code>MultiGridBarrier.amgb_core</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">amgb_core(B::Barrier,
          M::AMG{T,Mat,Geometry},
          x::Matrix{T},
          z::Array{T,1},
          c::Array{T,2};
          tol,
          t,
          maxit,
          kappa,
          early_stop,
          progress,
          c0,
          max_newton,
          finalize,
          printlog,
          args...) where {T,Mat,Geometry}</code></pre><p>Algebraic MultiGrid Barrier (AMGB) method.</p><p><strong>Arguments</strong></p><ul><li><code>B</code> : a <code>Barrier</code> object.</li><li><code>M</code> : an <code>AMG</code> hierarchy.</li><li><code>x</code> : a matrix with the same number of rows as <code>M.x</code>. Typically <code>x = M.x</code>.</li><li><code>z</code> : initial iterate, which must be admissible (<code>B.f0(z) &lt; ∞</code>).</li><li><code>c</code> : objective functional to minimize. Concretely, the method minimizes the integral of <code>c .* (D*z)</code> (with <code>D</code> the differential operator in <code>M</code>), subject to barrier feasibility.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>tol</code> : stopping tolerance; the method stops once <code>1/t &lt; tol</code>.</li><li><code>t</code> : initial barrier parameter.</li><li><code>maxit</code> : maximum number of barrier iterations.</li><li><code>kappa</code> : initial step size multiplier for <code>t</code>. Adapted dynamically but never exceeds this initial value.</li><li><code>early_stop</code> : function <code>z -&gt; Bool</code>; if <code>true</code>, the iteration halts early (e.g. in feasibility mode).</li><li><code>progress</code> : callback receiving a scalar in <code>[0,1]</code> for reporting progress (default: no-op).</li><li><code>c0</code> : base offset added to the objective (<code>c0 + t*c</code>).</li><li><code>max_newton</code> : maximum Newton iterations per inner solve (default depends on problem data).</li><li><code>finalize</code> : finalization stopping criterion for the last Newton solve.</li><li><code>printlog</code> : logging function.</li><li><code>args...</code> : extra keyword arguments passed to inner routines (<code>amgb_phase1</code>, <code>amgb_step</code>).</li></ul><p><strong>Returns</strong></p><p>A named tuple <code>SOL</code> with fields:</p><ul><li><code>z</code> : the computed solution.</li><li><code>z_unfinalized</code>: the solution before finalization.</li><li><code>c</code> : the input functional.</li><li><code>its</code> : iteration counts across levels and barrier steps.</li><li><code>ts</code> : sequence of barrier parameters <code>t</code>.</li><li><code>kappas</code> : step size multipliers used.</li><li><code>times</code> : wall-clock timestamps of iterations.</li><li><code>M</code> : the AMG hierarchy.</li><li><code>t_begin</code>, <code>t_end</code>, <code>t_elapsed</code> : timing information.</li><li><code>passed</code> : whether phase 1 succeeded.</li><li><code>c_dot_Dz</code> : recorded values of ⟨c, D*z⟩ at each iteration.</li></ul><p>Throws <code>AMGBConvergenceFailure</code> if convergence is not achieved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/AlgebraicMultiGridBarrier.jl#L875-L930">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.amgb_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#MultiGridBarrier.amgb_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.amgb_solve</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">amgb_solve(::Type{T}=Float64;
          L::Integer=2,
          n=nothing,
          method=FEM1D,
          K=nothing,
          state_variables::Matrix{Symbol} = [:u :dirichlet;
                                             :s :full],
          dim::Integer = amg_dim(method),
          D::Matrix{Symbol} = default_D[dim],
          M = amg_construct(T, method;
                            L=L, n=n, K=K,
                            state_variables=state_variables, D=D),
          p::T = T(1.0),
          g::Union{Function, Matrix{T}} = default_g(T)[dim],
          f::Union{Function, Matrix{T}} = default_f(T)[dim],
          Q::Convex{T} = convex_Euclidian_power(T, idx=2:dim+2, p=x-&gt;p),
          show=true,
          return_details=false,
          rest...) where {T}</code></pre><p>Convenience interface to the <strong>MultiGridBarrier</strong> module.   This function builds a discretization and calls <code>amgb</code> with the appropriate defaults.   For a quick start on p-Laplace problems, simply call:</p><pre><code class="nohighlight hljs">amg_solve()</code></pre><p><strong>Keyword arguments</strong></p><ul><li><code>L=2</code> : number of times to subdivide the base mesh.</li><li><code>n</code> : number of quadrature nodes along each axis (only for spectral methods). If set, <code>L</code> is ignored.</li><li><code>method=FEM1D</code> : discretization method. One of <code>FEM1D</code>, <code>FEM2D</code>, <code>SPECTRAL1D</code>, <code>SPECTRAL2D</code>.</li><li><code>K</code> : initial mesh (only relevant for <code>FEM2D</code>).</li><li><code>state_variables</code> : symbolic description of solution components (default <code>[:u :dirichlet; :s :full]</code>).</li><li><code>dim</code> : problem dimension (1 or 2). Used only to determine defaults for <code>f</code>, <code>g</code>, <code>Q</code>, and <code>D</code>.</li><li><code>D</code> : differential operators (default depends on <code>dim</code>).</li><li><code>M</code> : AMG hierarchy, constructed automatically unless supplied explicitly.</li><li><code>p=1.0</code> : parameter for the p-Laplace operator (used only if <code>Q</code> is not overridden).</li><li><code>g</code> : boundary conditions. Either a function (evaluated at mesh points) or a matrix. Defaults depend on <code>dim</code>.</li><li><code>f</code> : forcing / cost functional. Either a function (evaluated at mesh points) or a matrix. Defaults depend on <code>dim</code>.</li><li><code>Q</code> : convex domain for the variational problem. Defaults to <code>convex_Euclidian_power</code>, matching p-Laplace problems.</li><li><code>show=true</code> : if <code>true</code>, plot the computed solution.</li><li><code>return_details=false</code> :<ul><li>if <code>false</code>, return the solution <code>z</code> as a matrix.</li><li>if <code>true</code>, return the detailed named tuple from <code>amgb</code>.</li></ul></li><li><code>rest...</code> : any further keyword arguments are forwarded to <code>amgb</code>.</li></ul><p><strong>Defaults</strong></p><p>The defaults for <code>f</code>, <code>g</code>, and <code>D</code> depend on the spatial dimension:</p><table><tr><th style="text-align: left"><code>dim</code></th><th style="text-align: left">1</th><th style="text-align: left">2</th></tr><tr><td style="text-align: left"><code>f</code></td><td style="text-align: left"><code>(x)-&gt;T[0.5,0.0,1.0]</code></td><td style="text-align: left"><code>(x)-&gt;T[0.5,0.0,0.0,1.0]</code></td></tr><tr><td style="text-align: left"><code>g</code></td><td style="text-align: left"><code>(x)-&gt;T[x[1],2]</code></td><td style="text-align: left"><code>(x)-&gt;T[x[1]^2+x[2]^2,100.0]</code></td></tr><tr><td style="text-align: left"><code>D</code></td><td style="text-align: left"><code>[:u :id</code></td><td style="text-align: left"><code>[:u :id</code></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><code>:u :dx</code></td><td style="text-align: left"><code>:u :dx</code></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><code>:s :id]</code></td><td style="text-align: left"><code>:u :dy</code></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><code>:s :id]</code></td></tr></table><p><strong>Returns</strong></p><ul><li>If <code>return_details=false</code> (default): the solution <code>z</code> (matrix).</li><li>If <code>return_details=true</code>: the full solution object from <code>amgb</code>, which includes fields like <code>z</code>, <code>SOL_feasibility</code>, and <code>SOL_main</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/AlgebraicMultiGridBarrier.jl#L1198-L1261">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.apply_D-Union{Tuple{T}, Tuple{Any, Vector{T}}} where T" href="#MultiGridBarrier.apply_D-Union{Tuple{T}, Tuple{Any, Vector{T}}} where T"><code>MultiGridBarrier.apply_D</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_D(D,z::Vector{T}) where {T} = hcat([D[k]*z for k in 1:length(D)]...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/AlgebraicMultiGridBarrier.jl#L349">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.barrier-Tuple{Any}" href="#MultiGridBarrier.barrier-Tuple{Any}"><code>MultiGridBarrier.barrier</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function barrier(F;
    F1=(x,y)-&gt;ForwardDiff.gradient(z-&gt;F(x,z),y),
    F2=(x,y)-&gt;ForwardDiff.hessian(z-&gt;F(x,z),y))</code></pre><p>Constructor for barriers.</p><ul><li><code>F</code> is the actual barrier function. It should take parameters <code>(x,y)</code>.</li><li><code>F1</code> is the gradient of <code>F</code> with respect to <code>y</code>.</li><li><code>F2</code> is the Hessian of <code>F</code> with  respect to <code>y</code>.</li></ul><p>By default, <code>F1</code> and <code>F2</code> are automatically generated by the module <code>ForwardDiff</code>.</p><p>A more specific description of the Barrier object is as follows. The function <code>Barrier.f0</code> has parameters:</p><pre><code class="nohighlight hljs">function Barrier.f0(z,x,w,c,R,D,z0)</code></pre><p>Here, <code>R</code> is a matrix and <code>D</code> is an array of matrices; <code>x</code> is a matrix of quadrature nodes with weights <code>w</code>, and <code>c</code> is a matrix describing the functional we seek to minimize. The value of <code>Barrier.f0</code> is given by:</p><pre><code class="nohighlight hljs">        p = length(w)
        n = length(D)
        Rz = z0+R*z
        Dz = hcat([D[k]*Rz for k=1:n]...)
        y = [F(x[k,:],Dz[k,:]) for k=1:p]
        dot(w,y)+sum([dot(w.*c[:,k],Dz[:,k]) for k=1:n])</code></pre><p>Thus, <code>Barrier.f0</code> can be regarded as a quadrature approximation of the integral</p><p class="math-container">\[\int_{\Omega} \left(\sum_{k=1}^nc_k(x)v_k(x)\right) + F(x,v_1(x),\ldots,v_n(x)) \, dx \text{ where } v_k = D_k(z_0 + Rz).\]</p><p>Functions <code>Barrier.f1</code> and <code>Barrier.f2</code> are the gradient and Hessian, respectively, of <code>Barrier.f0</code>, with respect to the <code>z</code> parameter. If the underlying matrices are sparse, then sparse arithmetic is used for <code>Barrier.f2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/AlgebraicMultiGridBarrier.jl#L352-L384">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.convex_Euclidian_power-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#MultiGridBarrier.convex_Euclidian_power-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.convex_Euclidian_power</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function convex_Euclidian_power(::Type{T}=Float64;idx=Colon(),A::Function=(x)-&gt;I,b::Function=(x)-&gt;T(0),p::Function=x-&gt;T(2)) where {T}</code></pre><p>Generate a <code>Convex</code> object corresponding to the convex set defined by <span>$z[end] \geq \|z[1:end-1]\|_2^p$</span> where <span>$z = A(x)*y[idx] .+ b(x)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/AlgebraicMultiGridBarrier.jl#L208-L212">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.convex_linear-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#MultiGridBarrier.convex_linear-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.convex_linear</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function convex_linear(::Type{T}=Float64;idx=Colon(),A::Function=(x)-&gt;I,b::Function=(x)-&gt;T(0)) where {T}</code></pre><p>Generate a <code>Convex</code> structure corresponding to the convex domain A(x,k)*y[idx] .+ b(x,k) ≤ 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/AlgebraicMultiGridBarrier.jl#L193-L197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.convex_piecewise-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#MultiGridBarrier.convex_piecewise-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.convex_piecewise</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convex_piecewise(::Type{T}=Float64; Q::Vector{Convex{T}}, select::Function=(tr=fill(true,length(Q));x-&gt;tr)) where {T}</code></pre><p>Build a <code>Convex{T}</code> that combines multiple convex domains with spatial selectivity.</p><p><strong>Arguments</strong></p><ul><li><code>Q::Vector{Convex{T}}</code>: a vector of convex pieces to be combined.</li><li><code>select::Function</code>: a function <code>x -&gt; Vector{Bool}</code> indicating which pieces are active at <code>x</code>. Default: all pieces active everywhere (equivalent to intersection).</li></ul><p><strong>Semantics</strong></p><p>For <code>sel = select(x)</code>, the resulting convex domain has:</p><ul><li><code>barrier(x, y) = ∑(Q[k].barrier(x, y) for k where sel[k])</code></li><li><code>cobarrier(x, yhat) = ∑(Q[k].cobarrier(x, yhat) for k where sel[k])</code>  </li><li><code>slack(x, y) = max(Q[k].slack(x, y) for k where sel[k])</code></li></ul><p>The slack is the maximum over active pieces, ensuring a single slack value suffices for feasibility at each <code>x</code>.</p><p><strong>Use cases</strong></p><ol><li><strong>Intersections</strong> (default): All pieces active everywhere creates <code>Q₁ ∩ Q₂ ∩ ...</code></li><li><strong>Spatial switching</strong>: Different constraints in different regions</li><li><strong>Conditional constraints</strong>: Activate constraints based on solution state</li></ol><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Intersection (using default select)
U = convex_Euclidian_power(Float64; idx=[1, 3], p = x-&gt;2)
V = convex_linear(Float64; A = x-&gt;A_matrix, b = x-&gt;b_vector)
Qint = convex_piecewise(Float64; Q = [U, V])  # U ∩ V everywhere

# Region-dependent constraints
Q_left = convex_Euclidian_power(Float64; p = x-&gt;1.5)  
Q_right = convex_Euclidian_power(Float64; p = x-&gt;2.0)
select(x) = [x[1] &lt; 0, x[1] &gt;= 0]  # left half vs right half
Qreg = convex_piecewise(Float64; Q = [Q_left, Q_right], select = select)

# Conditional activation
Q_base = convex_linear(Float64; A = x-&gt;I, b = x-&gt;-ones(2))
Q_extra = convex_Euclidian_power(Float64; p = x-&gt;3)
select(x) = [true, norm(x) &gt; 0.5]  # extra constraint outside radius 0.5
Qcond = convex_piecewise(Float64; Q = [Q_base, Q_extra], select = select)</code></pre><p>See also: <a href="#Base.intersect-Union{Tuple{T}, Tuple{Convex{T}, Vararg{Any}}} where T"><code>Base.intersect</code></a>, <a href="#MultiGridBarrier.convex_linear-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>convex_linear</code></a>, <a href="#MultiGridBarrier.convex_Euclidian_power-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>convex_Euclidian_power</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/AlgebraicMultiGridBarrier.jl#L235-L280">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.fem1d-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#MultiGridBarrier.fem1d-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.fem1d</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fem1d(::Type{T}=Float64; L::Int=4, n=nothing, K=nothing,
                state_variables = [:u :dirichlet
                                   :s :full],
                D = [:u :id
                     :u :dx
                     :s :id],
                generate_feasibility=true) where {T}</code></pre><p>Construct an <code>AMG</code> object for a 1d piecewise linear finite element grid. The interval is [-1,1]. Parameters are:</p><ul><li><code>L</code>: divide the interval into 2^L subintervals (L for Levels).</li><li><code>state_variables</code>: the &quot;state vector&quot; consists of functions, by default this is <code>u(x)</code> and <code>s(x)</code>, on the finite element grid.</li><li><code>D</code>: the set of differential operators. The barrier function <code>F</code> will eventually be called with the parameters <code>F(x,Dz)</code>, where <code>z</code> is the state vector. By default, this results in <code>F(x,u,ux,s)</code>, where <code>ux</code> is the derivative of <code>u</code>.</li><li><code>generate_feasibility</code>: if <code>true</code>, returns a pair <code>M</code> of <code>AMG</code> objects. <code>M[1]</code> is the <code>AMG</code> object for the main problem, and <code>M[2]</code> is for the feasibility subproblem.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/fem1d.jl#L13-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.fem1d_interp-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, T}} where T" href="#MultiGridBarrier.fem1d_interp-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, T}} where T"><code>MultiGridBarrier.fem1d_interp</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fem1d_interp(x::Vector{T},
                  y::Vector{T},
                  t::T) where{T}</code></pre><p>Interpolate a 1d piecewise linear function at the given <code>t</code> value. If <code>u(xi)</code> is the piecewise linear function such that <code>u(x[k])=y[k]</code> then this function returns <code>u(t)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/fem1d.jl#L75-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.fem1d_interp-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector{T}}} where T" href="#MultiGridBarrier.fem1d_interp-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector{T}}} where T"><code>MultiGridBarrier.fem1d_interp</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fem1d_interp(x::Vector{T},
                  y::Vector{T},
                  t::Vector{T}) where{T}</code></pre><p>Returns <code>[fem1d_interp(x,y,t[k]) for k=1:length(t)]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/fem1d.jl#L104-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.fem1d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#MultiGridBarrier.fem1d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.fem1d_solve</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fem1d_solve(::Type{T}=Float64;rest...) where {T} = amg_solve(T;method=FEM1D,rest...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/fem1d.jl#L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.fem2d-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#MultiGridBarrier.fem2d-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.fem2d</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fem2d(::Type{T}=Float64; L::Int=2, n=nothing,
                K=T[-1 -1;1 -1;-1 1;1 -1;1 1;-1 1],
                state_variables = [:u :dirichlet
                                   :s :full],
                D = [:u :id
                     :u :dx
                     :u :dy
                     :s :id],
                generate_feasibility=true) where {T}</code></pre><p>Construct an <code>AMG</code> object for a 2d finite element grid on the domain <code>K</code> with piecewise quadratic elements. Parameters are:</p><ul><li><code>K</code>: a triangular mesh. If there are <code>n</code> triangles, then <code>K</code> should be a 3n by 2 matrix of vertices. The first column of <code>K</code> represents <code>x</code> coordinates, the second column represents <code>y</code> coordinates.</li><li><code>L</code>: number of refinement levels (L for Levels).</li><li><code>state_variables</code>: the &quot;state vector&quot; consists of functions, by default this is <code>u(x)</code> and <code>s(x)</code>, on the finite element grid.</li><li><code>D</code>: the set of differential operators. The barrier function <code>F</code> will eventually be called with the parameters <code>F(x,y,Dz)</code>, where <code>z</code> is the state vector. By default, this results in <code>F(x,y,u,ux,uy,s)</code>, where <code>(ux,uy)</code> is the gradient of <code>u</code>.</li><li><code>generate_feasibility</code>: if <code>true</code>, returns a pair <code>M</code> of <code>AMG</code> objects. <code>M[1]</code> is the <code>AMG</code> object for the main problem, and <code>M[2]</code> is for the feasibility subproblem.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/fem2d.jl#L93-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.fem2d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#MultiGridBarrier.fem2d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.fem2d_solve</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fem2d_solve(::Type{T}=Float64;rest...) where {T} = amgb_solve(T;method=FEM2D,rest...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/fem2d.jl#L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.illinois-Union{Tuple{T}, Tuple{Any, T, T}} where T" href="#MultiGridBarrier.illinois-Union{Tuple{T}, Tuple{Any, T, T}} where T"><code>MultiGridBarrier.illinois</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">illinois(f,a::T,b::T;fa=f(a),fb=f(b),maxit=10000) where {T}</code></pre><p>Find a root of <code>f</code> between <code>a</code> and <code>b</code> using the Illinois algorithm. If <code>f(a)*f(b)&gt;=0</code>, returns <code>b</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/AlgebraicMultiGridBarrier.jl#L566-L570">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.newton-Union{Tuple{Mat}, Tuple{T}, Tuple{Type{Mat}, Function, Function, Function, Vector{T}}} where {T, Mat}" href="#MultiGridBarrier.newton-Union{Tuple{Mat}, Tuple{T}, Tuple{Type{Mat}, Function, Function, Function, Vector{T}}} where {T, Mat}"><code>MultiGridBarrier.newton</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">newton(::Type{Mat},
       F0::Function,
       F1::Function,
       F2::Function,
       x::Array{T,1};
       maxit=10000,
       stopping_criterion=stopping_exact(T(0.1)),
       line_search=linesearch_illinois(T),
       printlog) where {T,Mat}</code></pre><p>Damped Newton iteration for unconstrained minimization of a differentiable function.</p><p><strong>Arguments</strong></p><ul><li><code>F0</code> : objective function.</li><li><code>F1</code> : gradient of <code>F0</code>.</li><li><code>F2</code> : Hessian of <code>F0</code> (must return a matrix of type <code>Mat</code>).</li><li><code>x</code>  : starting point (vector of type <code>T</code>).</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>maxit</code> : maximum number of iterations (default: 10,000).</li><li><code>stopping_criterion</code> : user-defined predicate deciding when to stop. The default is <code>stopping_exact(T(0.1))</code> which checks whether the objective decreased and the gradient norm fell sufficiently.</li><li><code>line_search</code> : line search strategy (default: <code>linesearch_illinois</code>). The alternative is <code>linesearch_backtracking</code>.</li><li><code>printlog</code> : logging function.</li></ul><p><strong>Notes</strong></p><p>The iteration stops if the <code>stopping_criterion</code> is satisfied or if <code>maxit</code> iterations are exceeded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/AlgebraicMultiGridBarrier.jl#L794-L822">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.parabolic_plot-Union{Tuple{Geometry}, Tuple{Mat}, Tuple{T}, Tuple{Any, AMG{T, Mat, Geometry}, Matrix{T}}} where {T, Mat, Geometry}" href="#MultiGridBarrier.parabolic_plot-Union{Tuple{Geometry}, Tuple{Mat}, Tuple{T}, Tuple{Any, AMG{T, Mat, Geometry}, Matrix{T}}} where {T, Mat, Geometry}"><code>MultiGridBarrier.parabolic_plot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">parabolic_plot(method,M::AMG{T, Mat,Geometry}, U::Matrix{T};
    interval=200, embed_limit=200.0,
    printer=(animation)-&gt;display(&quot;text/html&quot;, animation.to_html5_video(embed_limit=embed_limit))) where {T,Mat,Geometry}</code></pre><p>Animate the solution of the parabolic problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/Parabolic.jl#L141-L147">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.parabolic_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#MultiGridBarrier.parabolic_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.parabolic_solve</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">parabolic_solve(::Type{T}=Float64;
    method = FEM2D,
    state_variables = [:u  :dirichlet
                       :s1 :full
                       :s2 :full],
    dim = amg_dim(method),
    f1 = x-&gt;T(0.5),
    f_default = default_f_parabolic[dim],
    p = T(1),
    h = T(0.2),
    f = (t,x)-&gt;f_default(h*f1(x)-x[1+dim],T(0.5),h/p),
    g = default_g_parabolic[dim],
    D = default_D_parabolic[dim],
    L = 2,
    t0 = T(0),
    t1 = T(1),
    M = amg_construct(T,method,L=L,D=D,state_variables=state_variables),
    Q = (convex_Euclidian_power(;idx=[1,2+dim],p=x-&gt;T(2)) 
        ∩ convex_Euclidian_power(;idx=vcat(2:1+dim,3+dim),p=x-&gt;p)),
    verbose = true,
    show = true,
    interval = 200,
    printer=(animation)-&gt;display(&quot;text/html&quot;, animation.to_html5_video(embed_limit=200.0)),
    rest...) where {T}</code></pre><p>Solves a parabolic (i.e. time-dependent) p-Laplace problem of the form:</p><p class="math-container">\[u_t - \nabla \cdot (\|\nabla u\|_2^{p-2}\nabla u) = -f_1.\]</p><p>We use the implicit Euler scheme <span>$u_t \approx (u_{k+1}-u_k)/h$</span> to arrive at:</p><p class="math-container">\[u_{k+1} - h\nabla \cdot (\|\nabla u_{k+1}\|_2^{p-2}\nabla u_{k+1}) = u_k-hf_1.\]</p><p>According to the calculus of variation, we look for a weak solution minimizing</p><p class="math-container">\[J(u) = \int_{\Omega}{1 \over 2} u^2 + h {1 \over p} \|\nabla u\|_2^p + (hf_1-u_k)u \, dx\]</p><p>We introduce the slack functions <span>$s_1 \geq u^2$</span> and <span>$s_2 \geq \|\nabla u\|_2^p$</span> and minimize instead</p><p class="math-container">\[\int_{\Omega} {1 \over 2}s_1 + {h \over p} s_2 + (hf_1-u_k)u \, dx.\]</p><p>The canonical form is:</p><p class="math-container">\[z = \begin{bmatrix} u \\ s_1 \\ s_2 \end{bmatrix}
\qquad
f^T = \left[hf_1-u_k,0,0,{1 \over 2},{h \over p}\right]
\qquad
Dz = \begin{bmatrix} u \\ u_x \\ u_y \\ s_1 \\ s_2 \end{bmatrix}
\qquad
g = \begin{bmatrix} g_1 \\ 0 \\ 0 \end{bmatrix}.\]</p><p>Here, <span>$g_1$</span> encodes boundary conditions for <span>$u$</span>. Then we minimize:</p><p class="math-container">\[\int_{\Omega} f^TDz\]</p><p>The named arguments <code>rest...</code> are passed verbatim to <code>amg_solve</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/Parabolic.jl#L22-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.spectral1d-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#MultiGridBarrier.spectral1d-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.spectral1d</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spectral1d(::Type{T}=Float64; n=nothing, L::Integer=2,
                K=nothing,
                state_variables = [:u :dirichlet
                                   :s :full],
                D = [:u :id
                     :u :dx
                     :s :id],
                generate_feasibility=true) where {T}</code></pre><p>Construct an <code>AMG</code> object for a 1d spectral grid of polynomials of degree <code>n-1</code>. See also <code>fem1d</code> for a description of the parameters <code>state_variables</code> and <code>D</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/spectral1d.jl#L127-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.spectral1d_interp-Union{Tuple{Mat}, Tuple{T}, Tuple{AMG{T, Mat, SPECTRAL1D}, Vector{T}, Any}} where {T, Mat}" href="#MultiGridBarrier.spectral1d_interp-Union{Tuple{Mat}, Tuple{T}, Tuple{AMG{T, Mat, SPECTRAL1D}, Vector{T}, Any}} where {T, Mat}"><code>MultiGridBarrier.spectral1d_interp</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spectral1d_interp(MM::AMG{T,Mat,SPECTRAL1D}, y::Array{T,1},x) where {T,Mat}</code></pre><p>A function to interpolate a solution <code>y</code> at some point(s) <code>x</code>.</p><ul><li><code>MM</code> the mesh of the solution.</li><li><code>y</code> the solution.</li><li><code>x</code> point(s) at which the solution should be evaluated.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/spectral1d.jl#L151-L159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.spectral1d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#MultiGridBarrier.spectral1d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.spectral1d_solve</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spectral1d_solve(::Type{T}=Float64;rest...) where {T} = amgb_solve(T;method=SPECTRAL1D,rest...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/spectral1d.jl#L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.spectral2d-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#MultiGridBarrier.spectral2d-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.spectral2d</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spectral2d(::Type{T}=Float64; n=nothing,
                L::Integer=2,
                K=nothing,
                state_variables = [:u :dirichlet
                                   :s :full],
                D = [:u :id
                     :u :dx
                     :u :dy
                     :s :id],
                generate_feasibility=true) where {T}</code></pre><p>Construct an <code>AMG</code> object for a 2d spectral grid of degree <code>n-1</code>. See also <code>fem2d</code> for a description of <code>state_variables</code> and <code>D</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/spectral2d.jl#L14-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.spectral2d_interp-Union{Tuple{Mat}, Tuple{T}, Tuple{AMG{T, Mat, SPECTRAL2D}, Vector{T}, Matrix{T}}} where {T, Mat}" href="#MultiGridBarrier.spectral2d_interp-Union{Tuple{Mat}, Tuple{T}, Tuple{AMG{T, Mat, SPECTRAL2D}, Vector{T}, Matrix{T}}} where {T, Mat}"><code>MultiGridBarrier.spectral2d_interp</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spectral2d_interp(MM::AMG{T,Mat,SPECTRAL2D},z::Array{T,1},x::Array{T,2}) where {T,Mat}</code></pre><p>Interpolate a solution <code>z</code> at point(s) <code>x</code>, given the mesh <code>MM</code>. See also <code>spectral1d_interp</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/spectral2d.jl#L80-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.spectral2d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#MultiGridBarrier.spectral2d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.spectral2d_solve</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spectral2d_solve(::Type{T}=Float64;rest...) where {T} = amgb_solve(T;method=SPECTRAL2D,rest...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/spectral2d.jl#L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.stopping_exact-Tuple{T} where T" href="#MultiGridBarrier.stopping_exact-Tuple{T} where T"><code>MultiGridBarrier.stopping_exact</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">stopping_exact(theta::T) where {T}</code></pre><p>Create an exact stopping criterion for Newton methods.</p><p><strong>Arguments</strong></p><ul><li><code>theta</code> : tolerance parameter for gradient norm relative decrease (type T).</li></ul><p><strong>Returns</strong></p><p>A stopping criterion function with signature: <code>stop(ymin, ynext, gmin, gnext, n, ndecmin, ndec) -&gt; Bool</code></p><p>where:</p><ul><li><code>ymin</code> : minimum objective value seen so far.</li><li><code>ynext</code> : current objective value.</li><li><code>gmin</code> : minimum gradient norm seen so far.</li><li><code>gnext</code> : current gradient vector.</li><li><code>n</code> : current Newton direction.</li><li><code>ndecmin</code> : square root of minimum Newton decrement seen so far.</li><li><code>ndec</code> : square root of current Newton decrement.</li></ul><p><strong>Algorithm</strong></p><p>Returns <code>true</code> (stop) if both conditions hold:</p><ol><li>No objective improvement: <code>ynext ≥ ymin</code></li><li>Gradient norm stagnation: <code>‖gnext‖ ≥ theta * gmin</code></li></ol><p><strong>Notes</strong></p><p>This criterion is &quot;exact&quot; in the sense that it requires both objective and gradient stagnation before stopping, making it suitable for high-precision optimization. Typical values of <code>theta</code> are in the range [0.1, 0.9].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/AlgebraicMultiGridBarrier.jl#L723-L753">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.stopping_inexact-Union{Tuple{T}, Tuple{T, T}} where T" href="#MultiGridBarrier.stopping_inexact-Union{Tuple{T}, Tuple{T, T}} where T"><code>MultiGridBarrier.stopping_inexact</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">stopping_inexact(lambda_tol::T, theta::T) where {T}</code></pre><p>Create an inexact stopping criterion for Newton methods that combines Newton decrement and exact stopping conditions.</p><p><strong>Arguments</strong></p><ul><li><code>lambda_tol</code> : tolerance for the Newton decrement (type T).</li><li><code>theta</code> : tolerance parameter for the exact stopping criterion (type T).</li></ul><p><strong>Returns</strong></p><p>A stopping criterion function with signature: <code>stop(ymin, ynext, gmin, gnext, n, ndecmin, ndec) -&gt; Bool</code></p><p>where:</p><ul><li><code>ymin</code> : minimum objective value seen so far.</li><li><code>ynext</code> : current objective value.</li><li><code>gmin</code> : minimum gradient norm seen so far.</li><li><code>gnext</code> : current gradient vector.</li><li><code>n</code> : current Newton direction.</li><li><code>ndecmin</code> : square root of minimum Newton decrement seen so far.</li><li><code>ndec</code> : square root of current Newton decrement (√(gᵀH⁻¹g)).</li></ul><p><strong>Algorithm</strong></p><p>Returns <code>true</code> (stop) if either condition holds:</p><ol><li>Newton decrement condition: <code>ndec &lt; lambda_tol</code></li><li>Exact stopping condition: <code>stopping_exact(theta)</code> is satisfied</li></ol><p><strong>Notes</strong></p><p>This criterion is &quot;inexact&quot; because it allows early termination based on the Newton decrement, which provides a quadratic convergence estimate. The Newton decrement <code>λ = √(gᵀH⁻¹g)</code> approximates the distance to the optimum in the Newton metric. Typical values: <code>lambda_tol ∈ [1e-6, 1e-3]</code>, <code>theta ∈ [0.1, 0.9]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/a131998294176a83eb6b8655f7a00f1960fb5966/src/AlgebraicMultiGridBarrier.jl#L755-L788">source</a></section></article><h1 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h1><ul><li><a href="#MultiGridBarrier.MultiGridBarrier"><code>MultiGridBarrier.MultiGridBarrier</code></a></li><li><a href="#MultiGridBarrier.AMG"><code>MultiGridBarrier.AMG</code></a></li><li><a href="#MultiGridBarrier.Barrier"><code>MultiGridBarrier.Barrier</code></a></li><li><a href="#MultiGridBarrier.Convex"><code>MultiGridBarrier.Convex</code></a></li><li><a href="#MultiGridBarrier.FEM1D"><code>MultiGridBarrier.FEM1D</code></a></li><li><a href="#MultiGridBarrier.FEM2D"><code>MultiGridBarrier.FEM2D</code></a></li><li><a href="#MultiGridBarrier.SPECTRAL1D"><code>MultiGridBarrier.SPECTRAL1D</code></a></li><li><a href="#MultiGridBarrier.SPECTRAL2D"><code>MultiGridBarrier.SPECTRAL2D</code></a></li><li><a href="#Base.intersect-Union{Tuple{T}, Tuple{Convex{T}, Vararg{Any}}} where T"><code>Base.intersect</code></a></li><li><a href="#MultiGridBarrier.amg-Union{Tuple{Type{Geometry}}, Tuple{Geometry}, Tuple{M}, Tuple{T}} where {T, M, Geometry}"><code>MultiGridBarrier.amg</code></a></li><li><a href="#MultiGridBarrier.amg_construct-Union{Tuple{T}, Tuple{Type{T}, Type{FEM1D}}} where T"><code>MultiGridBarrier.amg_construct</code></a></li><li><a href="#MultiGridBarrier.amg_construct-Union{Tuple{T}, Tuple{Type{T}, Type{SPECTRAL1D}}} where T"><code>MultiGridBarrier.amg_construct</code></a></li><li><a href="#MultiGridBarrier.amg_construct-Union{Tuple{T}, Tuple{Type{T}, Type{FEM2D}}} where T"><code>MultiGridBarrier.amg_construct</code></a></li><li><a href="#MultiGridBarrier.amg_construct-Union{Tuple{T}, Tuple{Type{T}, Type{SPECTRAL2D}}} where T"><code>MultiGridBarrier.amg_construct</code></a></li><li><a href="#MultiGridBarrier.amg_dim-Tuple{Type{FEM1D}}"><code>MultiGridBarrier.amg_dim</code></a></li><li><a href="#MultiGridBarrier.amg_dim-Tuple{Type{FEM2D}}"><code>MultiGridBarrier.amg_dim</code></a></li><li><a href="#MultiGridBarrier.amg_dim-Tuple{Type{SPECTRAL2D}}"><code>MultiGridBarrier.amg_dim</code></a></li><li><a href="#MultiGridBarrier.amg_dim-Tuple{Type{SPECTRAL1D}}"><code>MultiGridBarrier.amg_dim</code></a></li><li><a href="#MultiGridBarrier.amg_plot-Union{Tuple{Mat}, Tuple{T}, Tuple{AMG{T, Mat, SPECTRAL2D}, Vector{T}}} where {T, Mat}"><code>MultiGridBarrier.amg_plot</code></a></li><li><a href="#MultiGridBarrier.amg_plot-Union{Tuple{Mat}, Tuple{T}, Tuple{AMG{T, Mat, FEM2D}, Array{T}}} where {T, Mat}"><code>MultiGridBarrier.amg_plot</code></a></li><li><a href="#MultiGridBarrier.amg_plot-Union{Tuple{Mat}, Tuple{T}, Tuple{AMG{T, Mat, SPECTRAL1D}, Any}} where {T, Mat}"><code>MultiGridBarrier.amg_plot</code></a></li><li><a href="#MultiGridBarrier.amg_plot-Union{Tuple{Mat}, Tuple{T}, Tuple{AMG{T, Mat, FEM1D}, Vector{T}}} where {T, Mat}"><code>MultiGridBarrier.amg_plot</code></a></li><li><a href="#MultiGridBarrier.amgb-Union{Tuple{Geometry}, Tuple{Mat}, Tuple{T}, Tuple{Tuple{AMG{T, Mat, Geometry}, AMG{T, Mat, Geometry}}, Matrix{T}, Matrix{T}, Convex}} where {T, Mat, Geometry}"><code>MultiGridBarrier.amgb</code></a></li><li><a href="#MultiGridBarrier.amgb_core-Union{Tuple{Geometry}, Tuple{Mat}, Tuple{T}, Tuple{Barrier, AMG{T, Mat, Geometry}, Matrix{T}, Vector{T}, Matrix{T}}} where {T, Mat, Geometry}"><code>MultiGridBarrier.amgb_core</code></a></li><li><a href="#MultiGridBarrier.amgb_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.amgb_solve</code></a></li><li><a href="#MultiGridBarrier.apply_D-Union{Tuple{T}, Tuple{Any, Vector{T}}} where T"><code>MultiGridBarrier.apply_D</code></a></li><li><a href="#MultiGridBarrier.barrier-Tuple{Any}"><code>MultiGridBarrier.barrier</code></a></li><li><a href="#MultiGridBarrier.convex_Euclidian_power-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.convex_Euclidian_power</code></a></li><li><a href="#MultiGridBarrier.convex_linear-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.convex_linear</code></a></li><li><a href="#MultiGridBarrier.convex_piecewise-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.convex_piecewise</code></a></li><li><a href="#MultiGridBarrier.fem1d-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.fem1d</code></a></li><li><a href="#MultiGridBarrier.fem1d_interp-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector{T}}} where T"><code>MultiGridBarrier.fem1d_interp</code></a></li><li><a href="#MultiGridBarrier.fem1d_interp-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, T}} where T"><code>MultiGridBarrier.fem1d_interp</code></a></li><li><a href="#MultiGridBarrier.fem1d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.fem1d_solve</code></a></li><li><a href="#MultiGridBarrier.fem2d-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.fem2d</code></a></li><li><a href="#MultiGridBarrier.fem2d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.fem2d_solve</code></a></li><li><a href="#MultiGridBarrier.illinois-Union{Tuple{T}, Tuple{Any, T, T}} where T"><code>MultiGridBarrier.illinois</code></a></li><li><a href="#MultiGridBarrier.newton-Union{Tuple{Mat}, Tuple{T}, Tuple{Type{Mat}, Function, Function, Function, Vector{T}}} where {T, Mat}"><code>MultiGridBarrier.newton</code></a></li><li><a href="#MultiGridBarrier.parabolic_plot-Union{Tuple{Geometry}, Tuple{Mat}, Tuple{T}, Tuple{Any, AMG{T, Mat, Geometry}, Matrix{T}}} where {T, Mat, Geometry}"><code>MultiGridBarrier.parabolic_plot</code></a></li><li><a href="#MultiGridBarrier.parabolic_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.parabolic_solve</code></a></li><li><a href="#MultiGridBarrier.spectral1d-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.spectral1d</code></a></li><li><a href="#MultiGridBarrier.spectral1d_interp-Union{Tuple{Mat}, Tuple{T}, Tuple{AMG{T, Mat, SPECTRAL1D}, Vector{T}, Any}} where {T, Mat}"><code>MultiGridBarrier.spectral1d_interp</code></a></li><li><a href="#MultiGridBarrier.spectral1d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.spectral1d_solve</code></a></li><li><a href="#MultiGridBarrier.spectral2d-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.spectral2d</code></a></li><li><a href="#MultiGridBarrier.spectral2d_interp-Union{Tuple{Mat}, Tuple{T}, Tuple{AMG{T, Mat, SPECTRAL2D}, Vector{T}, Matrix{T}}} where {T, Mat}"><code>MultiGridBarrier.spectral2d_interp</code></a></li><li><a href="#MultiGridBarrier.spectral2d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.spectral2d_solve</code></a></li><li><a href="#MultiGridBarrier.stopping_exact-Tuple{T} where T"><code>MultiGridBarrier.stopping_exact</code></a></li><li><a href="#MultiGridBarrier.stopping_inexact-Union{Tuple{T}, Tuple{T, T}} where T"><code>MultiGridBarrier.stopping_inexact</code></a></li></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 19 September 2025 16:11">Friday 19 September 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
