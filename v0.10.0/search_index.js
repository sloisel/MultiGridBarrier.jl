var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"using Markdown\nusing Pkg\nusing MultiGridBarrier\nv = string(pkgversion(MultiGridBarrier))\nmd\"# MultiGridBarrier $v\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"MultiGridBarrier is a Julia module for solving nonlinear convex optimization problems in function spaces, such as p-Laplace problems. When regularity conditions are satisfied, the solvers are quasi-optimal.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The MultiGridBarrier module features finite element and spectral discretizations in 1d and 2d.","category":"page"},{"location":"#Finite-elements","page":"Home","title":"Finite elements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"After installing MultiGridBarrier with the Julia package manager, in a Jupyter notebook, one solves a 1d p-Laplace problem as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using PyPlot # hide\nusing MultiGridBarrier\nfem1d_solve(L=5,p=1.0,verbose=false);\nsavefig(\"fem1d.svg\"); nothing # hide\nclose() #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"A 2d p-Laplace problem:","category":"page"},{"location":"","page":"Home","title":"Home","text":"fem2d_solve(L=3,p=1.0,verbose=false);\nsavefig(\"fem2d.svg\"); nothing # hide\nclose() #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#Spectral-elements","page":"Home","title":"Spectral elements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Solve a 1d p-Laplace problem using spectral methods as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"spectral1d_solve(n=40,p=1.0,verbose=false);\nsavefig(\"spectral1d.svg\"); nothing # hide\nclose() #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"A 2d p-Laplace problem:","category":"page"},{"location":"","page":"Home","title":"Home","text":"spectral2d_solve(n=5,p=1.5,verbose=false);\nsavefig(\"spectral2d.svg\"); nothing # hide\nclose() #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#Solving-\\infty-Laplacians","page":"Home","title":"Solving infty-Laplacians","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For p geq 1 and domain Omega, the solution u of the p-Laplace problem is the minimizer of J(u) = nabla u_L^p(Omega)^p + int_Omega fu where u is in a suitable space of function satisfying, e.g. Dirichlet conditions, and f is a forcing. This definition must be modified for the infty-Laplace problem. Here we show how to minimize: J(u) = nabla u_L^infty(Omega)^p + int_Omega fu We put p=1 for simplicity.","category":"page"},{"location":"","page":"Home","title":"Home","text":"fem1d_solve(L=5,p=1.0,state_variables=[:u :dirichlet; :s :uniform],verbose=false);\nsavefig(\"fem1dinfty.svg\"); nothing # hide\nclose() #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#Parabolic-problems","page":"Home","title":"Parabolic problems","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A time-dependent problem:","category":"page"},{"location":"","page":"Home","title":"Home","text":"parabolic_solve(h=0.1,L=3,printer=anim->anim.save(\"parabolic.mp4\"),verbose=false);\nclose() #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"<video src=\"parabolic.mp4\" width=\"600\" controls autoplay loop></video>","category":"page"},{"location":"#Module-reference","page":"Home","title":"Module reference","text":"","category":"section"},{"location":"#MultiGridBarrier.MultiGridBarrier","page":"Home","title":"MultiGridBarrier.MultiGridBarrier","text":"module MultiGridBarrier\n\nModule MultiGridBarrier solves convex optimization problems in function spaces, for example, solving p-Laplace problems. We recommend to start with the functions fem1d_solve(), fem2d_solve(), spectral1d_solve(), spectral2d_solve(). These functions are sufficient to solve p-Laplace problems in 1d or 2d, using finite or spectral elements.\n\nFor more general use, the user will need to familiarize themselves with the basic ideas of convex optimization.\n\nOverview of convex optimization in function spaces by MultiGrid Barrier method.\n\nThe general idea is to build a multigrid hierarchy, represented by an AMG object, and barrier for a convex set, represented by a Barrier object, and then solve a convex optimization problem using the amgb() solver.\n\nTo generate the multigrid hierarchy represented by the AMG object, use either fem1d(), fem2d(), spectral1d() or spectral2d() functions. These constructors will assemble suitable AMG objects for either FEM or spectral discretizations, in 1d or 2d. One should think of these four constructors as being specialized in constructing some specific function spaces. A user can use the amg() constructor directly if custom function spaces are required, but this is more difficult.\n\nWe now describe the barrier function.\n\nAssume that Omega subset mathbbR^d is some open set. Consider the example of the p-Laplace problem on Omega. Let f(x) be a \"forcing\" (a function) on Omega, and 1 leq p  infty. One wishes to solve the minimization problem\n\nbeginequation\ninf_u int_Omega fu + nabla u_2^p  dx tag1\nendequation\n\nGenerally speaking, u will range in some function space, e.g. a space of differentiable functions satisfying homogeneous Dirichlet conditions. Under some conditions, minimizing (1) is equivalent to solving the p-Laplace PDE:\n\nnabla cdot (nabla u_2^p-2nabla u) = 1 over p f\n\nWe introduce the \"slack function\" s(x) and replace (1) with the following equivalent problem:\n\nbeginequation\ninf_s(x) geq nabla u(x)_2^p int_Omega fu + s  dx tag2\nendequation\n\nDefine the convex set mathcalQ =  (u(x)q(x)s(x))    s(x) geq q(x)_2^p , and\n\nz = beginbmatrix u  s endbmatrix qquad\nc^T = f01 qquad\nDz = beginbmatrix u  nabla u  s endbmatrix\n\nThen, (2) can be rewritten as\n\nbeginequation\ninf_Dz in mathcalQ int_Omega c^T(x)Dz(x)  dx tag3\nendequation\n\nRecall that a barrier for mathcalQ is a convex function mathcalF on mathcalQ such that mathcalF  infty in the interior of mathcalQ and mathcalF = infty on the boundary of mathcalQ. A barrier for the p-Laplace problem is:\n\nmathcalF(uqs) = int_Omega -log(s^2 over p - q_2^2) - 2log s  dx = int_Omega F(Dz(x))  dx\n\nThe central path z^*(t) minimizes, for each fixed t0, the quantity\n\nint_Omega tc^TDz + F(Dz)  dx\n\nAs t to infty, z^*(t) forms a minimizing sequence (or filter) for (3). We think of the function c(x) as the \"functional\" that we seek to minimize.\n\nThe Convex{T} type describes various convex sets (denoted Q above) by way of functions barrier(), cobarrier() and slack(). barrier is indeed a barrier for Q, cobarrier() is a barrier for a related feasibility problems, and slack() is used in solving the feasibility problem. Convex{T} objects can be created using the various convex_...() constructors, e.g. convex_Euclidian_power() for the p-Laplace problem.\n\nOnce one has AMG and Convex objects, and a suitable \"functional\" c, one uses the amgb() function to solve the optimization problem by the MultiGrid Barrier method, a variant of the barrier method (or interior point method) that is quasi-optimal for sufficiently regular problems.\n\n\n\n\n\n","category":"module"},{"location":"#Types-reference","page":"Home","title":"Types reference","text":"","category":"section"},{"location":"#MultiGridBarrier.AMGBConvergenceFailure","page":"Home","title":"MultiGridBarrier.AMGBConvergenceFailure","text":"AMGBConvergenceFailure <: Exception\n\nException thrown when the AMGB solver fails to converge.\n\nContains a descriptive message about the convergence failure, including information about which phase failed (feasibility or main optimization) and relevant iteration counts or tolerance values.\n\nFields\n\nmessage::String: Description of the convergence failure\n\nExamples\n\nThis exception is thrown when:\n\nFeasibility problem cannot be solved (problem may be infeasible)\nNewton iteration fails at any grid level\nMain optimization exceeds maximum iterations\nBarrier parameter fails to reach target tolerance\n\n\n\n\n\n","category":"type"},{"location":"#MultiGridBarrier.Convex","page":"Home","title":"MultiGridBarrier.Convex","text":"Convex{T}\n\nRepresentation of a convex constraint set via barrier functions.\n\nEncodes a convex domain Q implicitly through three functions that enable interior point methods to handle constraints.\n\nType Parameters\n\nT: Numeric type for computations\n\nFields\n\nbarrier::Function: Logarithmic barrier for the constraint set Q. Signature: (x, y) -> scalar where x is spatial location, y is state\ncobarrier::Function: Barrier for feasibility subproblem with slack. Signature: (x, yhat) -> scalar where yhat includes slack variable\nslack::Function: Initializes valid slack value for feasibility. Signature: (x, y) -> scalar returning a safe slack value\n\nUsage\n\nThe barrier function F(x, y) is finite inside Q and infinite on ∂Q. For a fixed spatial point x, the function y ↦ barrier(x, y) defines a barrier for the convex set at that point.\n\nConstructors\n\nconvex_linear: Linear inequality constraints Ay ≤ b\nconvex_Euclidian_power: Power cone constraints ‖y‖ᵖ ≤ s\nconvex_piecewise: Piecewise or combined constraints\nintersect: Intersection of multiple convex sets\n\nExamples\n\n# p-Laplace constraint: s ≥ ‖∇u‖ᵖ\nQ = convex_Euclidian_power(; idx=2:3, p=x->1.5)\n\n# Linear constraints: Ay ≤ b\nQ = convex_linear(; A=x->A_matrix, b=x->b_vector)\n\n# Intersection of constraints\nQ = intersect(Q1, Q2)\n\n\n\n\n\n","category":"type"},{"location":"#MultiGridBarrier.FEM1D","page":"Home","title":"MultiGridBarrier.FEM1D","text":"FEM1D{T}\n\n1D finite element discretization using piecewise linear basis functions.\n\nType Parameters\n\nT: Numeric type for computations\n\nFields\n\nL::Int: Number of refinement levels (mesh has 2^L elements)\n\nDescription\n\nRepresents a 1D finite element discretization on [-1, 1] with 2^L uniform elements and piecewise linear (P1) basis functions. Used with subdivide to generate the multigrid hierarchy for AMGB solvers.\n\nSee Also\n\nfem1d: Constructor function\nfem1d_solve: High-level solver interface\nsubdivide: Generate AMG hierarchy\n\n\n\n\n\n","category":"type"},{"location":"#MultiGridBarrier.FEM2D","page":"Home","title":"MultiGridBarrier.FEM2D","text":"FEM2D{T}\n\n2D finite element discretization using quadratic bubble elements.\n\nType Parameters\n\nT: Numeric type for computations\n\nFields\n\nK::Matrix{T}: Initial triangular mesh (3n×2 matrix for n triangles)\nL::Int: Number of refinement levels\n\nDescription\n\nRepresents a 2D finite element discretization with quadratic plus bubble elements on triangular meshes. Each triangle uses 7 nodes (3 vertices, 3 edge midpoints, 1 centroid) providing quadratic accuracy.\n\nSee Also\n\nfem2d: Constructor function\nfem2d_solve: High-level solver interface\nsubdivide: Generate AMG hierarchy\n\n\n\n\n\n","category":"type"},{"location":"#MultiGridBarrier.SPECTRAL1D","page":"Home","title":"MultiGridBarrier.SPECTRAL1D","text":"SPECTRAL1D{T}\n\n1D spectral element discretization using Chebyshev polynomials.\n\nType Parameters\n\nT: Numeric type for computations\n\nFields\n\nn::Int: Number of Chebyshev nodes (polynomial degree n-1)\n\nDescription\n\nRepresents a 1D spectral discretization on [-1, 1] using n Chebyshev nodes with Clenshaw-Curtis quadrature. Provides spectral accuracy for smooth solutions.\n\nSee Also\n\nspectral1d: Constructor function\nspectral1d_solve: High-level solver interface\nsubdivide: Generate AMG hierarchy\n\n\n\n\n\n","category":"type"},{"location":"#MultiGridBarrier.SPECTRAL2D","page":"Home","title":"MultiGridBarrier.SPECTRAL2D","text":"SPECTRAL2D{T}\n\n2D spectral element discretization using tensor-product Chebyshev polynomials.\n\nType Parameters\n\nT: Numeric type for computations\n\nFields\n\nn::Int: Number of Chebyshev nodes per dimension (degree n-1 per axis)\n\nDescription\n\nRepresents a 2D spectral discretization on [-1, 1]×[-1, 1] using n×n tensor-product Chebyshev nodes. Provides spectral accuracy for smooth solutions.\n\nSee Also\n\nspectral2d: Constructor function\nspectral2d_solve: High-level solver interface\nsubdivide: Generate AMG hierarchy\n\n\n\n\n\n","category":"type"},{"location":"#Functions-reference","page":"Home","title":"Functions reference","text":"","category":"section"},{"location":"#Base.intersect-Union{Tuple{T}, Tuple{Convex{T}, Vararg{Any}}} where T","page":"Home","title":"Base.intersect","text":"Base.intersect(U::Convex{T}, rest...) where {T}\n\nIntersection of arbitrarily many convex domains.\n\nReturns a Convex{T} that enforces all given domains at each x. Internally this is implemented via convex_piecewise with select(x) = [true, true, ...], so that:\n\nbarrier(x, y) = U.barrier(x, y) + ∑ rest[k].barrier(x, y)\ncobarrier(x, yhat) = U.cobarrier(x, yhat) + ∑ rest[k].cobarrier(x, yhat)\nslack(x, y) = max(U.slack(x, y), max(rest[k].slack(x, y) for k))\n\nThis lets you compose constraints in a natural way: the resulting domain equals U ∩ V₁ ∩ V₂ ∩ ....\n\nExamples\n\n# Intersect two domains\nU = convex_Euclidian_power(Float64; idx=[1, 2+dim], p = x->2)\nV = convex_Euclidian_power(Float64; idx=vcat(2:1+dim, 3+dim), p = x->p)\nQ = U ∩ V  # same as intersect(U, V)\n\n# Intersect three or more domains\nW = convex_linear(Float64; A = x->A_matrix, b = x->b_vector)\nQ3 = U ∩ V ∩ W  # same as intersect(U, V, W)\n\n# Works with single domain (returns it unchanged)\nQ1 = intersect(U)  # effectively returns U\n\nSee also: convex_piecewise.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.amgb-Union{Tuple{}, Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T","page":"Home","title":"MultiGridBarrier.amgb","text":"amgb(geometry=fem1d(), ::Type{T}=get_T(geometry); kwargs...)\n\nAlgebraic MultiGrid Barrier (AMGB) solver for nonlinear convex optimization problems  in function spaces using multigrid barrier methods.\n\nThis is the main high-level entry point for solving p-Laplace and related problems using the barrier method with multigrid acceleration. The solver operates in two phases:\n\nFeasibility phase: Finds an interior point for the constraint set (if needed)\nMain optimization phase: Solves the barrier-augmented optimization problem\n\nArguments\n\ngeometry: Discretization geometry (default: fem1d()). Options: \nfem1d(L=n): 1D finite elements with 2^L elements\nfem2d(L=n, K=mesh): 2D finite elements \nspectral1d(n=m): 1D spectral with m nodes\nspectral2d(n=m): 2D spectral with m×m nodes\nT::Type: Numeric type (default: inferred from geometry via get_T(geometry))\n\nKeyword Arguments\n\nProblem Specification\n\ndim::Integer = amg_dim(geometry): Problem dimension (1 or 2), auto-detected from geometry\nstate_variables::Matrix{Symbol} = [:u :dirichlet; :s :full]: Solution components and their function spaces\nD::Matrix{Symbol} = default_D[dim]: Differential operators to apply to state variables\nx::Matrix{T} = M[1].x: Mesh/sample points where f and g are evaluated when they are functions\n\nDiscretization Control\n\nM = subdivide(geometry; state_variables, D): Pre-built AMG hierarchy (constructed automatically if not provided)\n\nProblem Data\n\np::T = 1.0: Exponent for p-Laplace operator (p ≥ 1)\ng::Function = default_g(T)[dim]: Boundary conditions/initial guess (function of spatial coordinates)\ng_grid::Matrix{T}: Alternative to g, directly provide values on grid (default: g evaluated at x)\nf::Function = default_f(T)[dim]: Forcing term/cost functional (function of spatial coordinates)\nf_grid::Matrix{T}: Alternative to f, directly provide values on grid (default: f evaluated at x)\nQ::Convex{T} = convex_Euclidian_power(T, idx=2:dim+2, p=x->p): Convex constraint set\n\nOutput Control\n\nverbose::Bool = true: Display progress bar during solving\nshow::Bool = true: Plot the computed solution using PyPlot (requires PyPlot.jl)\nreturn_details::Bool = false: \nfalse: Return only the solution matrix z\ntrue: Return full solution object with detailed solver information\nlogfile = devnull: IO stream for logging (default: no file logging)\n\nSolver Control - Barrier Method (passed to amgb_core)\n\ntol = sqrt(eps(T)): Stopping tolerance; the method stops once 1/t < tol where t is the barrier parameter\nt = T(0.1): Initial barrier parameter for the main solve\nt_feasibility = t: Initial barrier parameter for the feasibility solve\nmaxit = 10000: Maximum number of barrier iterations\nkappa = T(10.0): Initial step size multiplier for barrier parameter t. Adapted dynamically but never exceeds this initial value\nc0 = T(0): Base offset added to the objective (c0 + t*c)\nearly_stop = z->false: Function z -> Bool; if true, the iteration halts early (e.g., to stop feasibility phase when interior point found)\n\nSolver Control - Newton Method (passed to amgbdriver/amgbcore)\n\nmax_newton = ceil((log2(-log2(eps(T))))+2): Maximum Newton iterations per inner solve\nstopping_criterion = stopping_inexact(sqrt(minimum(M[1].w))/2, T(0.5)): Stopping criterion for Newton solver. Options:\nstopping_exact(tol): Check if objective decreased and gradient norm fell below tolerance\nstopping_inexact(h, theta): Inexact Newton with mesh-dependent tolerance\nline_search = linesearch_backtracking(T): Line search strategy. Options:\nlinesearch_backtracking(T): Backtracking line search (default)\nlinesearch_illinois(T): Illinois algorithm-based line search\nfinalize = stopping_exact(T(0.5)): Finalization stopping criterion for the last Newton solve (stricter convergence)\n\nAdditional Parameters\n\nrest...: Additional keyword arguments passed to amgbdriver, amgbcore, amgb_phase1, and newton\n\nDefault Values\n\nThe defaults for f, g, and D depend on the problem dimension:\n\n1D Problems\n\nf(x) = [0.5, 0.0, 1.0] - Forcing term\ng(x) = [x[1], 2] - Boundary conditions  \nD = [:u :id; :u :dx; :s :id] - Identity, derivative, identity\n\n2D Problems\n\nf(x) = [0.5, 0.0, 0.0, 1.0] - Forcing term\ng(x) = [x[1]²+x[2]², 100.0] - Boundary conditions\nD = [:u :id; :u :dx; :u :dy; :s :id] - Identity, x-derivative, y-derivative, identity\n\nReturns\n\nIf return_details=false (default): Matrix of size (n_nodes, n_components) containing the solution\nIf return_details=true: NamedTuple with fields:\nz: Solution matrix of size (n_nodes, n_components) containing the computed solution\nSOL_feasibility: Feasibility phase results (nothing if initial point was already feasible), otherwise a solution object (see below)\nSOL_main: Main optimization phase results as a solution object (see below)\nlog: String containing detailed iteration log for debugging\nEach solution object (SOL_feasibility and SOL_main) is a NamedTuple containing:\nz: Solution vector (flattened; for feasibility phase includes auxiliary slack variable)\nz_unfinalized: Solution before final refinement step\nc: Cost functional used in this phase\nits: Iteration counts across levels and barrier steps (L×k matrix where L is number of levels, k is number of barrier iterations)\nts: Sequence of barrier parameters t used (length k)\nkappas: Step size multipliers used at each iteration (length k)\ntimes: Wall-clock timestamps for each iteration (length k)\nM: The AMG hierarchy used (M[2] for feasibility, M[1] for main)\nt_begin, t_end, t_elapsed: Timing information for this phase\npassed: Boolean array indicating phase 1 success at each level\nc_dot_Dz: Values of ⟨c, D*z⟩ at each barrier iteration (length k)\n\nAlgorithm Overview\n\nThe AMGB method combines:\n\nInterior point method: Uses logarithmic barriers to handle constraints\nMultigrid acceleration: Solves on hierarchy of grids from coarse to fine\nDamped Newton iteration: Inner solver with line search for robustness\n\nThe solver automatically handles:\n\nConstruction of appropriate discretization and multigrid hierarchy\nFeasibility restoration when initial point is infeasible  \nAdaptive barrier parameter updates with step size control\nConvergence monitoring across multiple grid levels\nProgress reporting (when verbose=true) and logging (to logfile if specified)\n\nErrors\n\nThrows AMGBConvergenceFailure if:\n\nThe feasibility problem cannot be solved (problem may be infeasible)\nThe main optimization fails to converge within maxit iterations\nNewton iteration fails at any grid level\n\nExamples\n\n# Solve 1D p-Laplace problem with p=1.5 using FEM\nz = amgb(fem1d(L=4); p=1.5)\n\n# Solve 2D problem with spectral elements\nz = amgb(spectral2d(n=8); p=2.0)\n\n# Custom boundary conditions\ng_custom(x) = [sin(π*x[1])*sin(π*x[2]), 10.0]\nz = amgb(fem2d(L=3); g=g_custom)\n\n# Get detailed solution information\nsol = amgb(fem1d(L=3); return_details=true, verbose=true)\nprintln(\"Iterations: \", sum(sol.SOL_main.its))\nprintln(\"Final barrier parameter: \", sol.SOL_main.ts[end])\n\n# Log iterations to a file\nopen(\"solver.log\", \"w\") do io\n    amgb(fem2d(L=2); logfile=io, verbose=false)\nend\n\n# Use pre-built hierarchy\ngeom = spectral1d(n=32)\nM = subdivide(geom; state_variables=[:u :dirichlet; :v :full; :s :full])\nz = amgb(geom; M=M, p=1.5)\n\nSee Also\n\nfem1d_solve, fem2d_solve, spectral1d_solve, spectral2d_solve:  Convenience wrappers for specific discretizations\nsubdivide: Generate AMG hierarchy for various discretizations\nConvex: Constraint set specification type\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.apply_D-Union{Tuple{T}, Tuple{Any, Vector{T}}} where T","page":"Home","title":"MultiGridBarrier.apply_D","text":"apply_D(D,z::Vector{T}) where {T} = hcat([D[k]*z for k in 1:length(D)]...)\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.convex_Euclidian_power-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.convex_Euclidian_power","text":"convex_Euclidian_power(::Type{T}=Float64; idx=Colon(), A=(x)->I, b=(x)->T(0), p=x->T(2))\n\nCreate a convex set defined by Euclidean norm power constraints.\n\nConstructs a Convex{T} object representing the power cone: {y : s ≥ ‖q‖₂^p} where [q; s] = A(x)*y[idx] + b(x)\n\nThis is the fundamental constraint for p-Laplace problems where we need s ≥ ‖∇u‖^p for some scalar field u.\n\nArguments\n\nT::Type=Float64: Numeric type for computations\n\nKeyword Arguments\n\nidx=Colon(): Indices of y to which transformation applies\nA::Function: Matrix function x -> A(x) for linear transformation\nb::Function: Vector function x -> b(x) for affine shift\np::Function: Exponent function x -> p(x) where p(x) ≥ 1\n\nReturns\n\nConvex{T} object with logarithmic barrier for the power cone\n\nMathematical Details\n\nThe barrier function is:\n\nFor p = 2: -log(s² - ‖q‖²)\nFor p ≠ 2: -log(s^(2/p) - ‖q‖²) - μ(p)*log(s) where μ(p) = 0 if p∈{1,2}, 1 if p<2, 2 if p>2\n\nExamples\n\n# Standard p-Laplace constraint: s ≥ ‖∇u‖^p\nQ = convex_Euclidian_power(; idx=2:4, p=x->1.5)\n\n# Spatially varying exponent\np_var(x) = 1.0 + 0.5 * x[1]  # p varies from 0.5 to 1.5\nQ = convex_Euclidian_power(; p=p_var)\n\n# Second-order cone constraint: s ≥ ‖q‖₂\nQ = convex_Euclidian_power(; p=x->1.0)\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.convex_linear-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.convex_linear","text":"convex_linear(::Type{T}=Float64; idx=Colon(), A=(x)->I, b=(x)->T(0))\n\nCreate a convex set defined by linear inequality constraints.\n\nConstructs a Convex{T} object representing the feasible region: {y : A(x)*y[idx] + b(x) ≤ 0} for each spatial point x.\n\nArguments\n\nT::Type=Float64: Numeric type for computations\n\nKeyword Arguments\n\nidx=Colon(): Indices of y to which constraints apply (default: all)\nA::Function: Matrix function x -> A(x) for constraint coefficients\nb::Function: Vector function x -> b(x) for constraint bounds\n\nReturns\n\nConvex{T} object with appropriate barrier functions\n\nExamples\n\n# Box constraints: -1 ≤ y ≤ 1\nA_box(x) = [I; -I]\nb_box(x) = [ones(n); ones(n)]\nQ = convex_linear(; A=A_box, b=b_box)\n\n# Single linear constraint: y[1] + 2*y[2] ≤ 3\nA_single(x) = [1.0 2.0]\nb_single(x) = [-3.0]\nQ = convex_linear(; A=A_single, b=b_single, idx=1:2)\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.convex_piecewise-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.convex_piecewise","text":"convex_piecewise(::Type{T}=Float64; Q::Vector{Convex{T}}, select::Function=(tr=fill(true,length(Q));x->tr)) where {T}\n\nBuild a Convex{T} that combines multiple convex domains with spatial selectivity.\n\nArguments\n\nQ::Vector{Convex{T}}: a vector of convex pieces to be combined.\nselect::Function: a function x -> Vector{Bool} indicating which pieces are active at x. Default: all pieces active everywhere (equivalent to intersection).\n\nSemantics\n\nFor sel = select(x), the resulting convex domain has:\n\nbarrier(x, y) = ∑(Q[k].barrier(x, y) for k where sel[k])\ncobarrier(x, yhat) = ∑(Q[k].cobarrier(x, yhat) for k where sel[k])  \nslack(x, y) = max(Q[k].slack(x, y) for k where sel[k])\n\nThe slack is the maximum over active pieces, ensuring a single slack value suffices for feasibility at each x.\n\nUse cases\n\nIntersections (default): All pieces active everywhere creates Q₁ ∩ Q₂ ∩ ...\nSpatial switching: Different constraints in different regions\nConditional constraints: Activate constraints based on solution state\n\nExamples\n\n# Intersection (using default select)\nU = convex_Euclidian_power(Float64; idx=[1, 3], p = x->2)\nV = convex_linear(Float64; A = x->A_matrix, b = x->b_vector)\nQint = convex_piecewise(Float64; Q = [U, V])  # U ∩ V everywhere\n\n# Region-dependent constraints\nQ_left = convex_Euclidian_power(Float64; p = x->1.5)  \nQ_right = convex_Euclidian_power(Float64; p = x->2.0)\nselect(x) = [x[1] < 0, x[1] >= 0]  # left half vs right half\nQreg = convex_piecewise(Float64; Q = [Q_left, Q_right], select = select)\n\n# Conditional activation\nQ_base = convex_linear(Float64; A = x->I, b = x->-ones(2))\nQ_extra = convex_Euclidian_power(Float64; p = x->3)\nselect(x) = [true, norm(x) > 0.5]  # extra constraint outside radius 0.5\nQcond = convex_piecewise(Float64; Q = [Q_base, Q_extra], select = select)\n\nSee also: Base.intersect, convex_linear, convex_Euclidian_power.\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.fem1d-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.fem1d","text":"fem1d(::Type{T}=Float64; L=4, kwargs...)\n\nCreate a 1D finite element discretization geometry.\n\nConstructs a FEM1D object representing a piecewise linear finite element discretization on the interval [-1, 1].\n\nArguments\n\nT::Type=Float64: Numeric type for computations\n\nKeyword Arguments\n\nL::Int=4: Number of refinement levels (creates 2^L uniform elements)\nOther kwargs are ignored (for compatibility with general interface)\n\nReturns\n\nFEM1D{T} object to be used with subdivide or amgb\n\nExamples\n\n# Create FEM discretization with 16 elements\ngeom = fem1d(Float64; L=4)\n\n# Use directly with subdivide\nM = subdivide(fem1d(L=5))\n\n# Use with amgb solver\nz = amgb(fem1d(L=4); p=1.5)\n\nSee Also\n\nFEM1D: Type documentation\nsubdivide: Generate multigrid hierarchy\nfem1d_solve: High-level solver\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.fem1d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.fem1d_solve","text":"fem1d_solve(::Type{T}=Float64;rest...) where {T} = amgb(fem1d(T;rest...);rest...)\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.fem2d-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.fem2d","text":"fem2d(::Type{T}=Float64; L=2, K=default_mesh, kwargs...)\n\nCreate a 2D finite element discretization geometry.\n\nConstructs a FEM2D object representing a quadratic bubble element discretization on a triangular mesh.\n\nArguments\n\nT::Type=Float64: Numeric type for computations\n\nKeyword Arguments\n\nL::Int=2: Number of refinement levels\nK::Matrix: Initial triangular mesh as 3n×2 matrix for n triangles. Default is two triangles covering [-1,1]×[-1,1]\nOther kwargs are ignored (for compatibility)\n\nReturns\n\nFEM2D{T} object to be used with subdivide or amgb\n\nMesh Format\n\nEach triangle is defined by 3 consecutive rows in K:\n\nRow 3i-2: First vertex [x1, y1]\nRow 3i-1: Second vertex [x2, y2]\nRow 3i: Third vertex [x3, y3]\n\nExamples\n\n# Default square domain\ngeom = fem2d(L=3)\n\n# Single triangle\nK = [-1.0 -1.0; 1.0 -1.0; 0.0 1.0]\ngeom = fem2d(; K=K, L=2)\n\n# L-shaped domain (6 triangles)\nK = [...] # define L-shape triangulation\nM = subdivide(fem2d(; K=K, L=2))\n\nSee Also\n\nFEM2D: Type documentation\nsubdivide: Generate multigrid hierarchy\nfem2d_solve: High-level solver\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.fem2d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.fem2d_solve","text":"fem2d_solve(::Type{T}=Float64;rest...) where {T} = amgb(fem2d(T;rest...);rest...)\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.interpolate","page":"Home","title":"MultiGridBarrier.interpolate","text":"interpolate(M::AMG, z::Vector, t)\n\nInterpolate a solution vector at specified points.\n\nGiven a solution z on the AMG mesh M, evaluates the solution at new points t using the appropriate interpolation method for the discretization (piecewise linear for FEM, polynomial for spectral).\n\nArguments\n\nM::AMG: The AMG mesh containing grid and basis information\nz::Vector: Solution vector on the mesh (length must match number of DOFs)\nt: Evaluation points. Format depends on dimension:\n1D: Scalar or vector of x-coordinates\n2D: Matrix where each row is [x, y]\n\nReturns\n\nInterpolated values at the specified points. Shape matches input t.\n\nExamples\n\n# 1D interpolation\nM = subdivide(fem1d(L=3); generate_feasibility=false)\nz = sin.(π * M.x)  # sample solution\ny = interpolate(M, z, 0.5)  # evaluate at x=0.5\ny_vec = interpolate(M, z, [-0.5, 0.0, 0.5])  # evaluate at multiple points\n\n# 2D interpolation\nM = subdivide(spectral2d(n=4); generate_feasibility=false)\nz = sin.(π * M.x[:,1]) .* cos.(π * M.x[:,2])\npoints = [0.0 0.0; 0.5 0.5; -0.5 0.5]  # 3 points\ny = interpolate(M, z, points)\n\n\n\n\n\n","category":"function"},{"location":"#MultiGridBarrier.parabolic_solve-Union{Tuple{}, Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T","page":"Home","title":"MultiGridBarrier.parabolic_solve","text":"parabolic_solve(geometry=fem2d(), ::Type{T}=get_T(geometry); kwargs...)\n\nSolve time-dependent p-Laplace problems using implicit Euler timestepping.\n\nSolves the parabolic PDE:\n\nu_t - nabla cdot (nabla u_2^p-2nabla u) = -f_1\n\nusing implicit Euler discretization and barrier methods.\n\nArguments\n\ngeometry: Discretization geometry (default: fem2d())\nT::Type: Numeric type (inferred from geometry)\n\nKeyword Arguments\n\nDiscretization\n\nstate_variables: State variables (default: [:u :dirichlet; :s1 :full; :s2 :full])\nD: Differential operators (default depends on dimension)\ndim::Int: Spatial dimension (auto-detected from geometry)\nM: Pre-built AMG hierarchy (constructed if not provided)\n\nTime Integration\n\nt0::T=0: Initial time\nt1::T=1: Final time\nh::T=0.2: Time step size\n\nProblem Parameters\n\np::T=1: Exponent for p-Laplacian\nf1: Source term function (default: x->T(0.5))\nf: Full forcing function (derived from f1 by default)\ng: Initial/boundary conditions (default depends on dimension)\nQ: Convex constraints (default: appropriate for p-Laplace)\n\nOutput Control\n\nverbose::Bool=true: Show progress bar\nshow::Bool=true: Animate solution after solving\ninterval::Int=200: Animation frame interval (ms)\nprinter: Function to display animation\n\nAdditional Parameters\n\nrest...: Passed to amgb for each time step\n\nReturns\n\n3D array U of size (n_nodes, n_components, n_timesteps) containing the solution at each time step.\n\nMathematical Formulation\n\nThe implicit Euler scheme u_t  (u_k+1-u_k)h gives:\n\nu_k+1 - hnabla cdot (nabla u_k+1^p-2nabla u_k+1) = u_k - hf_1\n\nWe minimize the functional:\n\nJ(u) = int_Ω frac12u² + frachpnabla u^p + (hf_1 - u_k)u  dx\n\nWith slack variables s_1  u² and s_2  nabla u^p, this becomes:\n\nmin int_Ω frac12s_1 + frachps_2 + (hf_1 - u_k)u  dx\n\nExamples\n\n# Basic 2D heat equation (p=2)\nU = parabolic_solve(; p=2.0, h=0.1)\n\n# 1D p-Laplace with custom parameters\nU = parabolic_solve(fem1d(L=5); p=1.5, h=0.05, t1=2.0)\n\n# Spectral discretization without animation\nU = parabolic_solve(spectral2d(n=8); show=false, verbose=true)\n\n# Custom initial condition\ng_init(t, x) = [exp(-10*(x[1]^2 + x[2]^2)), 0, 0]\nU = parabolic_solve(; g=g_init)\n\nSee Also\n\namgb: Single time step solver\nPyPlot.plot: Animation function for time-dependent solutions\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.spectral1d-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.spectral1d","text":"spectral1d(::Type{T}=Float64; n=16, kwargs...)\n\nCreate a 1D spectral element discretization geometry.\n\nConstructs a SPECTRAL1D object representing a Chebyshev spectral discretization on the interval [-1, 1].\n\nArguments\n\nT::Type=Float64: Numeric type for computations\n\nKeyword Arguments\n\nn::Int=16: Number of Chebyshev nodes (polynomial degree n-1)\nOther kwargs are ignored (for compatibility)\n\nReturns\n\nSPECTRAL1D{T} object to be used with subdivide or amgb\n\nExamples\n\n# Create spectral discretization with 32 nodes\ngeom = spectral1d(Float64; n=32)\n\n# Use directly with subdivide\nM = subdivide(spectral1d(n=40))\n\n# Use with amgb solver\nz = amgb(spectral1d(n=20); p=2.0)\n\nNotes\n\nThe multigrid hierarchy is built with levels having min(n, 2^k) nodes for k=1,2,...,L where L=ceil(log2(n)).\n\nSee Also\n\nSPECTRAL1D: Type documentation\nsubdivide: Generate multigrid hierarchy\nspectral1d_solve: High-level solver\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.spectral1d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.spectral1d_solve","text":"spectral1d_solve(::Type{T}=Float64;rest...) where {T} = amgb(spectral1d(T;rest...);rest...)\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.spectral2d-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.spectral2d","text":"spectral2d(::Type{T}=Float64; n=4, kwargs...)\n\nCreate a 2D spectral element discretization geometry.\n\nConstructs a SPECTRAL2D object representing a tensor-product Chebyshev spectral discretization on the square [-1, 1]×[-1, 1].\n\nArguments\n\nT::Type=Float64: Numeric type for computations\n\nKeyword Arguments\n\nn::Int=4: Number of Chebyshev nodes per dimension\nOther kwargs are ignored (for compatibility)\n\nReturns\n\nSPECTRAL2D{T} object to be used with subdivide or amgb\n\nExamples\n\n# Create 8×8 spectral discretization\ngeom = spectral2d(Float64; n=8)\n\n# Use directly with subdivide\nM = subdivide(spectral2d(n=6))\n\n# Use with amgb solver\nz = amgb(spectral2d(n=5); p=2.0)\n\nNotes\n\nUses tensor-product basis: n² total degrees of freedom\nMultigrid hierarchy built with min(n, 2^k) nodes per dimension\n\nSee Also\n\nSPECTRAL2D: Type documentation\nsubdivide: Generate multigrid hierarchy\nspectral2d_solve: High-level solver\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.spectral2d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"MultiGridBarrier.spectral2d_solve","text":"spectral2d_solve(::Type{T}=Float64;rest...) where {T} = amgb(spectral2d(T;rest...);rest...)\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.stopping_exact-Tuple{T} where T","page":"Home","title":"MultiGridBarrier.stopping_exact","text":"stopping_exact(theta::T) where {T}\n\nCreate an exact stopping criterion for Newton methods.\n\nArguments\n\ntheta : tolerance parameter for gradient norm relative decrease (type T).\n\nReturns\n\nA stopping criterion function with signature: stop(ymin, ynext, gmin, gnext, n, ndecmin, ndec) -> Bool\n\nwhere:\n\nymin : minimum objective value seen so far.\nynext : current objective value.\ngmin : minimum gradient norm seen so far.\ngnext : current gradient vector.\nn : current Newton direction.\nndecmin : square root of minimum Newton decrement seen so far.\nndec : square root of current Newton decrement.\n\nAlgorithm\n\nReturns true (stop) if both conditions hold:\n\nNo objective improvement: ynext ≥ ymin\nGradient norm stagnation: ‖gnext‖ ≥ theta * gmin\n\nNotes\n\nThis criterion is \"exact\" in the sense that it requires both objective and gradient stagnation before stopping, making it suitable for high-precision optimization. Typical values of theta are in the range [0.1, 0.9].\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.stopping_inexact-Union{Tuple{T}, Tuple{T, T}} where T","page":"Home","title":"MultiGridBarrier.stopping_inexact","text":"stopping_inexact(lambda_tol::T, theta::T) where {T}\n\nCreate an inexact stopping criterion for Newton methods that combines Newton decrement and exact stopping conditions.\n\nArguments\n\nlambda_tol : tolerance for the Newton decrement (type T).\ntheta : tolerance parameter for the exact stopping criterion (type T).\n\nReturns\n\nA stopping criterion function with signature: stop(ymin, ynext, gmin, gnext, n, ndecmin, ndec) -> Bool\n\nwhere:\n\nymin : minimum objective value seen so far.\nynext : current objective value.\ngmin : minimum gradient norm seen so far.\ngnext : current gradient vector.\nn : current Newton direction.\nndecmin : square root of minimum Newton decrement seen so far.\nndec : square root of current Newton decrement (√(gᵀH⁻¹g)).\n\nAlgorithm\n\nReturns true (stop) if either condition holds:\n\nNewton decrement condition: ndec < lambda_tol\nExact stopping condition: stopping_exact(theta) is satisfied\n\nNotes\n\nThis criterion is \"inexact\" because it allows early termination based on the Newton decrement, which provides a quadratic convergence estimate. The Newton decrement λ = √(gᵀH⁻¹g) approximates the distance to the optimum in the Newton metric. Typical values: lambda_tol ∈ [1e-6, 1e-3], theta ∈ [0.1, 0.9].\n\n\n\n\n\n","category":"method"},{"location":"#MultiGridBarrier.subdivide","page":"Home","title":"MultiGridBarrier.subdivide","text":"subdivide(geometry; state_variables, D, generate_feasibility=true)\n\nGenerate a multigrid hierarchy (AMG object) for a given discretization geometry.\n\nThis function constructs the complete multigrid data structures needed for the AMGB solver, including basis functions, differential operators, and interpolation operators across all grid levels.\n\nArguments\n\ngeometry: A geometry object (FEM1D, FEM2D, SPECTRAL1D, or SPECTRAL2D) specifying the discretization method and parameters\n\nKeyword Arguments\n\nstate_variables::Matrix{Symbol}: State variables and their function spaces. Default depends on geometry but typically [:u :dirichlet; :s :full]\nD::Matrix{Symbol}: Differential operators to apply. Default depends on dimension.\n1D: [:u :id; :u :dx; :s :id] (identity, derivative, identity)\n2D: [:u :id; :u :dx; :u :dy; :s :id] (identity, x-deriv, y-deriv, identity)\ngenerate_feasibility::Bool=true: If true, returns a tuple (M_main, M_feasibility) where M_feasibility includes an additional slack variable for feasibility phase\n\nReturns\n\nIf generate_feasibility=false: Single AMG object for the main problem\nIf generate_feasibility=true: Tuple of (mainAMG, feasibilityAMG)\n\nExamples\n\n# Generate FEM hierarchy with 4 levels\nM = subdivide(fem1d(L=4))\n\n# Generate spectral hierarchy without feasibility\nM = subdivide(spectral2d(n=8); generate_feasibility=false)\n\n# Custom state variables\nM = subdivide(fem2d(L=3); state_variables=[:u :dirichlet; :v :dirichlet; :s :full])\n\n\n\n\n\n","category":"function"},{"location":"#PyPlot.plot","page":"Home","title":"PyPlot.plot","text":"PyPlot.plot(M::AMG, z::Vector; kwargs...)\n\nPlot solutions on AMG meshes using PyPlot.\n\nVisualizes finite element or spectral element solutions with appropriate interpolation for smooth curves.\n\nArguments\n\nM::AMG: The AMG mesh containing discretization information\nz::Vector: Solution vector to plot (or matrix for multiple components)\n\nKeyword Arguments\n\nDiscretization-specific:\n\nFor SPECTRAL1D: x=-1:0.01:1 - evaluation points for interpolation\nFor SPECTRAL2D: x=-1:0.01:1, y=-1:0.01:1 - evaluation grid\nFor FEM2D: Uses triangulation from mesh directly\n\nAll other kwargs are passed to the underlying PyPlot functions.\n\nExamples\n\n# 1D plot\nM = subdivide(fem1d(L=3); generate_feasibility=false)\nz = sin.(π * M.x)\nplot(M, z)\n\n# 2D surface plot\nM = subdivide(spectral2d(n=4); generate_feasibility=false)\nz = exp.(-M.x[:,1].^2 - M.x[:,2].^2)\nplot(M, z)\n\n# With custom options\nplot(M, z; color=\"red\", linewidth=2)\n\n\n\n\n\n","category":"function"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
