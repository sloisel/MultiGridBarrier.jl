<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · MultiGridBarrier.jl</title><meta name="title" content="Home · MultiGridBarrier.jl"/><meta property="og:title" content="Home · MultiGridBarrier.jl"/><meta property="twitter:title" content="Home · MultiGridBarrier.jl"/><meta name="description" content="Documentation for MultiGridBarrier.jl."/><meta property="og:description" content="Documentation for MultiGridBarrier.jl."/><meta property="twitter:description" content="Documentation for MultiGridBarrier.jl."/><meta property="og:url" content="https://sloisel.github.io/MultiGridBarrier.jl/"/><meta property="twitter:url" content="https://sloisel.github.io/MultiGridBarrier.jl/"/><link rel="canonical" href="https://sloisel.github.io/MultiGridBarrier.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>MultiGridBarrier.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Finite-elements"><span>Finite elements</span></a></li><li><a class="tocitem" href="#Spectral-elements"><span>Spectral elements</span></a></li><li><a class="tocitem" href="#Solving-\\infty-Laplacians"><span>Solving <span>$\infty$</span>-Laplacians</span></a></li><li><a class="tocitem" href="#Parabolic-problems"><span>Parabolic problems</span></a></li><li class="toplevel"><a class="tocitem" href="#Module-reference"><span>Module reference</span></a></li><li class="toplevel"><a class="tocitem" href="#Types-reference"><span>Types reference</span></a></li><li class="toplevel"><a class="tocitem" href="#Functions-reference"><span>Functions reference</span></a></li><li class="toplevel"><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/sloisel/MultiGridBarrier.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1>MultiGridBarrier 0.11.10</h1><p><a href="https://github.com/sloisel/MultiGridBarrier.jl">MultiGridBarrier</a> is a Julia module for solving nonlinear convex optimization problems in function spaces, such as p-Laplace problems. When regularity conditions are satisfied, the solvers are quasi-optimal.</p><p>The <code>MultiGridBarrier</code> module features finite element and spectral discretizations in 1d and 2d.</p><h2 id="Finite-elements"><a class="docs-heading-anchor" href="#Finite-elements">Finite elements</a><a id="Finite-elements-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-elements" title="Permalink"></a></h2><p>After installing <code>MultiGridBarrier</code> with the Julia package manager, in a Jupyter notebook, one solves a 1d p-Laplace problem as follows:</p><pre><code class="language-julia hljs">using MultiGridBarrier
plot(fem1d_solve(L=5,p=1.0,verbose=false));</code></pre><p><img src="fem1d.svg" alt/></p><p>A 2d p-Laplace problem:</p><pre><code class="language-julia hljs">plot(fem2d_solve(L=3,p=1.0,verbose=false));</code></pre><p><img src="fem2d.svg" alt/></p><h2 id="Spectral-elements"><a class="docs-heading-anchor" href="#Spectral-elements">Spectral elements</a><a id="Spectral-elements-1"></a><a class="docs-heading-anchor-permalink" href="#Spectral-elements" title="Permalink"></a></h2><p>Solve a 1d p-Laplace problem using spectral methods as follows:</p><pre><code class="language-julia hljs">plot(spectral1d_solve(n=40,p=1.0,verbose=false));</code></pre><p><img src="spectral1d.svg" alt/></p><p>A 2d p-Laplace problem:</p><pre><code class="language-julia hljs">plot(spectral2d_solve(n=5,p=1.5,verbose=false));</code></pre><p><img src="spectral2d.svg" alt/></p><h2 id="Solving-\\infty-Laplacians"><a class="docs-heading-anchor" href="#Solving-\\infty-Laplacians">Solving <span>$\infty$</span>-Laplacians</a><a id="Solving-\\infty-Laplacians-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-\\infty-Laplacians" title="Permalink"></a></h2><p>For <span>$p \geq 1$</span> and domain <span>$\Omega$</span>, the solution <span>$u$</span> of the <span>$p$</span>-Laplace problem is the minimizer of <span>$J(u) = \|\nabla u\|_{L^p(\Omega)}^p + \int_{\Omega} fu,$</span> where <span>$u$</span> is in a suitable space of function satisfying, e.g. Dirichlet conditions, and <span>$f$</span> is a forcing. This definition must be modified for the <span>$\infty$</span>-Laplace problem. Here we show how to minimize: <span>$J(u) = \|\nabla u\|_{L^\infty(\Omega)}^p + \int_{\Omega} fu.$</span> We put <span>$p=1$</span> for simplicity.</p><pre><code class="language-julia hljs">plot(fem1d_solve(L=5,p=1.0,state_variables=[:u :dirichlet; :s :uniform],verbose=false));</code></pre><p><img src="fem1dinfty.svg" alt/></p><h2 id="Parabolic-problems"><a class="docs-heading-anchor" href="#Parabolic-problems">Parabolic problems</a><a id="Parabolic-problems-1"></a><a class="docs-heading-anchor-permalink" href="#Parabolic-problems" title="Permalink"></a></h2><p>A time-dependent problem:</p><pre><code class="language-julia hljs">plot(parabolic_solve(fem2d(L=3);h=0.1,verbose=false);printer=anim-&gt;anim.save(&quot;parabolic.mp4&quot;))</code></pre><video src="parabolic.mp4" width="600" controls autoplay loop></video><h1 id="Module-reference"><a class="docs-heading-anchor" href="#Module-reference">Module reference</a><a id="Module-reference-1"></a><a class="docs-heading-anchor-permalink" href="#Module-reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.MultiGridBarrier" href="#MultiGridBarrier.MultiGridBarrier"><code>MultiGridBarrier.MultiGridBarrier</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">module MultiGridBarrier</code></pre><p>MultiGridBarrier solves nonlinear convex optimization problems in function spaces using a barrier (interior-point) method accelerated by a multigrid hierarchy constructed from your chosen discretization (FEM or spectral). The package provides simple, high-level entry points as well as a general solver that accept a &quot;geometry&quot; and optional keywords.</p><p><strong>A gentle introduction via the p-Laplacian</strong></p><p>For a domain Ω ⊂ ℝᵈ and p ≥ 1, consider the variational problem</p><p class="math-container">\[\min_{u} \; J(u) = \int_{\Omega} \|\nabla u\|_2^p + f\,u \, dx\]</p><p>subject to appropriate boundary conditions (e.g., homogeneous Dirichlet). The Euler–Lagrange equation gives the p-Laplace PDE:</p><p class="math-container">\[\nabla \cdot \big(\|\nabla u\|_2^{p-2}\,\nabla u\big) = \tfrac{1}{p}\,f \quad \text{in } \Omega,\]</p><p>with the specified boundary conditions. This connection is obtained by integration by parts applied to the first variation of J(u).</p><p><strong>Constrained linear reformulation with a slack variable</strong></p><p>Introduce a slack <span>$s(x) \geq \|\nabla u(x)\|_2^p$</span> and rewrite the objective using s:</p><p class="math-container">\[\min_{u,\,s} \; \int_{\Omega} s + f\,u \, dx
\quad \text{subject to}\quad s \ge \|\nabla u\|_2^p.\]</p><p>This is a convex optimization problem with a linear objective and convex constraints. In discrete form, we bundle the state into z, and apply a block &quot;differential&quot; operator D so that</p><p class="math-container">\[D z = \begin{bmatrix} u \\ \nabla u \\ s \end{bmatrix},
\qquad
c^\top = \begin{bmatrix} f &amp; 0 &amp; 1 \end{bmatrix}.\]</p><p>The problem becomes</p><p class="math-container">\[\min_{z} \int_{\Omega} c(x)^\top \, (D z)(x) \, dx
\quad \text{subject to}\quad (u,q,s) \in \mathcal{Q} := \{ s \ge \|q\|_2^p \}\ \text{pointwise},\]</p><p>which MultiGridBarrier solves by a barrier method. An illustrative (simple) barrier for <span>$\mathcal{Q}$</span> is</p><p class="math-container">\[\mathcal{F}(q,s) = -\log\!\big(s^{2/p} - \|q\|_2^2\big) - 2\log s,\]</p><p>and the method minimizes the barrier-augmented functional</p><p class="math-container">\[\int_{\Omega} t\, c(x)^\top (D z)(x) + \mathcal{F}\!\big((D z)(x)\big) \, dx\]</p><p>for increasing barrier parameter t. Internally, the solve proceeds on a hierarchy of grids with damped Newton steps and line search, but these details are abstracted away.</p><p><strong>How to use it (discretizations and solvers)</strong></p><ul><li>Solve with a convenience wrapper (recommended to start):<ul><li><code>sol = fem1d_solve(; kwargs...)</code></li><li><code>sol = fem2d_solve(; kwargs...)</code></li><li><code>sol = spectral1d_solve(; kwargs...)</code></li><li><code>sol = spectral2d_solve(; kwargs...)</code></li></ul></li><li>Or call the general solver directly:<ul><li><code>sol = amgb(geometry; kwargs...)</code> → <code>AMGBSOL</code></li></ul></li><li>The solution can be plotted by calling <code>plot(sol)</code>. If using <code>amgb()</code> directly, you must construct a suitable geometry object:<ul><li><code>geometry = fem1d(; L=4)</code>         → 1D FEM on [-1, 1] with 2^L elements</li><li><code>geometry = fem2d(; L=2, K=...)</code>  → 2D FEM (quadratic + bubble triangles)</li><li><code>geometry = spectral1d(; n=16)</code>   → 1D spectral (Chebyshev/Clenshaw–Curtis)</li><li><code>geometry = spectral2d(; n=4)</code>    → 2D spectral (tensor Chebyshev)</li></ul></li></ul><p><strong>Quick examples</strong></p><pre><code class="language-julia hljs"># 1D FEM p-Laplace
z = fem1d_solve(L=5, p=1.0).z

# 2D spectral p-Laplace
z = spectral2d_solve(n=8, p=2.0).z

# 2D FEM with custom boundary data
g_custom(x) = [sin(π*x[1])*sin(π*x[2]), 10.0]
z = fem2d_solve(L=3; p=1.0, g=g_custom).z

# Time-dependent (implicit Euler)
sol = parabolic_solve(fem2d(L=3); h=0.1)
# plot(sol) animates the first component</code></pre><p><strong>Inputs and defaults (high level)</strong></p><ul><li><code>p::Real</code> = 1.0: exponent in the p-Laplace term</li><li><code>g</code>, <code>f</code>: boundary/initial data and forcing; either as functions <code>g(x)</code>, <code>f(x)</code> or as grids <code>g_grid</code>, <code>f_grid</code></li><li><code>D</code> and <code>state_variables</code>: symbolic specifications of which operators act on which variables (sane defaults provided based on the geometry’s dimension)</li><li><code>Q</code>: convex set (by default, a p-Laplace-compatible set via <code>convex_Euclidian_power</code>)</li><li><code>verbose</code>, <code>logfile</code>: visualization and logging</li><li>Advanced control: <code>tol</code>, <code>t</code>, <code>t_feasibility</code>, <code>line_search</code>, <code>stopping_criterion</code>, <code>finalize</code></li></ul><p><strong>What you get back</strong></p><ul><li>Static solvers (<code>amgb</code>, <code>*_solve</code>) return an <code>AMGBSOL</code> with fields:<ul><li><code>z::Matrix</code>: solution on the finest grid (nodes × components)</li><li><code>SOL_main</code>, <code>SOL_feasibility</code>: per-phase diagnostics</li><li><code>log::String</code>: textual log for debugging</li><li><code>geometry</code>: the <code>Geometry</code> used to construct the multilevel operators</li></ul>The solution object supports <code>plot(sol)</code> to visualize the first component.</li><li>The time-dependent solver <code>parabolic_solve</code> returns a <code>ParabolicSOL</code> with fields:<ul><li><code>geometry</code>, <code>ts::Vector</code>, <code>u::Array(nodes × components × timesteps)</code></li></ul>Call <code>plot(parabolic_sol)</code> to animate using <code>ts</code> (see plot docs for timing options).</li></ul><p><strong>Utilities</strong></p><ul><li><code>interpolate(geometry, z, points)</code>: evaluate the discrete solution at arbitrary points</li><li><code>plot(sol)</code> or <code>plot(geometry, z)</code>: plot 1D curves or 2D surfaces</li><li><code>plot(geometry, ts, U; printer=...)</code>: animate a time sequence at times <code>ts</code> (seconds), e.g., from <code>parabolic_solve</code></li><li>Convex set helpers: <code>convex_Euclidian_power</code>, <code>convex_linear</code>, <code>convex_piecewise</code>, <code>intersect</code></li></ul><p><strong>Errors and diagnostics</strong></p><ul><li>Throws <code>AMGBConvergenceFailure</code> if the feasibility subproblem or the main solve cannot converge</li><li>Set <code>verbose=true</code> for a progress bar; inspect <code>SOL_main</code>/feasibility and <code>log</code> for details</li></ul><p><strong>See also</strong></p><ul><li>Discretizations: <code>fem1d</code>, <code>fem2d</code>, <code>spectral1d</code>, <code>spectral2d</code></li><li>Solvers: <code>amgb</code>, <code>fem1d_solve</code>, <code>fem2d_solve</code>, <code>spectral1d_solve</code>, <code>spectral2d_solve</code>, <code>parabolic_solve</code></li><li>Convex: <code>convex_Euclidian_power</code>, <code>convex_linear</code>, <code>convex_piecewise</code>, <code>intersect</code></li><li>Visualization &amp; sampling: <code>plot</code>, <code>interpolate</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/de439ed9efe12bda71af4b005010c4296237c1ec/src/MultiGridBarrier.jl#L1-L119">source</a></section></article><h1 id="Types-reference"><a class="docs-heading-anchor" href="#Types-reference">Types reference</a><a id="Types-reference-1"></a><a class="docs-heading-anchor-permalink" href="#Types-reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.AMGBConvergenceFailure" href="#MultiGridBarrier.AMGBConvergenceFailure"><code>MultiGridBarrier.AMGBConvergenceFailure</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AMGBConvergenceFailure &lt;: Exception</code></pre><p>Thrown when the AMGB solver fails to converge (feasibility or main phase). Includes a descriptive message about the failure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/de439ed9efe12bda71af4b005010c4296237c1ec/src/AlgebraicMultiGridBarrier.jl#L81-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.Convex" href="#MultiGridBarrier.Convex"><code>MultiGridBarrier.Convex</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Convex{T}</code></pre><p>Container for a convex constraint set used by AMGB.</p><p>Fields:</p><ul><li>barrier(x, y): barrier of the set</li><li>cobarrier(x, yhat): barrier with slack for feasibility</li><li>slack(x, y): initial slack value</li></ul><p>Construct via helpers like <code>convex_linear</code>, <code>convex_Euclidian_power</code>, <code>convex_piecewise</code>, or <code>intersect</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/de439ed9efe12bda71af4b005010c4296237c1ec/src/AlgebraicMultiGridBarrier.jl#L220-L231">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.FEM1D" href="#MultiGridBarrier.FEM1D"><code>MultiGridBarrier.FEM1D</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM1D{T}</code></pre><p>1D FEM geometry descriptor. Field: <code>L::Int</code> (levels). Use with <code>amgb</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/de439ed9efe12bda71af4b005010c4296237c1ec/src/fem1d.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.FEM2D" href="#MultiGridBarrier.FEM2D"><code>MultiGridBarrier.FEM2D</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM2D{T}</code></pre><p>2D FEM geometry descriptor for quadratic+bubble triangles. Fields: <code>K::Matrix{T}</code> (3n×2 mesh), <code>L::Int</code> (levels). Use with <code>amgb</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/de439ed9efe12bda71af4b005010c4296237c1ec/src/fem2d.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.Geometry" href="#MultiGridBarrier.Geometry"><code>MultiGridBarrier.Geometry</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Geometry{T,M,Discretization}</code></pre><p>Container for discretization geometry and the multigrid transfer machinery used by AMGB.</p><p>Constructed by high-level front-ends like <code>fem1d</code>, <code>fem2d</code>, <code>spectral1d</code>, and <code>spectral2d</code>. It collects the physical/sample points, quadrature weights, per-level subspace embeddings, discrete operators (e.g. identity and derivatives), and intergrid transfer operators (refine/coarsen).</p><p>Type parameters</p><ul><li><code>T</code>: scalar numeric type (e.g. Float64)</li><li><code>M</code>: matrix type used for linear operators (e.g. <code>SparseMatrixCSC{T,Int}</code> or <code>Matrix{T}</code>)</li><li><code>Discretization</code>: front-end descriptor (e.g. <code>FEM1D{T}</code>, <code>FEM2D{T}</code>, <code>SPECTRAL1D{T}</code>, <code>SPECTRAL2D{T}</code>)</li></ul><p>Fields</p><ul><li><code>discretization::Discretization</code>: Discretization descriptor that encodes dimension and grid construction</li><li><code>x::Matrix{T}</code>: Sample/mesh points on the finest level; size is (n_nodes, dim)</li><li><code>w::Vector{T}</code>: Quadrature weights matching <code>x</code> (length n_nodes)</li><li><code>subspaces::Dict{Symbol,Vector{M}}</code>: Per-level selection/embedding matrices for function spaces (keys commonly include <code>:dirichlet</code>, <code>:full</code>, <code>:uniform</code>). Each value is a vector of length L with one matrix per level.</li><li><code>operators::Dict{Symbol,M}</code>: Discrete operators defined on the finest level (e.g. <code>:id</code>, <code>:dx</code>, <code>:dy</code>). Operators at other levels are obtained via <code>coarsen_fine * operator * refine_fine</code> inside <code>amg</code>.</li><li><code>refine::Vector{M}</code>: Level-to-level refinement (prolongation) matrices for the primary state space</li><li><code>coarsen::Vector{M}</code>: Level-to-level coarsening (restriction) matrices for the primary state space</li></ul><p>Notes</p><ul><li><code>Geometry</code> is consumed by <code>amg</code> to build an <code>AMG</code> hierarchy and by utilities like <code>interpolate</code> and <code>plot</code>.</li><li>The length of <code>refine</code>/<code>coarsen</code> equals the number of levels L; the last entry is typically the identity.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/de439ed9efe12bda71af4b005010c4296237c1ec/src/AlgebraicMultiGridBarrier.jl#L99-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.SPECTRAL1D" href="#MultiGridBarrier.SPECTRAL1D"><code>MultiGridBarrier.SPECTRAL1D</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SPECTRAL1D{T}</code></pre><p>1D spectral geometry descriptor (Chebyshev). Field: <code>n::Int</code> (nodes). Use with <code>amgb</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/de439ed9efe12bda71af4b005010c4296237c1ec/src/spectral1d.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.SPECTRAL2D" href="#MultiGridBarrier.SPECTRAL2D"><code>MultiGridBarrier.SPECTRAL2D</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SPECTRAL2D{T}</code></pre><p>2D spectral geometry descriptor (tensor Chebyshev). Field: <code>n::Int</code> (nodes per dim). Use with <code>amgb</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/de439ed9efe12bda71af4b005010c4296237c1ec/src/spectral2d.jl#L3-L8">source</a></section></article><h1 id="Functions-reference"><a class="docs-heading-anchor" href="#Functions-reference">Functions reference</a><a id="Functions-reference-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.intersect-Union{Tuple{T}, Tuple{Convex{T}, Vararg{Any}}} where T" href="#Base.intersect-Union{Tuple{T}, Tuple{Convex{T}, Vararg{Any}}} where T"><code>Base.intersect</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">intersect(U::Convex{T}, rest...) where {T}</code></pre><p>Return the intersection of convex domains as a single <code>Convex{T}</code>. Equivalent to <code>convex_piecewise</code> with all pieces active.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/de439ed9efe12bda71af4b005010c4296237c1ec/src/AlgebraicMultiGridBarrier.jl#L427-L432">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.amgb-Union{Tuple{}, Tuple{Geometry{T, Mat, Discretization}}, Tuple{Discretization}, Tuple{Mat}, Tuple{T}} where {T, Mat, Discretization}" href="#MultiGridBarrier.amgb-Union{Tuple{}, Tuple{Geometry{T, Mat, Discretization}}, Tuple{Discretization}, Tuple{Mat}, Tuple{T}} where {T, Mat, Discretization}"><code>MultiGridBarrier.amgb</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">amgb(geometry::Geometry{T,Mat,Discretization}; kwargs...) where {T, Mat, Discretization}</code></pre><p>Algebraic MultiGrid Barrier (AMGB) solver for nonlinear convex optimization problems in function spaces using multigrid barrier methods.</p><p>This is the main high-level entry point for solving p-Laplace and related problems using the barrier method with multigrid acceleration. The solver operates in two phases:</p><ol><li>Feasibility phase: Finds an interior point for the constraint set (if needed)</li><li>Main optimization phase: Solves the barrier-augmented optimization problem</li></ol><p><strong>Arguments</strong></p><ul><li><code>geometry</code>: Discretization geometry (default: <code>fem1d()</code>). Options:<ul><li><code>fem1d(L=n)</code>: 1D finite elements with 2^L elements</li><li><code>fem2d(L=n, K=mesh)</code>: 2D finite elements</li><li><code>spectral1d(n=m)</code>: 1D spectral with m nodes</li><li><code>spectral2d(n=m)</code>: 2D spectral with m×m nodes</li></ul></li></ul><p><strong>Keyword Arguments</strong></p><p><strong>Problem Specification</strong></p><ul><li><code>dim::Integer = amg_dim(geometry.discretization)</code>: Problem dimension (1 or 2), auto-detected from geometry</li><li><code>state_variables::Matrix{Symbol} = [:u :dirichlet; :s :full]</code>: Solution components and their function spaces</li><li><code>D::Matrix{Symbol} = default_D[dim]</code>: Differential operators to apply to state variables</li><li><code>x::Matrix{T} = geometry.x</code>: Mesh/sample points where <code>f</code> and <code>g</code> are evaluated when they are functions</li></ul><p><strong>Problem Data</strong></p><ul><li><code>p::T = 1.0</code>: Exponent for p-Laplace operator (p ≥ 1)</li><li><code>g::Function = default_g(T)[dim]</code>: Boundary conditions/initial guess (function of spatial coordinates)</li><li><code>g_grid::Matrix{T}</code>: Alternative to <code>g</code>, directly provide values on grid (default: <code>g</code> evaluated at <code>x</code>)</li><li><code>f::Function = default_f(T)[dim]</code>: Forcing term/cost functional (function of spatial coordinates)</li><li><code>f_grid::Matrix{T}</code>: Alternative to <code>f</code>, directly provide values on grid (default: <code>f</code> evaluated at <code>x</code>)</li><li><code>Q::Convex{T} = convex_Euclidian_power(T, idx=2:dim+2, p=x-&gt;p)</code>: Convex constraint set</li></ul><p><strong>Output Control</strong></p><ul><li><code>verbose::Bool = true</code>: Display progress bar during solving</li><li><code>logfile = devnull</code>: IO stream for logging (default: no file logging)</li></ul><p><strong>Solver Control</strong></p><p><strong>Passthrough Arguments</strong></p><p>Additional keyword arguments are passed through to internal solver components:</p><ul><li><code>tol = sqrt(eps(T))</code>: Stopping tolerance; the method stops once <code>1/t &lt; tol</code> where <code>t</code> is the barrier parameter</li><li><code>t = T(0.1)</code>: Initial barrier parameter for the main solve</li><li><code>t_feasibility = t</code>: Initial barrier parameter for the feasibility solve</li><li><code>maxit = 10000</code>: Maximum number of barrier iterations</li><li><code>kappa = T(10.0)</code>: Initial step size multiplier for barrier parameter <code>t</code>. Adapted dynamically but never exceeds this initial value</li><li><code>c0 = T(0)</code>: Base offset added to the objective (<code>c0 + t*c</code>)</li><li><code>early_stop = z-&gt;false</code>: Function <code>z -&gt; Bool</code>; if <code>true</code>, the iteration halts early (e.g., to stop feasibility phase when interior point found)</li><li><code>max_newton = ceil((log2(-log2(eps(T))))+2)</code>: Maximum Newton iterations per inner solve</li><li><code>stopping_criterion = stopping_inexact(sqrt(minimum(M[1].w))/2, T(0.5))</code>: Stopping criterion for Newton solver. Options:<ul><li><code>stopping_exact(theta)</code>: Check if objective decreased and gradient norm fell below tolerance</li><li><code>stopping_inexact(lambda_tol, theta)</code>: Inexact Newton with mesh-dependent tolerance</li></ul></li><li><code>line_search = linesearch_backtracking(T)</code>: Line search strategy. Options:<ul><li><code>linesearch_backtracking(T)</code>: Backtracking line search (default)</li><li><code>linesearch_illinois(T)</code>: Illinois algorithm-based line search</li></ul></li><li><code>finalize = stopping_exact(T(0.5))</code>: Finalization stopping criterion for the last Newton solve (stricter convergence)</li></ul><p><strong>Default Values</strong></p><p>The defaults for <code>f</code>, <code>g</code>, and <code>D</code> depend on the problem dimension:</p><p><strong>1D Problems</strong></p><ul><li><code>f(x) = [0.5, 0.0, 1.0]</code> - Forcing term</li><li><code>g(x) = [x[1], 2]</code> - Boundary conditions</li><li><code>D = [:u :id; :u :dx; :s :id]</code> - Identity, derivative, identity</li></ul><p><strong>2D Problems</strong></p><ul><li><code>f(x) = [0.5, 0.0, 0.0, 1.0]</code> - Forcing term</li><li><code>g(x) = [x[1]²+x[2]², 100.0]</code> - Boundary conditions</li><li><code>D = [:u :id; :u :dx; :u :dy; :s :id]</code> - Identity, x-derivative, y-derivative, identity</li></ul><p><strong>Returns</strong></p><p>Solution object with fields:</p><ul><li><code>z</code>: Solution matrix of size <code>(n_nodes, n_components)</code> containing the computed solution</li><li><code>SOL_feasibility</code>: Feasibility phase results (<code>nothing</code> if the initial point was already feasible), otherwise a solution object (see below)</li><li><code>SOL_main</code>: Main optimization phase results as a solution object (see below)</li><li><code>log</code>: String containing detailed iteration log for debugging</li><li><code>geometry</code>: The input <code>geometry</code> object</li></ul><p>Each solution object (<code>SOL_feasibility</code> and <code>SOL_main</code>) is a NamedTuple containing:</p><ul><li><code>z</code>: Solution vector (flattened; for feasibility phase includes auxiliary slack variable)</li><li><code>z_unfinalized</code>: Solution before final refinement step</li><li><code>c</code>: Cost functional used in this phase</li><li><code>its</code>: Iteration counts across levels and barrier steps (L×k matrix where L is number of levels, k is number of barrier iterations)</li><li><code>ts</code>: Sequence of barrier parameters t used (length k)</li><li><code>kappas</code>: Step size multipliers used at each iteration (length k)</li><li><code>times</code>: Wall-clock timestamps for each iteration (length k)</li><li><code>t_begin</code>, <code>t_end</code>, <code>t_elapsed</code>: Timing information for this phase</li><li><code>passed</code>: Boolean array indicating phase 1 success at each level</li><li><code>c_dot_Dz</code>: Values of ⟨c, D*z⟩ at each barrier iteration (length k)</li></ul><p><strong>Algorithm Overview</strong></p><p>The AMGB method combines:</p><ol><li>Interior point method: Uses logarithmic barriers to handle constraints</li><li>Multigrid acceleration: Solves on hierarchy of grids from coarse to fine</li><li>Damped Newton iteration: Inner solver with line search for robustness</li></ol><p>The solver automatically handles:</p><ul><li>Construction of appropriate discretization and multigrid hierarchy</li><li>Feasibility restoration when initial point is infeasible</li><li>Adaptive barrier parameter updates with step size control</li><li>Convergence monitoring across multiple grid levels</li><li>Progress reporting (when <code>verbose=true</code>) and logging (to <code>logfile</code> if specified)</li></ul><p><strong>Errors</strong></p><p>Throws <code>AMGBConvergenceFailure</code> if:</p><ul><li>The feasibility problem cannot be solved (problem may be infeasible)</li><li>The main optimization fails to converge within <code>maxit</code> iterations</li><li>Newton iteration fails at any grid level</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Solve 1D p-Laplace problem with p=1.5 using FEM
z = amgb(fem1d(L=4); p=1.5).z

# Solve 2D problem with spectral elements
z = amgb(spectral2d(n=8); p=2.0).z

# Custom boundary conditions
g_custom(x) = [sin(π*x[1])*sin(π*x[2]), 10.0]
z = amgb(fem2d(L=3); g=g_custom).z

# Get detailed solution information
sol = amgb(fem1d(L=3); verbose=true)
println(&quot;Iterations: &quot;, sum(sol.SOL_main.its))
println(&quot;Final barrier parameter: &quot;, sol.SOL_main.ts[end])

# Visualize the first component
plot(sol)

# Log iterations to a file
open(&quot;solver.log&quot;, &quot;w&quot;) do io
    amgb(fem2d(L=2); logfile=io, verbose=false)
end</code></pre><p><strong>See Also</strong></p><ul><li><a href="#MultiGridBarrier.fem1d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>fem1d_solve</code></a>, <a href="#MultiGridBarrier.fem2d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>fem2d_solve</code></a>, <a href="#MultiGridBarrier.spectral1d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>spectral1d_solve</code></a>, <a href="#MultiGridBarrier.spectral2d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>spectral2d_solve</code></a>: Convenience wrappers for specific discretizations</li><li><a href="#MultiGridBarrier.Convex"><code>Convex</code></a>: Constraint set specification type</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/de439ed9efe12bda71af4b005010c4296237c1ec/src/AlgebraicMultiGridBarrier.jl#L1060-L1206">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.apply_D-Union{Tuple{T}, Tuple{Any, Vector{T}}} where T" href="#MultiGridBarrier.apply_D-Union{Tuple{T}, Tuple{Any, Vector{T}}} where T"><code>MultiGridBarrier.apply_D</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_D(D,z::Vector{T}) where {T} = hcat([D[k]*z for k in 1:length(D)]...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/de439ed9efe12bda71af4b005010c4296237c1ec/src/AlgebraicMultiGridBarrier.jl#L435">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.convex_Euclidian_power-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#MultiGridBarrier.convex_Euclidian_power-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.convex_Euclidian_power</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convex_Euclidian_power(::Type{T}=Float64; idx=Colon(), A=(x)-&gt;I, b=(x)-&gt;T(0), p=x-&gt;T(2))</code></pre><p>Create a convex set defined by Euclidean norm power constraints.</p><p>Constructs a <code>Convex{T}</code> object representing the power cone: <code>{y : s ≥ ‖q‖₂^p}</code> where <code>[q; s] = A(x)*y[idx] + b(x)</code></p><p>This is the fundamental constraint for p-Laplace problems where we need <code>s ≥ ‖∇u‖^p</code> for some scalar field u.</p><p><strong>Arguments</strong></p><ul><li><code>T::Type=Float64</code>: Numeric type for computations</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>idx=Colon()</code>: Indices of y to which transformation applies</li><li><code>A::Function</code>: Matrix function <code>x -&gt; A(x)</code> for linear transformation</li><li><code>b::Function</code>: Vector function <code>x -&gt; b(x)</code> for affine shift</li><li><code>p::Function</code>: Exponent function <code>x -&gt; p(x)</code> where p(x) ≥ 1</li></ul><p><strong>Returns</strong></p><p><code>Convex{T}</code> object with logarithmic barrier for the power cone</p><p><strong>Mathematical Details</strong></p><p>The barrier function is:</p><ul><li>For p = 2: <code>-log(s² - ‖q‖²)</code></li><li>For p ≠ 2: <code>-log(s^(2/p) - ‖q‖²) - μ(p)*log(s)</code> where μ(p) = 0 if p∈{1,2}, 1 if p&lt;2, 2 if p&gt;2</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Standard p-Laplace constraint: s ≥ ‖∇u‖^p
Q = convex_Euclidian_power(; idx=2:4, p=x-&gt;1.5)

# Spatially varying exponent
p_var(x) = 1.0 + 0.5 * x[1]  # variable p
Q = convex_Euclidian_power(; p=p_var)

# Second-order cone constraint: s ≥ ‖q‖₂
Q = convex_Euclidian_power(; p=x-&gt;1.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/de439ed9efe12bda71af4b005010c4296237c1ec/src/AlgebraicMultiGridBarrier.jl#L282-L323">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.convex_linear-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#MultiGridBarrier.convex_linear-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.convex_linear</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convex_linear(::Type{T}=Float64; idx=Colon(), A=(x)-&gt;I, b=(x)-&gt;T(0))</code></pre><p>Create a convex set defined by linear inequality constraints.</p><p>Defines <code>F(x, y) = A(x) * y[idx] + b(x)</code>. The interior of the set is given by <code>F(x, y) &gt; 0</code> (a logarithmic barrier is applied to each component of <code>F</code>). The boundary <code>F(x, y) = 0</code> corresponds to constraint activation.</p><p><strong>Arguments</strong></p><ul><li><code>T::Type=Float64</code>: Numeric type for computations</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>idx=Colon()</code>: Indices of y to which constraints apply (default: all)</li><li><code>A::Function</code>: Matrix function <code>x -&gt; A(x)</code> for constraint coefficients</li><li><code>b::Function</code>: Vector function <code>x -&gt; b(x)</code> for constraint bounds</li></ul><p><strong>Returns</strong></p><p><code>Convex{T}</code> object with appropriate barrier functions</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Box constraints in 2D: -1 ≤ y ≤ 1
A_box(x) = [1.0 0.0; 0.0 1.0; -1.0 0.0; 0.0 -1.0]
b_box(x) = [1.0, 1.0, 1.0, 1.0]
Q = convex_linear(; A=A_box, b=b_box, idx=1:2)

# Single linear constraint: y[1] + 2*y[2] ≤ 3
# Choose F = 3 - (y1 + 2*y2) &gt; 0
A_single(x) = [-1.0 -2.0]
b_single(x) = [3.0]
Q = convex_linear(; A=A_single, b=b_single, idx=1:2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/de439ed9efe12bda71af4b005010c4296237c1ec/src/AlgebraicMultiGridBarrier.jl#L238-L271">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.convex_piecewise-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#MultiGridBarrier.convex_piecewise-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.convex_piecewise</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convex_piecewise(::Type{T}=Float64; Q::Vector{Convex{T}}, select::Function=(tr=fill(true,length(Q));x-&gt;tr)) where {T}</code></pre><p>Build a <code>Convex{T}</code> that combines multiple convex domains with spatial selectivity.</p><p><strong>Arguments</strong></p><ul><li><code>Q::Vector{Convex{T}}</code>: a vector of convex pieces to be combined.</li><li><code>select::Function</code>: a function <code>x -&gt; Vector{Bool}</code> indicating which pieces are active at <code>x</code>. Default: all pieces active everywhere (equivalent to intersection).</li></ul><p><strong>Semantics</strong></p><p>For <code>sel = select(x)</code>, the resulting convex domain has:</p><ul><li><code>barrier(x, y) = ∑(Q[k].barrier(x, y) for k where sel[k])</code></li><li><code>cobarrier(x, yhat) = ∑(Q[k].cobarrier(x, yhat) for k where sel[k])</code>  </li><li><code>slack(x, y) = max(Q[k].slack(x, y) for k where sel[k])</code></li></ul><p>The slack is the maximum over active pieces, ensuring a single slack value suffices for feasibility at each <code>x</code>.</p><p><strong>Use cases</strong></p><ol><li><strong>Intersections</strong> (default): All pieces active everywhere creates <code>Q₁ ∩ Q₂ ∩ ...</code></li><li><strong>Spatial switching</strong>: Different constraints in different regions</li><li><strong>Conditional constraints</strong>: Activate constraints based on solution state</li></ol><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Intersection (using default select)
U = convex_Euclidian_power(Float64; idx=[1, 3], p = x-&gt;2)
V = convex_linear(Float64; A = x-&gt;A_matrix, b = x-&gt;b_vector)
Qint = convex_piecewise(Float64; Q = [U, V])  # U ∩ V everywhere

# Region-dependent constraints
Q_left = convex_Euclidian_power(Float64; p = x-&gt;1.5)  
Q_right = convex_Euclidian_power(Float64; p = x-&gt;2.0)
select(x) = [x[1] &lt; 0, x[1] &gt;= 0]  # left half vs right half
Qreg = convex_piecewise(Float64; Q = [Q_left, Q_right], select = select)

# Conditional activation
Q_base = convex_linear(Float64; A = x-&gt;I, b = x-&gt;-ones(2))
Q_extra = convex_Euclidian_power(Float64; p = x-&gt;3)
select(x) = [true, norm(x) &gt; 0.5]  # extra constraint outside radius 0.5
Qcond = convex_piecewise(Float64; Q = [Q_base, Q_extra], select = select)</code></pre><p>See also: <a href="#Base.intersect-Union{Tuple{T}, Tuple{Convex{T}, Vararg{Any}}} where T"><code>intersect</code></a>, <a href="#MultiGridBarrier.convex_linear-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>convex_linear</code></a>, <a href="#MultiGridBarrier.convex_Euclidian_power-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>convex_Euclidian_power</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/de439ed9efe12bda71af4b005010c4296237c1ec/src/AlgebraicMultiGridBarrier.jl#L346-L391">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.fem1d-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#MultiGridBarrier.fem1d-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.fem1d</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fem1d(::Type{T}=Float64; L=4, kwargs...)</code></pre><p>Construct 1D FEM geometry (piecewise linear) on [-1, 1]. Returns a Geometry suitable for use with <code>amgb</code>. Keyword <code>L</code> sets 2^L elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/de439ed9efe12bda71af4b005010c4296237c1ec/src/fem1d.jl#L19-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.fem1d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#MultiGridBarrier.fem1d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.fem1d_solve</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fem1d_solve(::Type{T}=Float64;rest...) where {T} = amgb(fem1d(T;rest...);rest...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/de439ed9efe12bda71af4b005010c4296237c1ec/src/fem1d.jl#L14-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.fem2d-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#MultiGridBarrier.fem2d-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.fem2d</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fem2d(::Type{T}=Float64; L=2, K=T[-1 -1;1 -1;-1 1;1 -1;1 1;-1 1], kwargs...)</code></pre><p>Construct 2D FEM geometry (quadratic + bubble) on a triangular mesh. Returns a Geometry suitable for use with <code>amgb</code>. Keywords: <code>L</code> levels, <code>K</code> 3n×2 vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/de439ed9efe12bda71af4b005010c4296237c1ec/src/fem2d.jl#L101-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.fem2d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#MultiGridBarrier.fem2d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.fem2d_solve</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fem2d_solve(::Type{T}=Float64;rest...) where {T} = amgb(fem2d(T;rest...);rest...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/de439ed9efe12bda71af4b005010c4296237c1ec/src/fem2d.jl#L14-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.interpolate" href="#MultiGridBarrier.interpolate"><code>MultiGridBarrier.interpolate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interpolate(M::Geometry, z::Vector, t)</code></pre><p>Interpolate a solution vector at specified points.</p><p>Given a solution <code>z</code> on the mesh <code>M</code>, evaluates the solution at new points <code>t</code> using the appropriate interpolation method for the discretization.</p><p>Supported discretizations</p><ul><li>1D FEM (<code>FEM1D</code>): piecewise-linear interpolation</li><li>1D spectral (<code>SPECTRAL1D</code>): spectral polynomial interpolation</li><li>2D spectral (<code>SPECTRAL2D</code>): tensor-product spectral interpolation</li></ul><p>Note: 2D FEM interpolation is not currently provided.</p><p><strong>Arguments</strong></p><ul><li><code>M::Geometry</code>: The geometry containing grid and basis information</li><li><code>z::Vector</code>: Solution vector on the finest grid (length must match number of DOFs)</li><li><code>t</code>: Evaluation points. Format depends on dimension:<ul><li>1D: scalar or <code>Vector{T}</code> of x-coordinates</li><li>2D spectral: <code>Matrix{T}</code> where each row is <code>[x, y]</code></li></ul></li></ul><p><strong>Returns</strong></p><p>Interpolated values at the specified points. Shape matches input <code>t</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># 1D interpolation (FEM)
geom = fem1d(L=3)
z = sin.(π .* vec(geom.x))
y = interpolate(geom, z, 0.5)
y_vec = interpolate(geom, z, [-0.5, 0.0, 0.5])

# 2D interpolation (spectral)
geom = spectral2d(n=4)
z = exp.(-geom.x[:,1].^2 .- geom.x[:,2].^2)
points = [0.0 0.0; 0.5 0.5; -0.5 0.5]
vals = interpolate(geom, z, points)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/de439ed9efe12bda71af4b005010c4296237c1ec/src/AlgebraicMultiGridBarrier.jl#L4-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.parabolic_solve-Union{Tuple{}, Tuple{Geometry{T, Mat, Discretization}}, Tuple{Discretization}, Tuple{Mat}, Tuple{T}} where {T, Mat, Discretization}" href="#MultiGridBarrier.parabolic_solve-Union{Tuple{}, Tuple{Geometry{T, Mat, Discretization}}, Tuple{Discretization}, Tuple{Mat}, Tuple{T}} where {T, Mat, Discretization}"><code>MultiGridBarrier.parabolic_solve</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">parabolic_solve(geometry::Geometry{T,Mat,Discretization}=fem2d(); kwargs...)</code></pre><p>Solve time-dependent p-Laplace problems using implicit Euler timestepping.</p><p>Solves the parabolic PDE:</p><p class="math-container">\[u_t - \nabla \cdot (\|\nabla u\|_2^{p-2}\nabla u) = -f_1\]</p><p>using implicit Euler discretization and barrier methods.</p><p><strong>Arguments</strong></p><ul><li><code>geometry</code>: Discretization geometry (default: <code>fem2d()</code>)</li></ul><p><strong>Keyword Arguments</strong></p><p><strong>Discretization</strong></p><ul><li><code>state_variables</code>: State variables (default: <code>[:u :dirichlet; :s1 :full; :s2 :full]</code>)</li><li><code>D</code>: Differential operators (default depends on dimension)</li><li><code>dim::Int</code>: Spatial dimension (auto-detected from geometry)</li></ul><p><strong>Time Integration</strong></p><ul><li><code>t0::T=0</code>: Initial time</li><li><code>t1::T=1</code>: Final time</li><li><code>h::T=0.2</code>: Time step size</li></ul><p><strong>Problem Parameters</strong></p><ul><li><code>p::T=1</code>: Exponent for p-Laplacian</li><li><code>f1</code>: Source term function (default: <code>x-&gt;T(0.5)</code>)</li><li><code>f</code>: Full forcing function (derived from f1 by default)</li><li><code>g</code>: Initial/boundary conditions (default depends on dimension)</li><li><code>Q</code>: Convex constraints (default: appropriate for p-Laplace)</li></ul><p><strong>Output Control</strong></p><ul><li><code>verbose::Bool=true</code>: Show progress bar</li><li><code>show::Bool=true</code>: Show animation after solving (calls <code>plot(M, ts, U[:,1,:]; printer=...)</code>)</li><li><code>printer</code>: Function to display the animation produced by <code>plot</code>. Takes a single argument <code>animation::matplotlib.animation.FuncAnimation</code> and displays it. Default: <code>(animation)-&gt;display(&quot;text/html&quot;, animation.to_html5_video(embed_limit=200.0))</code>. Custom printers can save to file (e.g., <code>(anim)-&gt;anim.save(&quot;output.mp4&quot;)</code>) or use alternative display methods.</li></ul><p><strong>Additional Parameters</strong></p><ul><li><code>rest...</code>: Passed to <code>amgb</code> for each time step</li></ul><p><strong>Returns</strong></p><p>ParabolicSOL with fields:</p><ul><li><code>geometry</code>: the Geometry used</li><li><code>ts::Vector{T}</code>: time stamps (seconds)</li><li><code>u::Array{T,3}</code>: solution tensor of size <code>(n_nodes, n_components, n_timesteps)</code></li></ul><p>You can animate directly with <code>plot(sol)</code> (or <code>plot(sol, k)</code> for component k). To save, pass a printer, e.g. <code>plot(sol; printer=anim-&gt;anim.save(&quot;out.mp4&quot;))</code>.</p><p><strong>Mathematical Formulation</strong></p><p>The implicit Euler scheme <span>$u_t ≈ (u_{k+1}-u_k)/h$</span> gives:</p><p class="math-container">\[u_{k+1} - h\nabla \cdot (\|\nabla u_{k+1}\|^{p-2}\nabla u_{k+1}) = u_k - hf_1\]</p><p>We minimize the functional:</p><p class="math-container">\[J(u) = \int_Ω \frac{1}{2}u² + \frac{h}{p}\|\nabla u\|^p + (hf_1 - u_k)u \, dx\]</p><p>With slack variables <span>$s_1 ≥ u²$</span> and <span>$s_2 ≥ \|\nabla u\|^p$</span>, this becomes:</p><p class="math-container">\[\min \int_Ω \frac{1}{2}s_1 + \frac{h}{p}s_2 + (hf_1 - u_k)u \, dx\]</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Basic 2D heat equation (p=2)
U = parabolic_solve(; p=2.0, h=0.1)

# 1D p-Laplace with custom parameters
U = parabolic_solve(fem1d(L=5); p=1.5, h=0.05, t1=2.0)

# Spectral discretization without animation
U = parabolic_solve(spectral2d(n=8); show=false, verbose=true)

# Custom initial condition
g_init(t, x) = [exp(-10*(x[1]^2 + x[2]^2)), 0, 0]
U = parabolic_solve(; g=g_init)</code></pre><p><strong>See Also</strong></p><ul><li><a href="#MultiGridBarrier.amgb-Union{Tuple{}, Tuple{Geometry{T, Mat, Discretization}}, Tuple{Discretization}, Tuple{Mat}, Tuple{T}} where {T, Mat, Discretization}"><code>amgb</code></a>: Single time step solver</li><li><a href="#PyPlot.plot"><code>plot</code></a>: Animation and plotting function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/de439ed9efe12bda71af4b005010c4296237c1ec/src/Parabolic.jl#L29-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.spectral1d-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#MultiGridBarrier.spectral1d-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.spectral1d</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spectral1d(::Type{T}=Float64; n=16, kwargs...)</code></pre><p>Construct 1D spectral geometry with n Chebyshev nodes (degree n-1). Returns a Geometry suitable for use with <code>amgb</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/de439ed9efe12bda71af4b005010c4296237c1ec/src/spectral1d.jl#L127-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.spectral1d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#MultiGridBarrier.spectral1d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.spectral1d_solve</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spectral1d_solve(::Type{T}=Float64;rest...) where {T} = amgb(spectral1d(T;rest...);rest...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/de439ed9efe12bda71af4b005010c4296237c1ec/src/spectral1d.jl#L15-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.spectral2d-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#MultiGridBarrier.spectral2d-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.spectral2d</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spectral2d(::Type{T}=Float64; n=4, kwargs...)</code></pre><p>Construct 2D spectral geometry with n×n Chebyshev nodes on [-1,1]^2. Returns a Geometry suitable for use with <code>amgb</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/de439ed9efe12bda71af4b005010c4296237c1ec/src/spectral2d.jl#L21-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.spectral2d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#MultiGridBarrier.spectral2d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.spectral2d_solve</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spectral2d_solve(::Type{T}=Float64;rest...) where {T} = amgb(spectral2d(T;rest...);rest...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/de439ed9efe12bda71af4b005010c4296237c1ec/src/spectral2d.jl#L13-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.stopping_exact-Tuple{T} where T" href="#MultiGridBarrier.stopping_exact-Tuple{T} where T"><code>MultiGridBarrier.stopping_exact</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">stopping_exact(theta::T) where {T}</code></pre><p>Create an exact stopping criterion for Newton methods.</p><p><strong>Arguments</strong></p><ul><li><code>theta</code> : tolerance parameter for gradient norm relative decrease (type T).</li></ul><p><strong>Returns</strong></p><p>A stopping criterion function with signature: <code>stop(ymin, ynext, gmin, gnext, n, ndecmin, ndec) -&gt; Bool</code></p><p>where:</p><ul><li><code>ymin</code> : minimum objective value seen so far.</li><li><code>ynext</code> : current objective value.</li><li><code>gmin</code> : minimum gradient norm seen so far.</li><li><code>gnext</code> : current gradient vector.</li><li><code>n</code> : current Newton direction.</li><li><code>ndecmin</code> : square root of minimum Newton decrement seen so far.</li><li><code>ndec</code> : square root of current Newton decrement.</li></ul><p><strong>Algorithm</strong></p><p>Returns <code>true</code> (stop) if both conditions hold:</p><ol><li>No objective improvement: <code>ynext ≥ ymin</code></li><li>Gradient norm stagnation: <code>‖gnext‖ ≥ theta * gmin</code></li></ol><p><strong>Notes</strong></p><p>This criterion is &quot;exact&quot; in the sense that it requires both objective and gradient stagnation before stopping, making it suitable for high-precision optimization. Typical values of <code>theta</code> are in the range [0.1, 0.9].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/de439ed9efe12bda71af4b005010c4296237c1ec/src/AlgebraicMultiGridBarrier.jl#L771-L801">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultiGridBarrier.stopping_inexact-Union{Tuple{T}, Tuple{T, T}} where T" href="#MultiGridBarrier.stopping_inexact-Union{Tuple{T}, Tuple{T, T}} where T"><code>MultiGridBarrier.stopping_inexact</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">stopping_inexact(lambda_tol::T, theta::T) where {T}</code></pre><p>Create an inexact stopping criterion for Newton methods that combines Newton decrement and exact stopping conditions.</p><p><strong>Arguments</strong></p><ul><li><code>lambda_tol</code> : tolerance for the Newton decrement (type T).</li><li><code>theta</code> : tolerance parameter for the exact stopping criterion (type T).</li></ul><p><strong>Returns</strong></p><p>A stopping criterion function with signature: <code>stop(ymin, ynext, gmin, gnext, n, ndecmin, ndec) -&gt; Bool</code></p><p>where:</p><ul><li><code>ymin</code> : minimum objective value seen so far.</li><li><code>ynext</code> : current objective value.</li><li><code>gmin</code> : minimum gradient norm seen so far.</li><li><code>gnext</code> : current gradient vector.</li><li><code>n</code> : current Newton direction.</li><li><code>ndecmin</code> : square root of minimum Newton decrement seen so far.</li><li><code>ndec</code> : square root of current Newton decrement (√(gᵀH⁻¹g)).</li></ul><p><strong>Algorithm</strong></p><p>Returns <code>true</code> (stop) if either condition holds:</p><ol><li>Newton decrement condition: <code>ndec &lt; lambda_tol</code></li><li>Exact stopping condition: <code>stopping_exact(theta)</code> is satisfied</li></ol><p><strong>Notes</strong></p><p>This criterion is &quot;inexact&quot; because it allows early termination based on the Newton decrement, which provides a quadratic convergence estimate. The Newton decrement <code>λ = √(gᵀH⁻¹g)</code> approximates the distance to the optimum in the Newton metric. Typical values: <code>lambda_tol ∈ [1e-6, 1e-3]</code>, <code>theta ∈ [0.1, 0.9]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/de439ed9efe12bda71af4b005010c4296237c1ec/src/AlgebraicMultiGridBarrier.jl#L803-L836">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PyPlot.plot" href="#PyPlot.plot"><code>PyPlot.plot</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot(sol::AMGBSOL, k::Int=1; kwargs...)
plot(sol::ParabolicSOL, k::Int=1; kwargs...)
plot(M::Geometry, z::Vector; kwargs...)
plot(M::Geometry, ts::AbstractVector, U::Matrix; printer=..., anim_duration=ts[end]-ts[1])</code></pre><p>Visualize solutions and time sequences on meshes.</p><ul><li>1D problems: Line plot. For spectral methods, you can specify evaluation points with <code>x=-1:0.01:1</code>.</li><li>2D FEM: Triangulated surface plot using the mesh structure.</li><li>2D spectral: 3D surface plot. You can specify evaluation grids with <code>x=-1:0.01:1, y=-1:0.01:1</code>.</li></ul><p>Time sequences (animation):</p><ul><li>Call <code>plot(M, ts, U; printer=..., anim_duration=ts[end]-ts[1])</code> where <code>U</code> has columns as frames and <code>ts</code> are absolute times in seconds (non-uniform allowed).</li><li>Or simply call <code>plot(sol)</code> where <code>sol</code> is a <code>ParabolicSOL</code> returned by <code>parabolic_solve</code> (uses <code>sol.ts</code>).</li><li>Timing is based on <code>(ts - ts[1])</code> rescaled to the total animation duration <code>anim_duration</code> (default <code>ts[end]-ts[1]</code>).</li><li>After rescaling, times are rounded to integer milliseconds; frames landing on the same millisecond are skipped.</li><li>The <code>printer</code> callback receives the Matplotlib animation object; use it to display or save (e.g., <code>anim.save(&quot;out.mp4&quot;)</code>).</li></ul><p>When <code>sol</code> is a solution object returned by <code>amgb</code> or the <code>*_solve</code> helpers, <code>plot(sol,k)</code> plots the kth component <code>sol.z[:, k]</code> using <code>sol.geometry</code>. <code>plot(sol)</code> uses the default k=1.</p><p>All other keyword arguments are passed to the underlying <code>PyPlot</code> functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sloisel/MultiGridBarrier.jl/blob/de439ed9efe12bda71af4b005010c4296237c1ec/src/AlgebraicMultiGridBarrier.jl#L45-L68">source</a></section></article><h1 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h1><ul><li><a href="#MultiGridBarrier.MultiGridBarrier"><code>MultiGridBarrier.MultiGridBarrier</code></a></li><li><a href="#MultiGridBarrier.AMGBConvergenceFailure"><code>MultiGridBarrier.AMGBConvergenceFailure</code></a></li><li><a href="#MultiGridBarrier.Convex"><code>MultiGridBarrier.Convex</code></a></li><li><a href="#MultiGridBarrier.FEM1D"><code>MultiGridBarrier.FEM1D</code></a></li><li><a href="#MultiGridBarrier.FEM2D"><code>MultiGridBarrier.FEM2D</code></a></li><li><a href="#MultiGridBarrier.Geometry"><code>MultiGridBarrier.Geometry</code></a></li><li><a href="#MultiGridBarrier.SPECTRAL1D"><code>MultiGridBarrier.SPECTRAL1D</code></a></li><li><a href="#MultiGridBarrier.SPECTRAL2D"><code>MultiGridBarrier.SPECTRAL2D</code></a></li><li><a href="#Base.intersect-Union{Tuple{T}, Tuple{Convex{T}, Vararg{Any}}} where T"><code>Base.intersect</code></a></li><li><a href="#MultiGridBarrier.amgb-Union{Tuple{}, Tuple{Geometry{T, Mat, Discretization}}, Tuple{Discretization}, Tuple{Mat}, Tuple{T}} where {T, Mat, Discretization}"><code>MultiGridBarrier.amgb</code></a></li><li><a href="#MultiGridBarrier.apply_D-Union{Tuple{T}, Tuple{Any, Vector{T}}} where T"><code>MultiGridBarrier.apply_D</code></a></li><li><a href="#MultiGridBarrier.convex_Euclidian_power-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.convex_Euclidian_power</code></a></li><li><a href="#MultiGridBarrier.convex_linear-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.convex_linear</code></a></li><li><a href="#MultiGridBarrier.convex_piecewise-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.convex_piecewise</code></a></li><li><a href="#MultiGridBarrier.fem1d-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.fem1d</code></a></li><li><a href="#MultiGridBarrier.fem1d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.fem1d_solve</code></a></li><li><a href="#MultiGridBarrier.fem2d-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.fem2d</code></a></li><li><a href="#MultiGridBarrier.fem2d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.fem2d_solve</code></a></li><li><a href="#MultiGridBarrier.interpolate"><code>MultiGridBarrier.interpolate</code></a></li><li><a href="#MultiGridBarrier.parabolic_solve-Union{Tuple{}, Tuple{Geometry{T, Mat, Discretization}}, Tuple{Discretization}, Tuple{Mat}, Tuple{T}} where {T, Mat, Discretization}"><code>MultiGridBarrier.parabolic_solve</code></a></li><li><a href="#MultiGridBarrier.spectral1d-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.spectral1d</code></a></li><li><a href="#MultiGridBarrier.spectral1d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.spectral1d_solve</code></a></li><li><a href="#MultiGridBarrier.spectral2d-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.spectral2d</code></a></li><li><a href="#MultiGridBarrier.spectral2d_solve-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>MultiGridBarrier.spectral2d_solve</code></a></li><li><a href="#MultiGridBarrier.stopping_exact-Tuple{T} where T"><code>MultiGridBarrier.stopping_exact</code></a></li><li><a href="#MultiGridBarrier.stopping_inexact-Union{Tuple{T}, Tuple{T, T}} where T"><code>MultiGridBarrier.stopping_inexact</code></a></li><li><a href="#PyPlot.plot"><code>PyPlot.plot</code></a></li></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 9 October 2025 23:51">Thursday 9 October 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
